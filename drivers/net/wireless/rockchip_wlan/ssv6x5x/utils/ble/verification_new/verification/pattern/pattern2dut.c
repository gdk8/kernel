#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>

#include "task.h"
#include "types.h"
#include "ctrl_bench.h"
#include "pattern2dut.h"
#include "../log/log.h"

#include "../bench/cli/cli.h"
#include "./hci_tools/lib/ssv_lib.h"
#include "./hci_tools/lib_bt/bt_hci_cmd_declare.h"
#include "./hci_tools/host_cli.h"
#include "./hci_tools/lib_bluez/bluetooth.h"
#include "./hci_tools/lib_bluez/hci.h"
#include "./hci_tools/lib_bluez/hci_lib.h"

#include "./pattern/param_pattern.h"
#include "./pattern/cli_cmd_master.h"
#include "./pattern/cli_cmd_bcmd.h"

enum {
    DUT_TYPE_TI = 1 ,
    DUT_TYPE_SSV,
    DUT_TYPE_CSR
};

enum {
    TI_CONT_TX_MOD = 0,
    TI_CONT_TX_TP,
    TI_CONT_TX_FREQ,
    TI_CONT_TX_PWR,
    TI_CONT_TX_PARAM_NUM
};

enum {
    TI_PKT_TXRX_FREQ_MODE = 0,
    TI_PKT_TXRX_TX_CH,
    TI_PKT_TXRX_RX_CH,
    TI_PKT_TXRX_PKT_TYPE,
    TI_PKT_TXRX_PKT_PATTERN,
	TI_PKT_TXRX_PKT_LEN,
	TI_PKT_TXRX_PWR_LEVEL,
	TI_PKT_TXRX_PRBS9,
	TI_PKT_TXRX_PARAM_NUM
};

enum {
    TI_BER_METER_START_FREQ = 0,
    TI_BER_METER_START_PKT_TYPE,
    TI_BER_METER_START_PKT_LEN,
    TI_BER_METER_START_NUM_OF_PKT,
	TI_BER_METER_START_PRBS9,
    TI_BER_METER_START_PARAM_NUM
};

typedef enum {
    CFG_DEFAULT = 0,
    CFG_ADV     ,
    CFG_SCAN    ,
    CFG_MULTIROLE   ,
    CFG_SLAVE   ,
    CFG_MASTER  
}enum_cfg;

#define ACL_DATA_MAX 27
#define FIXED_MAS_LE_PDU_BUF 4


static u8 READ_LE_EVENT =0;

static u8  s_manufacturer[2]= {0};
static u8  s_subversion[2]  = {0};
static u8  s_dev_num        = 0;
static u8  s_dev_type[MAX_DUTS+1]    = {0};
static u32 s_pkt_cnt        = 100;
static struct timeval timeStart, timeEnd;

#define CH_MAP_FULL 0x1FFFFFFFFF
#define CH_MAP_ODD  0x0AAAAAAAAA
#define CH_MAP_EVEN 0x1555555555

u8 scan_addr[ADDR_LENGTH]           = {0x4F, 0x80, 0xCD, 0x72, 0x39, 0xD0};
u8 adv_addr[ADDR_LENGTH]            = {0x00, 0x80, 0xCD, 0x72, 0x39, 0xD0};
u8 init_addr[ADDR_LENGTH]           = {0xF0, 0x60, 0x25, 0x8C, 0xBA, 0x1C};
u8 scan_random_addr[ADDR_LENGTH]    = {0x66, 0x55, 0x44, 0x33, 0x22, 0x11};
u8 adv_random_addr[ADDR_LENGTH]     = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
u8 zero_addr[ADDR_LENGTH]           = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

typedef struct {
    u8  dut_type;
    int dut_fd;
    u8  dut_addr[ADDR_LENGTH];
    u8  dut_random_addr[ADDR_LENGTH]; 
}dut_setting;

dut_setting Dut_setting[MAX_DUTS+1];

u8 error_addr[ADDR_LENGTH]          = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
u8 dut1_error_com_ass[ADDR_LENGTH]  = {0x4F, 0x80, 0xCD, 0x44, 0x55, 0x66};
u8 dut1_error_com_idf[ADDR_LENGTH]  = {0x11, 0x22, 0x33, 0x72, 0x39, 0xD0};
u8 dut1_error_both[ADDR_LENGTH]     = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};

u8 dut2_error_com_ass[ADDR_LENGTH]  = {0x00, 0x80, 0xCD, 0x44, 0x55, 0x66};
u8 dut2_error_com_idf[ADDR_LENGTH]  = {0x11, 0x22, 0x33, 0x72, 0x39, 0xD0};
u8 dut2_error_both[ADDR_LENGTH]     = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};

u8 enc_rand[8] = {0x90, 0x78, 0x56, 0x34, 0x12, 0xEF, 0xCD, 0xAB};
u8 enc_ediv[2] = {0x74, 0x24};
u8 enc_ltk[16] = {0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,0x11,0x22,0x33,0x44,0x55,0x66};

u8 dut2_error_conn_handles[2] = {0x03, 0x00};

#define PRINT_TIME \
    {\
        char now[256];\
        log_time(now);\
        printf("%s " ,now);\
    }\

#define HCI_WRITEDATA(PARAM)	\
        PRINT_TIME \
		ret=bt_hci_write_data2socket(dut_fd, &PARAM);	\
		if(SOCKET_SUCCESS != ret)	\
			return FAIL;	\


#define HCI_WRITEDATA_AND_NUMPACKETS_PARSING(PARAM)	\
        PRINT_TIME \
		ret=bt_hci_write_data2socket(dut_fd, &PARAM);	\
		if(SOCKET_SUCCESS != ret)	\
			return FAIL;	\
        do{ \
            ret=socket_msg_get(dut_fd,&len,buf);\
        }while(len <=0);    \
        if(SOCKET_SUCCESS != ret)   \
            return FAIL;    \
		printf("Get Event(%d):\n",dut_fd);	\
		print_charray(len,buf); \
		\
		printf("%d packets completed\n ", hci_event_num_of_completed_packets_parsing(buf)); \

#define HCI_WRITECMD(PARAM)	\
        PRINT_TIME \
		ret=bt_hci_write_cmd2socket(dut_fd, &PARAM);	\
		if(SOCKET_SUCCESS != ret)	\
			return FAIL;	\

#define HCI_WRITECMD_AND_GETEVENT_PARSING(PARAM)	\
        PRINT_TIME \
		ret=bt_hci_write_cmd2socket(dut_fd, &PARAM);	\
		if(SOCKET_SUCCESS != ret)	\
			return FAIL;	\
		do{   \
    		ret=socket_msg_get(dut_fd,&len,buf);	\
		}while(len <=0);    \
        if(SOCKET_SUCCESS != ret)   \
            return FAIL;    \
		printf("Get Event(%d):              ",dut_fd);	\
        ret = hci_event_command_complete_parsing(buf);\
        if (CMD_SUCCESS == ret){ \
			printf("# command complete (success)\n");   \
        } \
        else{   \
            printf("# command complete (failed 0x%02x)\n" , ret); \
        }\
        print_charray(len,buf); \


#define HCI_WRITECMD_AND_GETEVENT_PARSING_CMD_STATUS(PARAM) \
        PRINT_TIME \
		ret=bt_hci_write_cmd2socket(dut_fd, &PARAM);	\
		if(SOCKET_SUCCESS != ret)	\
			return FAIL;	\
        do{   \
            ret=socket_msg_get(dut_fd,&len,buf);    \
        }while(len <=0);    \
        if(SOCKET_SUCCESS != ret)   \
            return FAIL;    \
        printf("Get Event(%d):              ",dut_fd);  \
        ret = hci_event_command_status_parsing(buf);\
        if (CMD_SUCCESS == ret) {   \
            printf("# command status (success)\n"); \
        }  \
        else{   \
            printf("# command status (failed 0x%02x)\n" , ret); \
        }\
        print_charray(len,buf); \
		
#define VERDICT_FAIL_RESULT_WITH_LINE()	\
        if (PASS == verdict)    \
        {   \
            line=__LINE__;  \
            goto FUN_FAIL;  \
        }

#define VERDICT_RESULT_WITH_LINE()	\
		if (PASS != verdict)	\
		{	\
			line=__LINE__;	\
			goto FUN_FAIL;	\
		}

#define VERDICT_ERROR_CODE_CHECK_WITH_LINE(ERRORCODE)	\
		if (ERRORCODE != verdict)	\
		{	\
			line=__LINE__;	\
			goto FUN_FAIL;	\
		}

#define FUNC_END() \
        printf(INV "\n                               [run func end]                               \n" NONE);\
        event_query_timer_stop(&timer); \
        read_le_event_disable(); \
        COMM_Dut_check_payload(dut1_fd , 0); \
    	dut_reset_with_mask_en(dut1_fd); \
        COMM_Dut_check_payload(dut2_fd , 0); \
        dut_reset_with_mask_en(dut2_fd); \
        printf(INV "\n                               [run func end]                               \n" NONE);\
        gettimeofday(&timeEnd, NULL);   \
        LOG_INFO("Execution Time : %d sec\n", (u32)(timeEnd.tv_sec - timeStart.tv_sec));

#define MULTIROLE_FUNC_END() \
        {\
            printf(INV "\n[run func end]\n" NONE);\
            event_query_timer_stop(&timer); \
            read_le_event_disable(); \
            int dut_cnt = 0; \
            for(dut_cnt = 0; dut_cnt < MAX_DUTS+1; dut_cnt++) { \
                if(Dut_setting[dut_cnt].dut_fd != 0) \
                    COMM_Dut_check_payload(Dut_setting[dut_cnt].dut_fd, 0); \
            }\
            for(dut_cnt = 0; dut_cnt < MAX_DUTS+1; dut_cnt++) { \
                if(Dut_setting[dut_cnt].dut_fd != 0) \
                    dut_reset_with_mask_en(Dut_setting[dut_cnt].dut_fd); \
            }\
            gettimeofday(&timeEnd, NULL);   \
            LOG_INFO("Execution Time : %d sec\n", (u32)(timeEnd.tv_sec - timeStart.tv_sec)); \
        }\

#define LOG_TIME() \
        gettimeofday(&start_time,NULL); \
        LOG_INFO("\n###time = %ld %ld###\n",start_time.tv_sec ,start_time.tv_usec); \

#define CHECK_CONNECT() \
        printf("\ncheck connect with dut 1\n");    \
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) { \
    	    line = __LINE__;    \
    	    goto FUN_FAIL;  \
    	}   \
    	else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) { \
    	    line = __LINE__;    \
    	    goto FUN_FAIL;  \
    	}   \
        printf("\ncheck connect with dut 2\n");    \
        if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) { \
    	    line = __LINE__;    \
    	    goto FUN_FAIL;  \
    	}   \
    	else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) { \
    	    line = __LINE__;    \
    	    goto FUN_FAIL;  \
    	}   \

#define CHECK_NON_DISCONNECT()  \
         printf("\ncheck disconnect with dut 1\n");    \
         if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    \
             line = __LINE__;   \
             goto FUN_FAIL; \
         }  else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {    \
             line = __LINE__;   \
             goto FUN_FAIL; \
         }  \
         if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) { \
             line = __LINE__;   \
             goto FUN_FAIL; \
         }  \
         printf("\ncheck disconnect with dut 2\n");    \
         if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {   \
             line = __LINE__;   \
             goto FUN_FAIL; \
         }  else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {    \
             line = __LINE__;   \
             goto FUN_FAIL; \
         }  \
         if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) { \
             line = __LINE__;   \
             goto FUN_FAIL; \
         }  \


#define ADV_TIME_IND_PATTERN_CONFIG_READ() pattern_config_read(__FUNCTION__ , ADV_PARAM_TIME_INDEP );
#define ADV_TIME_DEP_PATTERN_CONFIG_READ() pattern_config_read(__FUNCTION__ , ADV_PARAM_TIME_DEP   );
#define SCN_TIME_IND_PATTERN_CONFIG_READ() pattern_config_read(__FUNCTION__ , SCAN_PARAM_TIME_INDEP   );
#define SCN_TIME_DEP_PATTERN_CONFIG_READ() pattern_config_read(__FUNCTION__ , SCAN_PARAM_TIME_DEP   );
#define SLA_TIME_IND_PATTERN_CONFIG_READ() pattern_config_read(__FUNCTION__ , SLAVE_PARAM_TIME_INDEP   );
#define SLA_TIME_DEP_PATTERN_CONFIG_READ() pattern_config_read(__FUNCTION__ , SLAVE_PARAM_TIME_DEP   );
#define ADV_STABLE_PATTERN_CONFIG_READ()   pattern_config_read(__FUNCTION__ , ADV_STABLE   );
#define SCN_STABLE_PATTERN_CONFIG_READ()   pattern_config_read(__FUNCTION__ , SCAN_STABLE   );
#define SLA_STABLE_PATTERN_CONFIG_READ()   pattern_config_read(__FUNCTION__ , SLAVE_STABLE   );
#define SLA_STRESS_PATTERN_CONFIG_READ()   pattern_config_read(__FUNCTION__ , SLAVE_STRESS   );
#define MULTIROLE_SLA_PERF_PATTERN_CONFIG_READ() pattern_config_read(__FUNCTION__ , MULTIROLE_SLA_PERF);


#define MSLEEP(val) usleep(val * 1000)

Pattern_param g_pattern_param;

/*
util
*/
char* 	dut_type_str(u8 dut_type) {
	switch (dut_type) {
    case DUT_TYPE_TI:	return "TI";
    case DUT_TYPE_SSV:	return "SSV";
    case DUT_TYPE_CSR:	return "CSR";
	}
	return "UNKNOWN";
}

void fill_data(u8 * source , u32 send_cnt){

    source[0] = (send_cnt & 0x00ff0000) >> 16 ; 
    source[1] = (send_cnt & 0x0000ff00) >>  8 ;
    source[2] = (send_cnt & 0x000000ff) ;

}

void acl_data_gen_tbx(u8 *acl_data , u8 len , u8 val)
{
	u8 cnt = 0;
	for ( ; cnt < len ; cnt ++){		
		acl_data[cnt+4] = val;
	}
}

void dump_fail_reason(Fail_reason *reason){

    LOG_INFO(" reason.instant_passed                 %d \n" , reason->instant_passed      );            
    LOG_INFO(" reason.no_conn_req                    %d \n" , reason->no_conn_req         );
    LOG_INFO(" reason.no_num_pkt_comp                %d \n" , reason->no_num_pkt_comp     );
    LOG_INFO(" reason_fail_to_establish              %d \n" , reason->fail_to_establish   );
    LOG_INFO(" reason.connection_timeout             %d \n" , reason->connection_timeout  );
    LOG_INFO(" reason.error_pld_acl                  %d \n" , reason->error_pld_acl       );
    LOG_INFO(" reason.error_no_acl                   %d \n" , reason->error_no_acl        );
    LOG_INFO(" reason.instant_passed                 %d \n" , reason->instant_passed      );
    LOG_INFO(" reason.no_encrypt_change_master       %d \n" , reason->no_encrypt_change_master      );   
    LOG_INFO(" reason.no_encrypt_change_slave        %d \n" , reason->no_encrypt_change_slave       );
}

int hci_event_num_of_completed_packets_parsing(u8 * event_parameter){
	return (event_parameter[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
			event_parameter[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS];
}

int hci_event_command_status_parsing(u8 * event_parameter){
	return event_parameter[_BT_HCI_IDX_CMD_STATUS];
}

int hci_event_command_complete_parsing(u8 * event_parameter){
	return event_parameter[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
}

int hci_event_encryption_change_parsing(int adv_type,u8 * event_parameter ,Pattern_param param)
{
	printf("Status = %d\n" ,	event_parameter[_BT_HCI_EVT_ENCRYPTION_CHANGE_STATUS]);
	printf("Connection_Handle = 0x%02x 0x%02x\n" ,
		event_parameter[_BT_HCI_EVT_ENCRYPTION_CHANGE_CONN_HANDLE],
		event_parameter[_BT_HCI_EVT_ENCRYPTION_CHANGE_CONN_HANDLE+1]);
	printf("Encryption_Enabled = %d\n\n" ,	event_parameter[_BT_HCI_EVT_ENCRYPTION_CHANGE_ENABLED]);

    if ((event_parameter[_BT_HCI_EVT_ENCRYPTION_CHANGE_CONN_HANDLE] == 0) && 
        (event_parameter[_BT_HCI_EVT_ENCRYPTION_CHANGE_CONN_HANDLE+1] == 0)){
        return __LINE__ ; 
    }
    else{      
    	return event_parameter[_BT_HCI_EVT_DISCONN_COMP_STATUS];
    }
}

int hci_event_encryption_key_refresh_complte_parsing(int adv_type,u8 * event_parameter ,Pattern_param param)
{
	printf("Status = %d\n" ,	event_parameter[_BT_HCI_EVT_ENCRYPTION_KEY_REFRESH_COMPLETE_STATUS]);
	printf("Connection_Handle = 0x%02x 0x%02x\n\n" ,
		event_parameter[_BT_HCI_EVT_ENCRYPTION_KEY_REFRESH_COMPLETE_CONN_HANDLE],
		event_parameter[_BT_HCI_EVT_ENCRYPTION_KEY_REFRESH_COMPLETE_CONN_HANDLE+1]);

    if ((event_parameter[_BT_HCI_EVT_ENCRYPTION_KEY_REFRESH_COMPLETE_CONN_HANDLE] == 0) && 
        (event_parameter[_BT_HCI_EVT_ENCRYPTION_KEY_REFRESH_COMPLETE_CONN_HANDLE+1] == 0)){
        return __LINE__ ; 
    }        
    else{
	    return event_parameter[_BT_HCI_EVT_DISCONN_COMP_STATUS];
    }

}


int hci_event_disconnection_complete_parsing(int adv_type,u8 * event_parameter ,Pattern_param param)
{

	printf("Status = %d\n" ,	event_parameter[_BT_HCI_EVT_DISCONN_COMP_STATUS]);
    printf("Connection_Handle = 0x%02x 0x%02x\n" ,
        event_parameter[_BT_HCI_EVT_DISCONN_COMP_HANDLE],
        event_parameter[_BT_HCI_EVT_DISCONN_COMP_HANDLE+1]);
	printf("Disconnect Reason = 0x%x\n\n" , event_parameter[_BT_HCI_EVT_DISCONN_COMP_REASON]);

	return event_parameter[_BT_HCI_EVT_DISCONN_COMP_STATUS];
}

int hci_event_read_remote_version_information_complete_parsing(u8 * event_parameter ,Pattern_param param)
{
	printf("Status = %d\n" ,	event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_STATUS]);
	printf("Connection_Handle = 0x%02x 0x%02x\n" ,
		event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_CONN_HANDLE],
		event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_CONN_HANDLE+1]);
	printf("Version = %d\n" ,	event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_VER]);
	printf("Manufacturer_Name = 0x%02x 0x%02x\n" ,
		event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_MANU_NAME],
		event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_MANU_NAME+1]);
	printf("Subversion: = 0x%02x 0x%02x\n\n" ,
		event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_SUBVER],
		event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_SUBVER+1]);
    
    if ((event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_CONN_HANDLE] == 0) && 
        (event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_CONN_HANDLE+1] == 0)){
        return ERROR ; 
    }        
    else{
	    return event_parameter[_BT_HCI_EVT_REMOTE_VER_INFO_STATUS];
    }
}

int hci_event_read_remote_supported_features_complete_parsing(int adv_type,u8 * event_parameter ,Pattern_param param)
{

	printf("Subevent_Code = %d\n" , event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_SUB_CODE]);
	printf("Status = %d\n"		,	event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_STATUS]);
	printf("Connection_Handle = 0x%02x 0x%02x\n" ,
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_HANDLE+0],
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_HANDLE+1]);
	printf("LE_Features = %x%x%x%x%x%x%x%x\n\n" ,
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_LE_FEATURES+0],
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_LE_FEATURES+1],
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_LE_FEATURES+2],
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_LE_FEATURES+3],
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_LE_FEATURES+4],
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_LE_FEATURES+5],
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_LE_FEATURES+6],
		event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_LE_FEATURES+7]
	);

    if ((event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_HANDLE] == 0) && 
        (event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_HANDLE+1] == 0)){
        return ERROR ; 
    }        
    else{
    	return event_parameter[_BT_HCI_EVT_REMOTE_USED_FEATURES_STATUS];
    }
}

int hci_event_read_white_list_size_parsing(u8 * event_parameter)
{
	printf("Status = %d\n" ,	event_parameter[_BT_HCI_EVT_LE_READ_WHITE_LIST_SIZE_STATUS]);
	printf("Size   = %d\n" ,    event_parameter[_BT_HCI_EVT_LE_READ_WHITE_LIST_SIZE]);

	return event_parameter[_BT_HCI_EVT_LE_READ_WHITE_LIST_SIZE_STATUS];
}

int hci_event_read_buff_size_parsing(u8 * event_parameter)
{
	printf("Status = %d\n" ,	event_parameter[_BT_HCI_EVT_LE_READ_BUFF_SIZE_STATUS]);
	printf("Data Pkt Len = %02x %02x\n" ,
		event_parameter[_BT_HCI_EVT_LE_READ_BUFF_SIZE_LE_DATA_PKT_LEN],
		event_parameter[_BT_HCI_EVT_LE_READ_BUFF_SIZE_LE_DATA_PKT_LEN+1]);
	printf("Data Pkts Num = %02x \n\n" ,
		event_parameter[_BT_HCI_EVT_LE_READ_BUFF_SIZE_LE_DATA_PKT_NUM]);

	return event_parameter[_BT_HCI_EVT_LE_READ_BUFF_SIZE_STATUS];
}


int hci_le_event_connection_complete_parsing(int adv_type,u8 * event_parameter ,Pattern_param param)
{
	printf("Subevent_Code = %d\n" , event_parameter[_BT_HCI_EVT_CON_COMP_SUB_CODE]);
	printf("Status = %d\n" ,	event_parameter[_BT_HCI_EVT_CON_COMP_STATUS]);
	printf("Connection_Handle = 0x%02x 0x%02x\n\n" ,
		event_parameter[_BT_HCI_EVT_CON_COMP_CONN_HANDLE],
		event_parameter[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1]);

    if ((event_parameter[_BT_HCI_EVT_CON_COMP_CONN_HANDLE] == 0) && 
        (event_parameter[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] == 0)){
        return __LINE__ ; 
    }        
    else{
	    return event_parameter[_BT_HCI_EVT_CON_COMP_STATUS];
    }
}


int hci_le_event_advertising_report_parsing(int adv_type,u8 * event_parameter ,Pattern_param param)
{
	int ret = EQUAL;

    if(event_parameter[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){
        ret = __LINE__ ;
        return ret ;
    }

    if(event_parameter[_BT_HCI_IDX_EVENT_PARAMETER_] != 0){
        printf("\n");
    	printf("#Subevent_Code   =   %d\n" , event_parameter[_BT_HCI_IDX_EVENT_PARAMETER_]);
    	printf("#Num_Reports     =   %d\n" ,	event_parameter[_BT_HCI_EVT_ADV_RPT_NUM_RPT]);
    }
	//for (;report_cnt < event_parameter[4] ; report_cnt++)
	{
        //if(event_parameter[_BT_HCI_IDX_EVENT_PARAMETER_] != 0)
    	printf("#Event_Type      =   %d\n" ,	event_parameter[_BT_HCI_EVT_ADV_RPT_EVT_TYPE]);
		printf("#Address_Type    =   %d\n" ,	event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR_TYPE]);
		printf("#Address         =   %02x:%02x:%02x:%02x:%02x:%02x\n" ,
			event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR0],event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR1],
			event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR2],event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR3],
			event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR4],event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR5]
			);
		printf("#Length_Data     =   %d\n" ,event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN]);
        
		if(0 != event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN])
			print_charray(event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN],event_parameter+_BT_HCI_EVT_ADV_RPT_DATA);
		//for(;data_len <event_parameter[13] ;data_len++ )
			//printf("%02x " ,event_parameter[14+data_len]);
		printf("#RSSI            =   %x\n\n" ,event_parameter[_BT_HCI_EVT_ADV_RPT_RSSI(event_parameter)]);
	}

    //# addr type check
	if (param.adv_param.Own_Address_Type[0]!=		event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR_TYPE]){
		printf("!addr_type error %d:%d\n" ,         param.adv_param.Own_Address_Type[0] ,	
                                                    event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR_TYPE]);
		ret=__LINE__;
	}

	if( adv_type != HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP){

        //# adv rpt type check
		if (param.adv_param.Advertising_Type[0] !=  event_parameter[_BT_HCI_EVT_ADV_RPT_EVT_TYPE]){
			printf("!adv_type error %d:%d\n" ,		param.adv_param.Advertising_Type[0]
												,	event_parameter[_BT_HCI_EVT_ADV_RPT_EVT_TYPE]);
			ret=__LINE__;
		}
    
	    //# adv rpt data len check
	    if(HCI_CMD_PARAM_ADV_DIRECT_IND != param.adv_param.Advertising_Type[0]){
    		if (param.adv_data_param.Advertising_Data_Length[0] !=		event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN]){
    			printf("!adv_data_len error %d:%d\n" ,
    				param.adv_data_param.Advertising_Data_Length[0],	event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN]);
    			ret=__LINE__;
    		}

    		if(0 != memcmp(param.adv_data_param.Advertising_Data,
    						event_parameter+_BT_HCI_EVT_ADV_RPT_DATA,		
    						event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN])){
    			printf("!adv_data error \n");
    			print_charray(event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN] ,	param.adv_data_param.Advertising_Data);
    			print_charray(event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN] ,	event_parameter+_BT_HCI_EVT_ADV_RPT_DATA);
    			ret=__LINE__;
    		}
	    }    

        
	    if(HCI_CMD_PARAM_ADV_DIRECT_IND == param.adv_param.Advertising_Type[0]){
            if(event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN] != 0){
    			printf("!adv_data_len error %d:%d\n" ,
    				param.adv_data_param.Advertising_Data_Length[0],	event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN]);
    			ret=__LINE__;
            }
	    }
        
	}
	else{//HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP

		if (param.scn_rsp_param.Scan_Response_Data_Length[0] != 	event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN]){
			printf("!scan_rsp_data_len error %d:%d\n" ,
				param.scn_rsp_param.Scan_Response_Data_Length[0],	event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN]);
			ret=__LINE__;
		}

		if(0 != memcmp(param.scn_rsp_param.Scan_Response_Data,
						event_parameter+_BT_HCI_EVT_ADV_RPT_DATA,		
						event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN])){
			printf("!scan_rsp_data error \n");
			print_charray(event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN] ,	param.scn_rsp_param.Scan_Response_Data);
			print_charray(event_parameter[_BT_HCI_EVT_ADV_RPT_DATA_LEN] ,	event_parameter+_BT_HCI_EVT_ADV_RPT_DATA);
			ret=__LINE__;
		}	   
		
	}

	// check the advertiser's address to avoid catch error data  //add by ShaoShih 2015/06/10 

	if(HCI_CMD_PARAM_ADV_DIRECT_IND != param.adv_param.Advertising_Type[0]) {

        if ( 0 != memcmp (param.adv_param.Direct_Address , 
             event_parameter + _BT_HCI_EVT_ADV_RPT_ADDR0 ,
             ADDR_LENGTH)){			 
    			printf("!Direct_Address error \n");
    			printf("!param.adv_param.Advertising_Type : %d \n", param.adv_param.Advertising_Type[0]);
                printf("!param %02x:%02x:%02x:%02x:%02x:%02x\n" , param.adv_param.Direct_Address[0] , param.adv_param.Direct_Address[1] , 
                    param.adv_param.Direct_Address[2] ,param.adv_param.Direct_Address[3] ,param.adv_param.Direct_Address[4] ,
                    param.adv_param.Direct_Address[5] );
                printf("!event %02x:%02x:%02x:%02x:%02x:%02x\n" , event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR0] , event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR1],
                    event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR2] , event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR3],
                    event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR4] , event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR5]);
    			ret = __LINE__; 		   
		}
	}
	else {

        u8 addr_check ;
        //# adv_direct_ind , rpt addr will be advA
        addr_check = (  memcmp(adv_addr             , event_parameter + _BT_HCI_EVT_ADV_RPT_ADDR0 , ADDR_LENGTH) &&
                        memcmp(adv_random_addr      , event_parameter + _BT_HCI_EVT_ADV_RPT_ADDR0 , ADDR_LENGTH) &&
                        memcmp(dut2_error_com_ass   , event_parameter + _BT_HCI_EVT_ADV_RPT_ADDR0 , ADDR_LENGTH) &&
                        memcmp(dut2_error_com_idf   , event_parameter + _BT_HCI_EVT_ADV_RPT_ADDR0 , ADDR_LENGTH) &&
                        memcmp(dut2_error_both      , event_parameter + _BT_HCI_EVT_ADV_RPT_ADDR0 , ADDR_LENGTH) );

        if (addr_check != 0){
            printf("!adv_Address error \n");
            printf("!param.adv_param.Advertising_Type : %d \n", 
                    param.adv_param.Advertising_Type[0]);
            printf("!param %02x:%02x:%02x:%02x:%02x:%02x\n" , 
                    param.adv_param.Direct_Address[0] , param.adv_param.Direct_Address[1] , 
                    param.adv_param.Direct_Address[2] , param.adv_param.Direct_Address[3] ,
                    param.adv_param.Direct_Address[4] , param.adv_param.Direct_Address[5] );
            
            printf("!event %02x:%02x:%02x:%02x:%02x:%02x\n" , 
                event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR0] , event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR1],
                event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR2] , event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR3],
                event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR4] , event_parameter[_BT_HCI_EVT_ADV_RPT_ADDR5]);
            ret = __LINE__;     
        }

	}				  
	
	return ret;
}

int hci_le_event_connection_update_complete_parsing(int adv_type,u8 * event_parameter ,Pattern_param param)
{
	int ret = EQUAL;

	printf("Subevent_Code = %d\n" , event_parameter[_BT_HCI_EVT_CON_COMP_SUB_CODE]);
	printf("Status = %d\n" ,	event_parameter[_BT_HCI_EVT_CON_COMP_STATUS]);
	printf("Connection_Handle = 0x%02x 0x%02x\n" ,
		event_parameter[_BT_HCI_EVT_CON_COMP_CONN_HANDLE],
		event_parameter[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1]);

    if ((event_parameter[_BT_HCI_EVT_CON_COMP_CONN_HANDLE] == 0) && (event_parameter[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] == 0)){
        ret=__LINE__;
    }        
    else{
	    return event_parameter[_BT_HCI_EVT_CON_COMP_STATUS];
    }

    if( 0 != memcmp (  event_parameter + _BT_HCI_EVT_CON_COMP_CONN_INT, 
                       param.conn_update_param.Conn_Interval_Min, 
                       2)){
        ret=__LINE__;
    }
    
    if( 0 != memcmp (  event_parameter + _BT_HCI_EVT_CON_COMP_CONN_LATENCY, 
                       param.conn_update_param.Conn_Latency, 
                       2)){
        ret=__LINE__;
    }

    if( 0 != memcmp (  event_parameter + _BT_HCI_EVT_CON_COMP_SUPER_TO, 
                       param.conn_update_param.Supervision_Timeout, 
                       2)){
        ret=__LINE__;

    }
    
	printf("Connection_Interval = %02x %02x\n" ,
		event_parameter[_BT_HCI_EVT_CON_COMP_CONN_INT],
		event_parameter[_BT_HCI_EVT_CON_COMP_CONN_INT+1]);
	printf("Connection_Latency  = %02x %02x\n" ,
		event_parameter[_BT_HCI_EVT_CON_COMP_CONN_LATENCY],
		event_parameter[_BT_HCI_EVT_CON_COMP_CONN_LATENCY+1]);
	printf("Supervision_Timeout = %02x %02x\n\n" ,
		event_parameter[_BT_HCI_EVT_CON_COMP_SUPER_TO],
		event_parameter[_BT_HCI_EVT_CON_COMP_SUPER_TO+1]);

    return ret;
    
}


int hci_le_event_ltk_request_parsing(int adv_type,u8 * event_parameter ,Pattern_param param)
{
	int ret = EQUAL;

	printf("Subevent_Code = %d\n" , event_parameter[_BT_HCI_EVT_LTK_REQ_SUB_CODE]);
	printf("Connection_Handle = 0x%02x 0x%02x\n" ,
		event_parameter[_BT_HCI_EVT_LTK_REQ_CONN_HANDLES+0],
		event_parameter[_BT_HCI_EVT_LTK_REQ_CONN_HANDLES+1]);
	printf("Random_Number = %x%x%x%x%x%x%x%x\n" ,
		event_parameter[_BT_HCI_EVT_LTK_REQ_RANDOM_NUM+0],
		event_parameter[_BT_HCI_EVT_LTK_REQ_RANDOM_NUM+1],
		event_parameter[_BT_HCI_EVT_LTK_REQ_RANDOM_NUM+2],
		event_parameter[_BT_HCI_EVT_LTK_REQ_RANDOM_NUM+3],
		event_parameter[_BT_HCI_EVT_LTK_REQ_RANDOM_NUM+4],
		event_parameter[_BT_HCI_EVT_LTK_REQ_RANDOM_NUM+5],
		event_parameter[_BT_HCI_EVT_LTK_REQ_RANDOM_NUM+6],
		event_parameter[_BT_HCI_EVT_LTK_REQ_RANDOM_NUM+7]);
	printf("Encrypted_Diversifier = 0x%02x 0x%02x\n\n" ,
		event_parameter[_BT_HCI_EVT_LTK_REQ_EDIV],
		event_parameter[_BT_HCI_EVT_LTK_REQ_EDIV+1]);

    if(( 0 == event_parameter[_BT_HCI_EVT_LTK_REQ_CONN_HANDLES+0]) && 
       ( 0 == event_parameter[_BT_HCI_EVT_LTK_REQ_CONN_HANDLES+1])){
        
        ret=__LINE__;        
    }

    return ret;
 
}

void Calculate_Execution_Time_Start() 
{
    gettimeofday(&timeStart,NULL);     
}

void read_le_event_enable()
{
	READ_LE_EVENT = 1;
}

void read_le_event_disable()
{
	READ_LE_EVENT =0 ;
}

int read_le_event_get()
{
	return READ_LE_EVENT;
}

int QUERY_Acl_Data(u8 dut_fd ,u8 * buf ){
	u16 len;
	u8 ret;
    
	memset(buf , 0 , SOCKET_BUF_SIZE);

	buf[_BT_HCI_IDX_INDICATOR_]         =	_BT_HCI_INDICATOR_QUERY_ACL_DATA_;
	buf[_BT_HCI_IDX_EVENT_CODE_]	    =	0xFF;
	buf[_BT_HCI_IDX_EVENT_LENGTH_]	    =	QUERY_ACL_LENGTH ;

#ifdef READ_EVT_DEBUG
    PRINT_TIME;
    printf(COLOR);
	printf("# send Acl Data query (dut:%d)\n",dut_fd);
    printf(NONE);
	print_charray(QUERY_EVT_HDR_LENGTH + _BT_HCI_W_EVENT_LENGTH_ +QUERY_ACL_LENGTH,buf);
#endif

	ret=socket_msg_send(dut_fd , QUERY_EVT_HDR_LENGTH + _BT_HCI_W_EVENT_LENGTH_ +QUERY_ACL_LENGTH ,buf);
	if(SOCKET_SUCCESS != ret)
		return __LINE__;

    do{
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);

	if(SOCKET_SUCCESS != ret)
		return __LINE__;

#ifdef READ_EVT_DEBUG
    PRINT_TIME;
    printf(COLOR);
	printf("# recv Acl Data from Buff (dut:%d)(len:%d)\n",dut_fd , len);
    printf(NONE);
	print_charray(len,buf);
#endif
	return SUCCESS;

}


int QUERY_Event(u8 dut_fd ,u8 * buf ,u8 event ){
	u16 len;
	u8 ret;

	memset(buf , 0 , SOCKET_BUF_SIZE);
    
	buf[_BT_HCI_IDX_INDICATOR_]         =	_BT_HCI_INDICATOR_QUERY_EVENT_;
	buf[_BT_HCI_IDX_EVENT_CODE_]	    =	event;
	buf[_BT_HCI_IDX_EVENT_LENGTH_]	    =	QUERY_EVT_LENGTH ;

#ifdef READ_EVT_DEBUG
    PRINT_TIME;
    printf(COLOR);
	printf("# send Event query (dut:%d)\n",dut_fd);
    printf(NONE);
	print_charray(QUERY_EVT_HDR_LENGTH + _BT_HCI_W_EVENT_LENGTH_ +QUERY_EVT_LENGTH,buf);
#endif
	ret=socket_msg_send(dut_fd , QUERY_EVT_HDR_LENGTH + _BT_HCI_W_EVENT_LENGTH_ +QUERY_EVT_LENGTH ,buf);
	if(SOCKET_SUCCESS != ret)
		return __LINE__;

    do{
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	if(SOCKET_SUCCESS != ret)
		return __LINE__;

#ifdef READ_EVT_DEBUG
    PRINT_TIME;
    printf(COLOR);
	printf("# recv Event from Buff (dut:%d)\n",dut_fd);
    printf(NONE);
	print_charray(len,buf);
#endif

	return SUCCESS;

}


int QUERY_LE_Event(u8 dut_fd ,u8 * buf ,u8 sub_event ,u8 adv_type){
	u16 len;
	u8 ret;

	memset(buf , 0 , SOCKET_BUF_SIZE);
    
	buf[_BT_HCI_IDX_INDICATOR_] 		=	_BT_HCI_INDICATOR_QUERY_EVENT_;
	buf[_BT_HCI_IDX_EVENT_CODE_]		=	_BT_HCI_EVENT_OP_LE_EVENT_;
	buf[_BT_HCI_IDX_EVENT_LENGTH_]		=	QUERY_LE_EVT_LENGTH ;
	buf[_BT_HCI_IDX_EVENT_PARAMETER_]	=	sub_event;
	buf[_BT_HCI_IDX_EVENT_PARAMETER_+1] =	0x00 ;//don't care	
	buf[_BT_HCI_IDX_EVENT_PARAMETER_+2] =	adv_type;
    
#ifdef READ_EVT_DEBUG
    PRINT_TIME;
    printf(COLOR);
    printf("# send Le Event query (dut:%d)\n",dut_fd);
    printf(NONE);
    print_charray(QUERY_EVT_HDR_LENGTH + _BT_HCI_W_EVENT_LENGTH_ +QUERY_LE_EVT_LENGTH+2,buf);
#endif

	ret=socket_msg_send(dut_fd , QUERY_EVT_HDR_LENGTH + _BT_HCI_W_EVENT_LENGTH_ +QUERY_LE_EVT_LENGTH+2 ,buf);
	if(SOCKET_SUCCESS != ret)
		return __LINE__;

    do{
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	if(SOCKET_SUCCESS != ret)
		return __LINE__;

#ifdef READ_EVT_DEBUG
    PRINT_TIME;
    printf(COLOR);
    printf("# recv Le Event from Buff (dut:%d)\n",dut_fd);
    printf(NONE);
	print_charray(len,buf);
#endif



	return SUCCESS;

}

void cfg_parse_hex(u8 *src, u8 *dest ,u8 digit)
{
	u8 i,k=0;
	for(i=0;i<digit;i++)
		{
		if(src[i] >= '0' && src[i] <= '9')
			dest[k] = (src[i] - '0') <<4;
		else if(src[i] >= 'A' && src [i] <= 'F')
			dest[k] = (src[i] - 'A'+10) << 4;
		else if(src[i] >= 'a' && src [i] <= 'f')
			dest[k] = (src[i] - 'a'+10) << 4;

		i++;

		if(src[i] >= '0' && src[i] <= '9')
			dest[k++] += src[i] - '0';
		else if(src[i] >= 'A' && src [i] <= 'F')
			dest[k++] += src[i] - 'A' +10;
		else if(src[i] >= 'a' && src [i] <= 'f')
			dest[k++] += src[i] - 'a' +10;

		i++;
		}

}

u8 pattern_config_read(const char * func_name , int type){

	// # read config file
    switch(type){
        case ADV_PARAM_TIME_INDEP :
            param_config_read(func_name  , adv_param_time_indep_config_tbl);
            break;

        case ADV_PARAM_TIME_DEP :
            param_config_read(func_name  , adv_param_time_dep_config_tbl);
            break;

        case SCAN_PARAM_TIME_INDEP :
            param_config_read(func_name  , scan_param_time_indep_config_tbl);
            break;
        
        case SCAN_PARAM_TIME_DEP :
            param_config_read(func_name  , scan_param_time_dep_config_tbl);
            break;

        case SLAVE_PARAM_TIME_INDEP :
            param_config_read(func_name  , slave_param_time_indep_config_tbl);
            break;
        
        case SLAVE_PARAM_TIME_DEP :
            param_config_read(func_name  , slave_param_time_dep_config_tbl);
            break;            

        case ADV_STABLE :
            param_config_read(func_name  , adv_stable_config_tbl);
            break;            

        case SCAN_STABLE :
            param_config_read(func_name  , scan_stable_config_tbl);
            break;  

        case SLAVE_STABLE :
            param_config_read(func_name  , sla_stable_config_tbl);
            break;  

        case SLAVE_STRESS :
            param_config_read(func_name  , sla_stress_config_tbl);
            break; 

        case MULTIROLE_SLA_PERF :
            param_config_read(func_name  , multirole_sla_perf_config_tbl);
            break;

    }

	return 0;
}

void error_addr_config(void){

    int i ;

    for(i = 0; i <= 5; i++) {
        dut1_error_both[i] = error_addr[i];
        dut2_error_both[i] = error_addr[i];
        
        if(i <= 2){
            dut1_error_com_ass[i] = scan_addr[i];
            dut1_error_com_idf[i] = error_addr[i];
            dut2_error_com_ass[i] = adv_addr[i];
            dut2_error_com_idf[i] = error_addr[i];
        }
        else {
            dut1_error_com_ass[i] = error_addr[i];
            dut1_error_com_idf[i] = scan_addr[i];
            dut2_error_com_ass[i] = error_addr[i];
            dut2_error_com_idf[i] = adv_addr[i];
        }
    }

    printf("dut1_error_com_ass = %02x:%02x:%02x:%02x:%02x:%02x\n",dut1_error_com_ass[0],dut1_error_com_ass[1],dut1_error_com_ass[2],\
         dut1_error_com_ass[3],dut1_error_com_ass[4],dut1_error_com_ass[5]);

    printf("dut1_error_com_idf = %02x:%02x:%02x:%02x:%02x:%02x\n",dut1_error_com_idf[0],dut1_error_com_idf[1],dut1_error_com_idf[2],\
         dut1_error_com_idf[3],dut1_error_com_idf[4],dut1_error_com_idf[5]);

    printf("dut1_error_both    = %02x:%02x:%02x:%02x:%02x:%02x\n",dut1_error_both[0],dut1_error_both[1],dut1_error_both[2],\
         dut1_error_both[3],dut1_error_both[4],dut1_error_both[5]);

    printf("dut2_error_com_ass = %02x:%02x:%02x:%02x:%02x:%02x\n",dut2_error_com_ass[0],dut2_error_com_ass[1],dut2_error_com_ass[2],\
         dut2_error_com_ass[3],dut2_error_com_ass[4],dut2_error_com_ass[5]);

    printf("dut2_error_com_idf = %02x:%02x:%02x:%02x:%02x:%02x\n",dut2_error_com_idf[0],dut2_error_com_idf[1],dut2_error_com_idf[2],\
         dut2_error_com_idf[3],dut2_error_com_idf[4],dut2_error_com_idf[5]);

    printf("dut2_error_both    = %02x:%02x:%02x:%02x:%02x:%02x\n",dut2_error_both[0],dut2_error_both[1],dut2_error_both[2],\
         dut2_error_both[3],dut2_error_both[4],dut2_error_both[5]);

}

void cfg_dev_type(u8 dut_num ,u8 *dut_type_name){
    
    if(memcmp(dut_type_name,"ti",2) == 0){
        s_dev_type[dut_num] = DUT_TYPE_TI;
    }
    
    if (memcmp(dut_type_name,"ssv",3) == 0){
        s_dev_type[dut_num] = DUT_TYPE_SSV;
    }
    
    if (memcmp(dut_type_name,"csr",3) == 0){
        s_dev_type[dut_num] = DUT_TYPE_CSR;
    }
    
    if(s_dev_type[dut_num] == 0){
        printf("!error dut type config");
        exit(1);
    }

    Dut_setting[dut_num].dut_type = s_dev_type[dut_num];
    printf("dut%d = %s", dut_num , dut_type_name);

}


#define CONFIG_BUF_SIZE 32
u8 bench_config_load(enum_cfg role_cfg){
	FILE *cfg_f;
	u8 cfg[1025],*pt ;

    switch (role_cfg){
        
        case CFG_ADV:
            printf("load adv cfg\n");
            if ((cfg_f = fopen("bench-adv.cfg","r")) == NULL){
             printf("cant't open config file\n");
             return -1;
            }
            break;

        case CFG_SCAN:
            printf("load scan cfg\n");            
            if ((cfg_f = fopen("bench-scn.cfg","r")) == NULL){
             printf("cant't open config file\n");
             return -1;
            }
            break;            
            
        case CFG_MULTIROLE:
            printf("load multirole cfg\n");            
            if ((cfg_f = fopen("bench-multirole.cfg","r")) == NULL){
             printf("cant't open config file\n");
             return -1;
            }

            break;

        default:            
            printf("load default cfg\n");
            if ((cfg_f = fopen("bench.cfg","r")) == NULL){
             printf("cant't open config file\n");
             return -1;
            }
            break;

    }

	//read config file, select dut path.
	while(1){
		fgets((char*)cfg , CONFIG_BUF_SIZE , cfg_f);
		if(cfg[0] == '^'){
			break;
		}

		pt=cfg;

		if(memcmp(cfg,"dev_num",7) == 0){
			while(*pt++ != '='){};
			printf("dev = %d\n" , atoi((char*)pt));
			s_dev_num = atoi((char*)pt);
		}
        
#define CFG_MANUFACTURER_LEN 4
#define CFG_SUBVERSION_LEN 4

		if(memcmp(cfg,"manufacturer",12) == 0){
			while(*pt++ != '='){};
            cfg_parse_hex(pt , s_manufacturer , CFG_MANUFACTURER_LEN);            
			printf("manufacturer = %02x%02x\n" , s_manufacturer[0] , s_manufacturer[1]);
		}
        
		if(memcmp(cfg,"subversion",10) == 0){
			while(*pt++ != '='){};
            cfg_parse_hex(pt , s_subversion , CFG_SUBVERSION_LEN);                        
			printf("subversion = %02x%02x\n" , s_subversion[0] ,s_subversion[1] );
		}
        // # start from '1'
        
		if(memcmp(cfg,"dut1_type",sizeof("dut1_type")-1) == 0){
			while(*pt++ != '='){};
            cfg_dev_type(1 , pt);
		}

		if(memcmp(cfg,"dut2_type",sizeof("dut2_type")-1) == 0){
			while(*pt++ != '='){};
            cfg_dev_type(2 , pt);            
		}

        if(memcmp(cfg,"dut3_type",sizeof("dut3_type")-1) == 0){
            while(*pt++ != '='){};
            cfg_dev_type(3 , pt);            
        }

        if(memcmp(cfg,"dut4_type",sizeof("dut4_type")-1) == 0){
            while(*pt++ != '='){};
            cfg_dev_type(4 , pt);            
        }

#define CFG_ADDR_LEN 18

		if(memcmp(cfg,"scan_addr",sizeof("scan_addr")-1) == 0){
			while(*pt++ != '='){};
			cfg_parse_hex(pt,scan_addr , CFG_ADDR_LEN);
            LOG_DEVICE(scan_addr , LOG_DEVICE_TYPE_SCANNER);
			//		  memcpy(cen_addr,dut_central_cfg.implementation_cfg.bd_addr,BD_ADDR_LEN);
			printf("scan_addr = %02x:%02x:%02x:%02x:%02x:%02x\n",scan_addr[0],scan_addr[1],scan_addr[2],\
					scan_addr[3],scan_addr[4],scan_addr[5]);
		}

		if(memcmp(cfg,"adv_addr",sizeof("adv_addr")-1) == 0){
			while(*pt++ != '='){};
			cfg_parse_hex(pt,adv_addr , CFG_ADDR_LEN);
            LOG_DEVICE(adv_addr , LOG_DEVICE_TYPE_ADVERTISER);
			//		memcpy(peri_addr,dut_peri_cfg.implementation_cfg.bd_addr,BD_ADDR_LEN);
			printf("adv_addr  = %02x:%02x:%02x:%02x:%02x:%02x\n",adv_addr[0],adv_addr[1],adv_addr[2],\
					adv_addr[3],adv_addr[4],adv_addr[5]);
		}

		if(memcmp(cfg,"init_addr",sizeof("init_addr")-1) == 0){
			while(*pt++ != '='){};
			cfg_parse_hex(pt,init_addr, CFG_ADDR_LEN);
            LOG_DEVICE(init_addr , LOG_DEVICE_TYPE_INITATOR);
			//		memcpy(peri_addr,dut_peri_cfg.implementation_cfg.bd_addr,BD_ADDR_LEN);
			printf("init_addr = %02x:%02x:%02x:%02x:%02x:%02x\n",init_addr[0],init_addr[1],init_addr[2],\
					init_addr[3],init_addr[4],init_addr[5]);
		}

        if(memcmp(cfg,"dut1_addr",sizeof("dut1_addr")-1) == 0){
            while(*pt++ != '='){};
            cfg_parse_hex(pt,Dut_setting[1].dut_addr, CFG_ADDR_LEN);
            LOG_DEVICE(Dut_setting[1].dut_addr , LOG_MULTIROLE_DEVICE_TYPE_1);
            //      memcpy(peri_addr,dut_peri_cfg.implementation_cfg.bd_addr,BD_ADDR_LEN);
            printf("dut1_addr = %02x:%02x:%02x:%02x:%02x:%02x\n",Dut_setting[1].dut_addr[0], Dut_setting[1].dut_addr[1], Dut_setting[1].dut_addr[2],\
                    Dut_setting[1].dut_addr[3], Dut_setting[1].dut_addr[4], Dut_setting[1].dut_addr[5]);

            //single role to muti role should init new dut_fd
            int dut_fd = dut_socket_init(1);
            if(ERROR != dut_fd) {
                Dut_setting[1].dut_fd = dut_fd;
                dut_reset_with_mask_en(dut_fd);
            }  
        }

        if(memcmp(cfg,"dut2_addr",sizeof("dut2_addr")-1) == 0){
            while(*pt++ != '='){};
            cfg_parse_hex(pt,Dut_setting[2].dut_addr, CFG_ADDR_LEN);
            LOG_DEVICE(Dut_setting[2].dut_addr , LOG_MULTIROLE_DEVICE_TYPE_2);
            //      memcpy(peri_addr,dut_peri_cfg.implementation_cfg.bd_addr,BD_ADDR_LEN);
            printf("dut2_addr = %02x:%02x:%02x:%02x:%02x:%02x\n",Dut_setting[2].dut_addr[0],Dut_setting[2].dut_addr[1],Dut_setting[2].dut_addr[2],\
                    Dut_setting[2].dut_addr[3],Dut_setting[2].dut_addr[4],Dut_setting[2].dut_addr[5]);

            //single role to muti role should init new dut_fd
            int dut_fd = dut_socket_init(2);
            if(ERROR != dut_fd) {
                Dut_setting[2].dut_fd = dut_fd;
                dut_reset_with_mask_en(dut_fd);
            }
        }

        if(memcmp(cfg,"dut3_addr",sizeof("dut3_addr")-1) == 0){
            while(*pt++ != '='){};
            cfg_parse_hex(pt,Dut_setting[3].dut_addr, CFG_ADDR_LEN);
            LOG_DEVICE(Dut_setting[3].dut_addr , LOG_MULTIROLE_DEVICE_TYPE_3);
            //      memcpy(peri_addr,dut_peri_cfg.implementation_cfg.bd_addr,BD_ADDR_LEN);
            printf("dut3_addr = %02x:%02x:%02x:%02x:%02x:%02x\n",Dut_setting[3].dut_addr[0],Dut_setting[3].dut_addr[1],Dut_setting[3].dut_addr[2],\
                    Dut_setting[3].dut_addr[3],Dut_setting[3].dut_addr[4],Dut_setting[3].dut_addr[5]);

            //single role to muti role should init new dut_fd
            int dut_fd = dut_socket_init(3);
            if(ERROR != dut_fd) {
                Dut_setting[3].dut_fd = dut_fd;
                dut_reset_with_mask_en(dut_fd);
            }
        }

        if(memcmp(cfg,"dut4_addr",sizeof("dut4_addr")-1) == 0){
            while(*pt++ != '='){};
            cfg_parse_hex(pt,Dut_setting[4].dut_addr, CFG_ADDR_LEN);
            LOG_DEVICE(Dut_setting[4].dut_addr , LOG_MULTIROLE_DEVICE_TYPE_4);
            //      memcpy(peri_addr,dut_peri_cfg.implementation_cfg.bd_addr,BD_ADDR_LEN);
            printf("dut4_addr = %02x:%02x:%02x:%02x:%02x:%02x\n",Dut_setting[4].dut_addr[0],Dut_setting[4].dut_addr[1],Dut_setting[4].dut_addr[2],\
                    Dut_setting[4].dut_addr[3],Dut_setting[4].dut_addr[4],Dut_setting[4].dut_addr[5]);

            //single role to muti role should init new dut_fd
            int dut_fd = dut_socket_init(4);
            if(ERROR != dut_fd) {
                Dut_setting[4].dut_fd = dut_fd;
                dut_reset_with_mask_en(dut_fd);
            }
        }

		if(memcmp(cfg,"dtm_pkt_cnt",11) == 0){
		    while(*pt++ != '='){};
			s_pkt_cnt = atoi((char*)pt) ;
			printf("pkt_cnt = %d\n" , s_pkt_cnt);
		}

	 }

	 printf("\n");

	 fclose(cfg_f);
	 return 0;
}


// # toolbox
void Dtm_Tx_Sleep_time(u32 pkt2tx )
{
	if(170 > pkt2tx)
	{
		usleep(120000);
	}else if(820 > pkt2tx)
	{
		usleep(585000);
	}
	else if(1700 > pkt2tx)
	{
		sleep(1);
		usleep(170000);
	}
	else if(3200 > pkt2tx)
	{
		sleep(2);
		usleep(340000);
	}
	else if(6400 > pkt2tx)
	{
		sleep(4);
		usleep(680000);

	}
	else if(10000 >= pkt2tx)
	{
		sleep(7);
		usleep(250000);

	}
}

int Dtm(int rxdut, int txdut ,int channel ,u32 pkt_cnt ,Ret_param * retp)
{
		s32 dut1_fd=0;
		s32 dut2_fd=0;
		u8 buf[SOCKET_BUF_SIZE]; //william : buf size should be  according socket_get_msg
		u16 len;

		u32 pkt2tx=pkt_cnt;
		// paramters for commands
		u8 TX_Frequency[1]		 = {channel};
		u8 Length_Of_Test_Data[1]	 = {0x25};
		u8 Packet_Payload[1]		 = {0x00};

		u8 VSCMD_TI_TX_Power_Level		  [1] = {0x01};
		u8 VSCMD_TI_RX_Mode 			  [1] = {0x00};
		u8 VSCMD_TI_Packets_to_transmit   [2] = {0xe8, 0x03};
		u8 VSCMD_TI_Access_code 		  [4] = {0x29, 0x41, 0x76, 0x71};
		u8 VSCMD_TI_PER_BER_Test_Enable   [1] = {0x00};
		u8 VSCMD_TI_BER_Test_Pattern	  [1] = {0x00};
		u8 VSCMD_TI_BER_Test_Packet_Length[1] = {0x1f};
		u8 VSCMD_TI_BER_FA_Threshold	  [1] = {0x14};
		u8 VSCMD_TI_Trace_Enable		  [1] = {0x00};
		u8 VSCMD_TI_Reference_CRC		  [4] = {0x55, 0x55, 0x55, 0x55};

		dut1_fd=dut_socket_init(rxdut);
		dut2_fd=dut_socket_init(txdut);
		//LOG_PRINTF("************* Testing with %d(rx) *************\n" ,dut1_fd);
		bt_hci_cmd_le_receiver_test.parameter_tbl[0].value = &channel;
		bt_hci_write_cmd2socket(dut1_fd, &bt_hci_cmd_le_receiver_test);

        do{
            socket_msg_get(dut1_fd,&len,buf);
        }while(len <=0);
		//print_charray(len,buf);
		bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
							buf[_BT_HCI_IDX_EVENT_LENGTH_],
							buf+_BT_HCI_IDX_EVENT_PARAMETER_);

		//LOG_PRINTF("************* Testing with %d(rx) *************\n" ,dut2_fd);

		if (1) //TI
		{
	//		TI_LoadPatch(fd_uart_array[1]);
			VSCMD_TI_Packets_to_transmit[0] = (pkt2tx & 0x000000ff) >> 0;
			VSCMD_TI_Packets_to_transmit[1] = (pkt2tx & 0x0000ff00) >> 8;

			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[0].value = VSCMD_TI_TX_Power_Level		  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[1].value = VSCMD_TI_RX_Mode 			  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[2].value = VSCMD_TI_Packets_to_transmit   ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[3].value = VSCMD_TI_Access_code 		  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[4].value = VSCMD_TI_PER_BER_Test_Enable   ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[5].value = VSCMD_TI_BER_Test_Pattern	  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[6].value = VSCMD_TI_BER_Test_Packet_Length;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[7].value = VSCMD_TI_BER_FA_Threshold	  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[8].value = VSCMD_TI_Trace_Enable		  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[9].value = VSCMD_TI_Reference_CRC		  ;
			bt_hci_write_cmd2socket (dut2_fd, &bt_hci_cmd_ti_set_le_test_mode_parameters);
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);

			bt_hci_cmd_le_transmitter_test.parameter_tbl[0].value = TX_Frequency		;
			bt_hci_cmd_le_transmitter_test.parameter_tbl[1].value = Length_Of_Test_Data;
			bt_hci_cmd_le_transmitter_test.parameter_tbl[2].value = Packet_Payload	;

			bt_hci_write_cmd2socket (dut2_fd, &bt_hci_cmd_le_transmitter_test);
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);

			printf("Waiting TX finish...\n");
			Dtm_Tx_Sleep_time(pkt2tx);

#if 1 //wiliam add for even tx failed
			//printf("***********william testing****************\n");
			bt_hci_write_cmd2socket (dut2_fd, &bt_hci_cmd_le_transmitter_test);
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);
#endif
			bt_hci_write_cmd2socket(dut2_fd, &bt_hci_cmd_le_test_end);
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);

			bt_hci_write_cmd2socket(dut1_fd, &bt_hci_cmd_le_test_end);
            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);

			return (buf[5+_BT_HCI_IDX_EVENT_PARAMETER_]<<8) + buf[4+_BT_HCI_IDX_EVENT_PARAMETER_];
				}
}


int AutoDtm(int rxdut, int txdut ,int channel , u32 tx_pkt_cnt,Ret_param * retp)
{
		s32 dut1_fd=0;
		s32 dut2_fd=0;
		u8 buf[SOCKET_BUF_SIZE]; //william : buf size should be  according socket_get_msg
		u16 len;

		u32 pkt2tx=tx_pkt_cnt;
		// paramters for commands
		u8 TX_Frequency[1]		 = {channel};
		u8 Length_Of_Test_Data[1]	 = {0x25};
		u8 Packet_Payload[1]		 = {0x00};

		u8 VSCMD_TI_TX_Power_Level		  [1] = {0x01};
		u8 VSCMD_TI_RX_Mode 			  [1] = {0x00};
		u8 VSCMD_TI_Packets_to_transmit   [2] = {0xe8, 0x03};
		u8 VSCMD_TI_Access_code 		  [4] = {0x29, 0x41, 0x76, 0x71};
		u8 VSCMD_TI_PER_BER_Test_Enable   [1] = {0x00};
		u8 VSCMD_TI_BER_Test_Pattern	  [1] = {0x00};
		u8 VSCMD_TI_BER_Test_Packet_Length[1] = {0x1f};
		u8 VSCMD_TI_BER_FA_Threshold	  [1] = {0x14};
		u8 VSCMD_TI_Trace_Enable		  [1] = {0x00};
		u8 VSCMD_TI_Reference_CRC		  [4] = {0x55, 0x55, 0x55, 0x55};

		dut1_fd=dut_socket_init(rxdut);
		dut2_fd=dut_socket_init(txdut);
		//LOG_PRINTF("************* Testing with %d(rx) *************\n" ,dut1_fd);
		bt_hci_cmd_le_receiver_test.parameter_tbl[0].value = &channel;
		bt_hci_write_cmd2socket(dut1_fd, &bt_hci_cmd_le_receiver_test);

        do{
            socket_msg_get(dut1_fd,&len,buf);
        }while(len <=0);
		//print_charray(len,buf);
		bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
							buf[_BT_HCI_IDX_EVENT_LENGTH_],
							buf+_BT_HCI_IDX_EVENT_PARAMETER_);

		//LOG_PRINTF("************* Testing with %d(rx) *************\n" ,dut2_fd);

		if (1) //TI
		{
	//		TI_LoadPatch(fd_uart_array[1]);
			VSCMD_TI_Packets_to_transmit[0] = (pkt2tx & 0x000000ff) >> 0;
			VSCMD_TI_Packets_to_transmit[1] = (pkt2tx & 0x0000ff00) >> 8;

			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[0].value = VSCMD_TI_TX_Power_Level		  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[1].value = VSCMD_TI_RX_Mode 			  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[2].value = VSCMD_TI_Packets_to_transmit   ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[3].value = VSCMD_TI_Access_code 		  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[4].value = VSCMD_TI_PER_BER_Test_Enable   ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[5].value = VSCMD_TI_BER_Test_Pattern	  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[6].value = VSCMD_TI_BER_Test_Packet_Length;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[7].value = VSCMD_TI_BER_FA_Threshold	  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[8].value = VSCMD_TI_Trace_Enable		  ;
			bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[9].value = VSCMD_TI_Reference_CRC		  ;
			bt_hci_write_cmd2socket (dut2_fd, &bt_hci_cmd_ti_set_le_test_mode_parameters);
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);

			bt_hci_cmd_le_transmitter_test.parameter_tbl[0].value = TX_Frequency		;
			bt_hci_cmd_le_transmitter_test.parameter_tbl[1].value = Length_Of_Test_Data;
			bt_hci_cmd_le_transmitter_test.parameter_tbl[2].value = Packet_Payload	;

			bt_hci_write_cmd2socket (dut2_fd, &bt_hci_cmd_le_transmitter_test);
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);

			printf("Waiting TX finish...\n");
			Dtm_Tx_Sleep_time(pkt2tx);

#if 1 //wiliam add for even tx failed
			//printf("***********william testing****************\n");
			bt_hci_write_cmd2socket (dut2_fd, &bt_hci_cmd_le_transmitter_test);
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);
#endif
			bt_hci_write_cmd2socket(dut2_fd, &bt_hci_cmd_le_test_end);
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);

			bt_hci_write_cmd2socket(dut1_fd, &bt_hci_cmd_le_test_end);
            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			//print_charray(len,buf);
			bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
								buf[_BT_HCI_IDX_EVENT_LENGTH_],
								buf+_BT_HCI_IDX_EVENT_PARAMETER_);

			return (buf[5+_BT_HCI_IDX_EVENT_PARAMETER_]<<8) + buf[4+_BT_HCI_IDX_EVENT_PARAMETER_];
		}
}



void  TI_Dtm_Tx(u8 txdut  ,u8 channel ,u16 pkt_cnt , u8 pkt_len , u8 pld_tp){

	s32 dut1_fd=0;
	u8	buf[SOCKET_BUF_SIZE]; //william : buf size should be  according socket_get_msg
	u16 len;

	// paramters for commands
	u8 TX_Frequency[1]		 = {channel};
	u8 Length_Of_Packet[1]	 = {pkt_len};
	/*
	# 0 - PRBS 9
	# 1 - FOFO		: 11110000
	# 2 - ZOZO		: 10101010
	# 3 - PRBS 15
	# 4 - All Ones
	# 5 - All Zeros
	# 6 - OFOF		:00001111
	# 7 - OZOZ		:01010101
	*/
	u8 Packet_Payload_Type			  [1] = {pld_tp};
	u8 VSCMD_TI_TX_Power_Level		  [1] = {0x01};     //fixed ble power level
	u8 VSCMD_TI_RX_Mode 			  [1] = {0x00};     //normal ,widewin ,cont RX,widewin and powersaving
	u8 VSCMD_TI_Packets_to_transmit   [2] = {0};
	u8 VSCMD_TI_Access_code 		  [4] = {0x29, 0x41, 0x76, 0x71};
	u8 VSCMD_TI_PER_BER_Test_Enable   [1] = {0x00};     //BER disable , PER enable
	u8 VSCMD_TI_BER_Test_Pattern	  [1] = {0x00}; 	//PRBS 9
	u8 VSCMD_TI_BER_Test_Packet_Length[1] = {0x1f};     //Number of payload bytes to be recieved in the BER test
	u8 VSCMD_TI_BER_FA_Threshold	  [1] = {0x14};
	u8 VSCMD_TI_Trace_Enable		  [1] = {0x00};
	u8 VSCMD_TI_Reference_CRC		  [4] = {0x55, 0x55, 0x55, 0x55};

	printf("dut(%d) pkt=%d channel=%d len=%d pldtype=%d\n" ,
		txdut ,pkt_cnt ,channel , pkt_len , pld_tp);

	dut1_fd=dut_socket_init(txdut);
	printf("************* Testing with %d(tx) *************\n" ,dut1_fd);


	VSCMD_TI_Packets_to_transmit[0] = (pkt_cnt & 0x000000ff) >> 0;
	VSCMD_TI_Packets_to_transmit[1] = (pkt_cnt & 0x0000ff00) >> 8;

	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[0].value = VSCMD_TI_TX_Power_Level		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[1].value = VSCMD_TI_RX_Mode 			  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[2].value = VSCMD_TI_Packets_to_transmit   ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[3].value = VSCMD_TI_Access_code 		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[4].value = VSCMD_TI_PER_BER_Test_Enable   ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[5].value = VSCMD_TI_BER_Test_Pattern	  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[6].value = VSCMD_TI_BER_Test_Packet_Length;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[7].value = VSCMD_TI_BER_FA_Threshold	  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[8].value = VSCMD_TI_Trace_Enable		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[9].value = VSCMD_TI_Reference_CRC		  ;
	bt_hci_write_cmd2socket (dut1_fd, &bt_hci_cmd_ti_set_le_test_mode_parameters);

    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	bt_hci_cmd_le_transmitter_test.parameter_tbl[0].value = TX_Frequency;
	bt_hci_cmd_le_transmitter_test.parameter_tbl[1].value = Length_Of_Packet;
	bt_hci_cmd_le_transmitter_test.parameter_tbl[2].value = Packet_Payload_Type ;

	bt_hci_write_cmd2socket (dut1_fd, &bt_hci_cmd_le_transmitter_test);
    
    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Waiting TX finish...\n");
	Dtm_Tx_Sleep_time(pkt_cnt);

	//add for even tx failed
	bt_hci_write_cmd2socket (dut1_fd, &bt_hci_cmd_le_transmitter_test);
    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

}

void  TI_Dtm_Tx_Continue(u8 txdut  ,u8 channel ,u16 pkt_cnt , u8 pkt_len , u8 pld_tp){

	s32 dut1_fd=0;
	u8	buf[SOCKET_BUF_SIZE]; //william : buf size should be  according socket_get_msg
	u16 len;

	// paramters for commands
	u8 TX_Frequency[1]		 = {channel};
	u8 Length_Of_Packet[1]	 = {pkt_len};
	/*
	# 0 - PRBS 9
	# 1 - FOFO		: 11110000
	# 2 - ZOZO		: 10101010
	# 3 - PRBS 15
	# 4 - All Ones
	# 5 - All Zeros
	# 6 - OFOF		:00001111
	# 7 - OZOZ		:01010101
	*/
	u8 Packet_Payload_Type			  [1] = {pld_tp};
	u8 VSCMD_TI_TX_Power_Level		  [1] = {0x01};     //fixed ble power level
	u8 VSCMD_TI_RX_Mode 			  [1] = {0x00};     //normal ,widewin ,cont RX,widewin and powersaving
	u8 VSCMD_TI_Packets_to_transmit   [2] = {0};
	u8 VSCMD_TI_Access_code 		  [4] = {0x29, 0x41, 0x76, 0x71};
	u8 VSCMD_TI_PER_BER_Test_Enable   [1] = {0x00};     //BER disable , PER enable
	u8 VSCMD_TI_BER_Test_Pattern	  [1] = {0x00}; 	//PRBS 9
	u8 VSCMD_TI_BER_Test_Packet_Length[1] = {0x1f};     //Number of payload bytes to be recieved in the BER test
	u8 VSCMD_TI_BER_FA_Threshold	  [1] = {0x14};
	u8 VSCMD_TI_Trace_Enable		  [1] = {0x00};
	u8 VSCMD_TI_Reference_CRC		  [4] = {0x55, 0x55, 0x55, 0x55};

	printf("dut(%d) pkt=%d channel=%d len=%d pldtype=%d\n" ,
		txdut ,pkt_cnt ,channel , pkt_len , pld_tp);

	dut1_fd=dut_socket_init(txdut);
	printf("************* Testing with %d(tx) *************\n" ,dut1_fd);


	VSCMD_TI_Packets_to_transmit[0] = (pkt_cnt & 0x000000ff) >> 0;
	VSCMD_TI_Packets_to_transmit[1] = (pkt_cnt & 0x0000ff00) >> 8;

	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[0].value = VSCMD_TI_TX_Power_Level		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[1].value = VSCMD_TI_RX_Mode 			  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[2].value = VSCMD_TI_Packets_to_transmit   ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[3].value = VSCMD_TI_Access_code 		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[4].value = VSCMD_TI_PER_BER_Test_Enable   ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[5].value = VSCMD_TI_BER_Test_Pattern	  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[6].value = VSCMD_TI_BER_Test_Packet_Length;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[7].value = VSCMD_TI_BER_FA_Threshold	  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[8].value = VSCMD_TI_Trace_Enable		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[9].value = VSCMD_TI_Reference_CRC		  ;
	bt_hci_write_cmd2socket (dut1_fd, &bt_hci_cmd_ti_set_le_test_mode_parameters);

    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	bt_hci_cmd_le_transmitter_test.parameter_tbl[0].value = TX_Frequency;
	bt_hci_cmd_le_transmitter_test.parameter_tbl[1].value = Length_Of_Packet;
	bt_hci_cmd_le_transmitter_test.parameter_tbl[2].value = Packet_Payload_Type ;

	bt_hci_write_cmd2socket (dut1_fd, &bt_hci_cmd_le_transmitter_test);
    
    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Waiting TX finish...\n");
	Dtm_Tx_Sleep_time(pkt_cnt);

	//add for even tx failed
	bt_hci_write_cmd2socket (dut1_fd, &bt_hci_cmd_le_transmitter_test);
    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

}

void  TI_Dtm_Tx_Continue_End(u8 txdut  ,u8 channel ,u16 pkt_cnt , u8 pkt_len , u8 pld_tp){

	s32 dut1_fd=0;
	u8	buf[SOCKET_BUF_SIZE]; //william : buf size should be  according socket_get_msg
	u16 len;

	// paramters for commands
	u8 TX_Frequency[1]		 = {channel};
	u8 Length_Of_Packet[1]	 = {pkt_len};
	/*
	# 0 - PRBS 9
	# 1 - FOFO		: 11110000
	# 2 - ZOZO		: 10101010
	# 3 - PRBS 15
	# 4 - All Ones
	# 5 - All Zeros
	# 6 - OFOF		:00001111
	# 7 - OZOZ		:01010101
	*/
	u8 Packet_Payload_Type			  [1] = {pld_tp};
	u8 VSCMD_TI_TX_Power_Level		  [1] = {0x01};     //fixed ble power level
	u8 VSCMD_TI_RX_Mode 			  [1] = {0x00};     //normal ,widewin ,cont RX,widewin and powersaving
	u8 VSCMD_TI_Packets_to_transmit   [2] = {0};
	u8 VSCMD_TI_Access_code 		  [4] = {0x29, 0x41, 0x76, 0x71};
	u8 VSCMD_TI_PER_BER_Test_Enable   [1] = {0x00};     //BER disable , PER enable
	u8 VSCMD_TI_BER_Test_Pattern	  [1] = {0x00}; 	//PRBS 9
	u8 VSCMD_TI_BER_Test_Packet_Length[1] = {0x1f};     //Number of payload bytes to be recieved in the BER test
	u8 VSCMD_TI_BER_FA_Threshold	  [1] = {0x14};
	u8 VSCMD_TI_Trace_Enable		  [1] = {0x00};
	u8 VSCMD_TI_Reference_CRC		  [4] = {0x55, 0x55, 0x55, 0x55};

	printf("dut(%d) pkt=%d channel=%d len=%d pldtype=%d\n" ,
		txdut ,pkt_cnt ,channel , pkt_len , pld_tp);

	dut1_fd=dut_socket_init(txdut);
	printf("************* Testing with %d(tx) *************\n" ,dut1_fd);


	VSCMD_TI_Packets_to_transmit[0] = (pkt_cnt & 0x000000ff) >> 0;
	VSCMD_TI_Packets_to_transmit[1] = (pkt_cnt & 0x0000ff00) >> 8;

	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[0].value = VSCMD_TI_TX_Power_Level		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[1].value = VSCMD_TI_RX_Mode 			  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[2].value = VSCMD_TI_Packets_to_transmit   ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[3].value = VSCMD_TI_Access_code 		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[4].value = VSCMD_TI_PER_BER_Test_Enable   ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[5].value = VSCMD_TI_BER_Test_Pattern	  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[6].value = VSCMD_TI_BER_Test_Packet_Length;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[7].value = VSCMD_TI_BER_FA_Threshold	  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[8].value = VSCMD_TI_Trace_Enable		  ;
	bt_hci_cmd_ti_set_le_test_mode_parameters.parameter_tbl[9].value = VSCMD_TI_Reference_CRC		  ;
	bt_hci_write_cmd2socket (dut1_fd, &bt_hci_cmd_ti_set_le_test_mode_parameters);

    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	bt_hci_cmd_le_transmitter_test.parameter_tbl[0].value = TX_Frequency;
	bt_hci_cmd_le_transmitter_test.parameter_tbl[1].value = Length_Of_Packet;
	bt_hci_cmd_le_transmitter_test.parameter_tbl[2].value = Packet_Payload_Type ;

	printf("run for even tx faild...\n");

	//add for even tx failed
	bt_hci_write_cmd2socket (dut1_fd, &bt_hci_cmd_le_transmitter_test);
    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

}


void  TI_Dtm_Rx(u8 rxdut ,u8 channel){

	s32 dut1_fd=0;
	u8	buf[SOCKET_BUF_SIZE]; //william : buf size should be  according socket_get_msg
	u16 len;

	printf("dut(%d) channel=%d \n" , rxdut,channel);

	dut1_fd=dut_socket_init(rxdut);
	printf("************* Testing with %d(rx) *************\n" ,dut1_fd);
	bt_hci_cmd_le_receiver_test.parameter_tbl[0].value = &channel;
	bt_hci_write_cmd2socket(dut1_fd, &bt_hci_cmd_le_receiver_test);

    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	//*bug with TI ? when R->T->R(can't recv packet) ; may add another le_recv_test cmd

}

void TI_Dtm_End(u8 dut){

	s32 dut1_fd=0;
	u8 buf[SOCKET_BUF_SIZE]; //william : buf size should be  according socket_get_msg
	u16 len;

	dut1_fd=dut_socket_init(dut);

	bt_hci_write_cmd2socket(dut1_fd, &bt_hci_cmd_le_test_end);
    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

    printf ("\n#receive %d packets#\n\n" , 
            (buf[5+_BT_HCI_IDX_EVENT_PARAMETER_]<<8) + 
             buf[4+_BT_HCI_IDX_EVENT_PARAMETER_]
           );

    
}

void  TI_DTM(u8 rxdut ,u8 txdut ,u8 rfch ,u16 tx_pkt_cnt){

	Ret_param retp;
	int pkt_cnt;
	char printf_buff[50][100];

	printf("DTM with Rx(%d) Tx(%d) \n" ,rxdut,txdut);

	pkt_cnt=Dtm(rxdut, txdut , rfch, tx_pkt_cnt , &retp);

	if(0==pkt_cnt){
		sprintf(printf_buff[0] ,"DTM (%d) Fail\n",rfch);
	}
	else{
		sprintf(printf_buff[0] ,"DTM (%d) RX/TX = %d/%d\n",rfch , pkt_cnt , tx_pkt_cnt );
	}

	printf("\n");
	printf("%s" , printf_buff[0]);

	printf("Exit DTM\n");
}


void  TI_Auto_DTM(u8 rxdut ,u8 txdut ,u16 tx_pkt_cnt){

	Ret_param retp;
	int pkt_cnt;
	int cnt=0;
	int channel_cnt=0;
	char printf_buff[50][100];

	for ( ; channel_cnt < 40 ; channel_cnt++)
	{
		pkt_cnt=AutoDtm(rxdut,txdut,channel_cnt, tx_pkt_cnt,&retp);

		if(0==pkt_cnt)
		{
			sprintf(printf_buff[channel_cnt] ,"Auto TxRx (%d) Fail\n",channel_cnt);
//			PRINTF_FX("Auto TxRx (%d) Fail\n" , ch2txrx);
		}
		else
		{
			sprintf(printf_buff[channel_cnt] ,"Auto TxRx (%d) RX/TX = %d/%d\n",channel_cnt , pkt_cnt ,tx_pkt_cnt);
//			PRINTF_FX("Auto TxRx (%d),RX/TX = %d/%d!\n",ch2txrx , ret, pkt2tx);
		}
	}

    
	printf("\nAuto testing with Rx(%d) Tx(%d) \n" ,rxdut,txdut);

	for ( ; cnt < 40 ; cnt++ )
	{
		printf("%s" , printf_buff[cnt]);
	}

	printf("Exit Auto testing\n");
}


u8 ssv_transmit_test(u8 tx_dut ,u8 channel ,u16 pkt_cnt, u8 pkt_len , u8 pld_tp){
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

//
	u8 TX_Frequency[1]		 = {channel};
	u8 Packet_Count[2]		 = {0,0};
	u8 Length_Of_Packet[1]	 = {pkt_len};

	/*
# 0 - PRBS 9
# 1 - FOFO		: 11110000
# 2 - ZOZO		: 10101010
# 3 - PRBS 15
# 4 - All Ones
# 5 - All Zeros
# 6 - OFOF		:00001111
# 7 - OZOZ		:01010101
	*/
	u8 Packet_Payload_Type[1]		 = {pld_tp};

	s32 dut_fd=0;

	printf("\ndut %d channel=%d\n\n" , tx_dut ,channel);

	dut_fd=dut_socket_init(tx_dut);

	Packet_Count[0] = (pkt_cnt & 0x000000ff) >> 0;
	Packet_Count[1] = (pkt_cnt & 0x0000ff00) >> 8;

	bt_hci_cmd_ssv_le_transmitter_test.parameter_tbl[0].value =TX_Frequency;
	bt_hci_cmd_ssv_le_transmitter_test.parameter_tbl[1].value =Packet_Count;
	bt_hci_cmd_ssv_le_transmitter_test.parameter_tbl[2].value =Length_Of_Packet;
	bt_hci_cmd_ssv_le_transmitter_test.parameter_tbl[3].value =Packet_Payload_Type;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_ssv_le_transmitter_test);

	return 0;
}


u8 transmit_test(u8 tx_dut	,u8 channel , s8 pkt_len , s8 pld_tp){
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

//
	u8 TX_Frequency[1]		 = {channel};
	u8 Length_Of_Packet[1]	 = {pkt_len};
	/*
# 0 - PRBS 9
# 1 - FOFO		: 11110000
# 2 - ZOZO		: 10101010
# 3 - PRBS 15
# 4 - All Ones
# 5 - All Zeros
# 6 - OFOF		:00001111
# 7 - OZOZ		:01010101
	*/
	u8 Packet_Payload_Type[1]		 = {pld_tp};

	s32 dut_fd=0;

	printf("\ndut %d channel %d\n\n" , tx_dut ,channel);

	dut_fd=dut_socket_init(tx_dut);

	bt_hci_cmd_le_transmitter_test.parameter_tbl[0].value =TX_Frequency;
	bt_hci_cmd_le_transmitter_test.parameter_tbl[1].value =Length_Of_Packet;
	bt_hci_cmd_le_transmitter_test.parameter_tbl[2].value =Packet_Payload_Type;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_transmitter_test);

	return 0;

}

u8 receive_test(u8 rxdut ,u8 channel){

	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	s32 dut_fd=0;

	printf("\ndut %d channel %d \n\n" , rxdut,channel);

	dut_fd=dut_socket_init(rxdut);
	bt_hci_cmd_le_receiver_test.parameter_tbl[0].value = &channel;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_receiver_test);
	return 0;

}

u8 test_end(u8 dut){
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	s32 dut_fd=0;

	printf("\ndut %d end \n\n" , dut);

	dut_fd=dut_socket_init(dut);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_test_end);

    printf ("#receive %d packets#\n" , 
            (buf[5+_BT_HCI_IDX_EVENT_PARAMETER_]<<8) + 
             buf[4+_BT_HCI_IDX_EVENT_PARAMETER_]
           );

	return 0;

}



u16 ssv_auto_txrx_ti_ssv(u8 ti_dut,u8 ssv_dut,u8 channel,u16 pkt_cnt,u8 pkt_len,u8 pld_type){

	s32 rx_fd=0;
	u8  buf[SOCKET_BUF_SIZE];
	u16 len;

	rx_fd=dut_socket_init(ssv_dut);

	// # T= TI , R = SSV
	receive_test (ssv_dut, channel);
	TI_Dtm_Tx(ti_dut , channel , pkt_cnt , pkt_len , pld_type);
	test_end (ti_dut);

	// # inorder to return the packet num
	bt_hci_write_cmd2socket(rx_fd, &bt_hci_cmd_le_test_end);
    do{
        socket_msg_get(rx_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	return (buf[5+_BT_HCI_IDX_EVENT_PARAMETER_]<<8) + buf[4+_BT_HCI_IDX_EVENT_PARAMETER_];

}

u16 ssv_auto_txrx_ssv_ti(u8 ti_dut,u8 ssv_dut,u8 channel,u16 pkt_cnt,u8 pkt_len,u8 pld_type){

	s32 rx_fd=0;
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;

	rx_fd=dut_socket_init(ti_dut);

	// # T= SSV , R = TI
	receive_test (ti_dut, channel);
	ssv_transmit_test(ssv_dut , channel ,pkt_cnt ,pkt_len,pld_type);
	Dtm_Tx_Sleep_time(pkt_cnt);
	test_end (ssv_dut);

	// # inorder to return the packet num
	bt_hci_write_cmd2socket(rx_fd, &bt_hci_cmd_le_test_end);
    do{
        socket_msg_get(rx_fd,&len,buf);
    }while(len <=0);
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	return (buf[5+_BT_HCI_IDX_EVENT_PARAMETER_]<<8) + buf[4+_BT_HCI_IDX_EVENT_PARAMETER_];

}


void set_adv_interval(u16 interval){
    u16 intv = interval / 0.625 ;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  intv & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (intv & 0xff00) >> 8;

    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  intv & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (intv & 0xff00) >> 8;
}

void set_adv_policy(u16 policy){

	g_pattern_param.adv_param.Advertising_Filter_Policy[0] =	policy;
}

void set_scan_interval(u16 interval){

    u16 intv = interval / 0.625 ;
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  intv & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (intv & 0xff00) >> 8;

}

void set_scan_windows(u16 window){

    u16 win  = window   / 0.625 ;
    g_pattern_param.scn_param.LE_Scan_Window[0] =  win & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] = (win & 0xff00) >> 8;
}

void set_scan_policy(u16 policy){

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	policy;
}

void set_conn_interval(u16 interval){

    u16 intv = interval / 1.25 ;
    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    intv & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (intv & 0xff00) >> 8;    
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    intv & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (intv & 0xff00) >> 8;
}

void set_conn_slave_latency(u16 latency){
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (latency & 0xff00) >> 8;    
}

void set_conn_super_timeout(u16 timeout){

    u16 to = timeout / 1.25 ;
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    to & 0x00ff;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (to & 0xff00) >> 8;    
}

#define RX_SUCCESS_RATE 0.99
#define TRX_PKT_CNT     1000
void ssv_dtm_pattern(u8 ti_dut ,u8 ssv_dut ,u16 pkt_cnt ,u8 pkt_len ,u8 pld_type){

	u8   log_cnt=0;
	u8	 channel=0;
    u8   chan_max =40 ;
	u16  rx_pkt_cnt=0;
    u16  rx_pkt_cnt_exp = TRX_PKT_CNT * RX_SUCCESS_RATE;
    
	char   printf_buff1[50][100];
	char   printf_buff2[50][100];

    u8   loop_pkt_len  = 0;
    u8   loop_pld_type = 0;
    
    while(loop_pld_type < 3){        

        printf("\npld_type [%d]\n" , loop_pld_type);

        rx_pkt_cnt=ssv_auto_txrx_ssv_ti(ti_dut,ssv_dut,channel,TRX_PKT_CNT,37,loop_pld_type);

        if( rx_pkt_cnt_exp >= rx_pkt_cnt)
        {
            LOG_INFO("SSV->TI type:%d ; less than %d[%d]\n",loop_pld_type , rx_pkt_cnt_exp , rx_pkt_cnt);
            return;
        }

        loop_pld_type ++ ;
    }

    LOG_INFO("pld_type pattern PASS\n");

    while(loop_pkt_len < 38){

        printf("\npkt_len [%d]\n" , loop_pkt_len);
        
        rx_pkt_cnt=ssv_auto_txrx_ssv_ti(ti_dut,ssv_dut,channel,TRX_PKT_CNT,loop_pkt_len,0);
        
        if( rx_pkt_cnt_exp >= rx_pkt_cnt)
        {
            LOG_INFO("SSV->pkt len:%d ; less than %d[%d]\n", loop_pkt_len, rx_pkt_cnt_exp, rx_pkt_cnt);
            return;
        }

        loop_pkt_len ++;
    }

    LOG_INFO("pkt_len pattern PASS\n");
    
	for ( channel = 0; channel < chan_max ; channel ++)
	{
		rx_pkt_cnt=ssv_auto_txrx_ti_ssv(ti_dut , ssv_dut,channel , TRX_PKT_CNT , 37 , 0);

        sprintf(printf_buff1[channel] ,"TI->SSV ch:%d RX/TX = %d/%d\n",channel , rx_pkt_cnt , TRX_PKT_CNT);

        if( rx_pkt_cnt_exp >= rx_pkt_cnt)
        {
            LOG_INFO("RX->ch:%d ; less than %d[%d]\n", channel , rx_pkt_cnt_exp, rx_pkt_cnt);
            return;
        }

	}

	for ( channel = 0; channel < chan_max ; channel ++)
	{
		rx_pkt_cnt=ssv_auto_txrx_ssv_ti(ti_dut , ssv_dut,channel , TRX_PKT_CNT , 37 , 0);

        sprintf(printf_buff2[channel] ,"SSV->TI ch:%d RX/TX = %d/%d\n",channel , rx_pkt_cnt , TRX_PKT_CNT);

        if( rx_pkt_cnt_exp >= rx_pkt_cnt)
        {
            LOG_INFO("TX->ch:%d ; less than %d[%d]\n", channel , rx_pkt_cnt_exp, rx_pkt_cnt);
            return;
        }
	}

    LOG_INFO("ch pattern PASS\n");

	LOG_INFO("##############################\n");
    
	for( log_cnt = 0 ; log_cnt < chan_max ; log_cnt ++)
	{
		LOG_INFO("%s" , printf_buff1[log_cnt]);
	}

	LOG_INFO("##############################\n");

	for( log_cnt = 0 ; log_cnt < chan_max ; log_cnt ++)
	{
		LOG_INFO("%s" , printf_buff2[log_cnt]);
	}

	LOG_INFO("##############################\n");

    LOG_INFO("dtm all pattern PASS\n");

}


void ssv_auto_dtm(u8 ti_dut ,u8 ssv_dut ,u16 pkt_cnt ,u8 pkt_len ,u8 pld_type){

	int  log_cnt=0;
	u8	 channel=0;
	u8	 chan_max =40;
	u16  rx_pkt_cnt=0;
	char printf_buff1[50][100];
	char printf_buff2[50][100];

	printf("ssv Auto testing with %d %d \n" ,ti_dut,ssv_dut);

	for ( channel = 0; channel < chan_max ; channel ++)
	{
		rx_pkt_cnt=ssv_auto_txrx_ti_ssv(ti_dut,ssv_dut,channel,pkt_cnt,pkt_len,pld_type);

		if(0==rx_pkt_cnt)
		{
			sprintf(printf_buff1[channel] ,"TI->SSV ch:%d Fail\n",channel);
		}
		else
		{
			sprintf(printf_buff1[channel] ,"TI->SSV ch:%d RX/TX = %d/%d\n",channel , rx_pkt_cnt,pkt_cnt);
		}
	}

	for ( channel = 0; channel < chan_max ; channel ++)
	{
		rx_pkt_cnt=ssv_auto_txrx_ssv_ti(ti_dut,ssv_dut,channel,pkt_cnt,pkt_len,pld_type);

		if(0==rx_pkt_cnt)
		{
			sprintf(printf_buff2[channel] ,"SSV->TI ch:%d Fail\n",channel);
		}
		else
		{
			sprintf(printf_buff2[channel] ,"SSV->TI ch:%d RX/TX = %d/%d\n",channel , rx_pkt_cnt,pkt_cnt);
		}
	}

	LOG_INFO("##############################\n");
    
	for( log_cnt = 0 ; log_cnt < chan_max ; log_cnt ++)
	{
		LOG_INFO("%s" , printf_buff1[log_cnt]);
	}

	LOG_INFO("##############################\n");

	for( log_cnt = 0 ; log_cnt < chan_max ; log_cnt ++)
	{
		LOG_INFO("%s" , printf_buff2[log_cnt]);
	}

	LOG_INFO("##############################\n");

	printf("Exit SSV Auto testing\n");
}




void COMM_Ltk_Req_Rep_Config(u8 dut_fd ,Pattern_param * param , u8 * conn_handle)
{
	param->ltk_req_rep_parameter.Connection_Handle[0]=conn_handle[0];
	param->ltk_req_rep_parameter.Connection_Handle[1]=conn_handle[1];

	memcpy(param->ltk_req_rep_parameter.Long_Term_Key,			enc_ltk,		16);

	bt_hci_cmd_le_long_term_key_request_reply.parameter_tbl[0].value = param->ltk_req_rep_parameter.Connection_Handle;
	bt_hci_cmd_le_long_term_key_request_reply.parameter_tbl[1].value = param->ltk_req_rep_parameter.Long_Term_Key;
}

void COMM_Ltk_Req_Negative_Rep_Config(u8 dut_fd ,Pattern_param * param , u8 * conn_handle)
{
	param->ltk_req_negative_rep_parameter.Connection_Handle[0]=conn_handle[0];
	param->ltk_req_negative_rep_parameter.Connection_Handle[1]=conn_handle[1];

	bt_hci_cmd_le_long_term_key_request_negative_reply.parameter_tbl[0].value = param->ltk_req_negative_rep_parameter.Connection_Handle;
}


void COMM_Start_Encryption_Config(u8 dut_fd ,Pattern_param * param , u8 * conn_handle)
{
	param->encryption_parameter.Connection_Handle[0]=conn_handle[0];
	param->encryption_parameter.Connection_Handle[1]=conn_handle[1];

	memcpy(param->encryption_parameter.Random_Number ,		    enc_rand ,	8);
	memcpy(param->encryption_parameter.Encrypted_Diversifier ,	enc_ediv ,	2);
	memcpy(param->encryption_parameter.Long_Term_Key,			enc_ltk  ,	16);

	bt_hci_cmd_le_start_encryption .parameter_tbl[0].value = param->encryption_parameter.Connection_Handle;
	bt_hci_cmd_le_start_encryption .parameter_tbl[1].value = param->encryption_parameter.Random_Number;
	bt_hci_cmd_le_start_encryption .parameter_tbl[2].value = param->encryption_parameter.Encrypted_Diversifier ;
	bt_hci_cmd_le_start_encryption .parameter_tbl[3].value = param->encryption_parameter.Long_Term_Key;
}

void COMM_Static_Random_Device_Address_Set_Config(u8* addr)
{
	bt_hci_cmd_le_set_random_address.parameter_tbl[0].value = addr;
}

void COMM_Random_Device_Address_Set_Config (u8 DUT ,Pattern_param * param)
{
	u8 cnt=0;
	//should get a random addr for SEC
	param->random_address[0]=0xb6;
	param->random_address[1]=0x54;
	param->random_address[2]=0x10;
	param->random_address[3]=0x40;
	param->random_address[4]=0x21;
	param->random_address[5]=0x61;

	for( ; cnt < 15 ; cnt++)
		param->ir[cnt] = param->plaintext[cnt]=cnt;

	param->ir[cnt] = param->plaintext[cnt]=0x01;


	bt_hci_cmd_le_set_random_address.parameter_tbl[0].value = param->random_address;
	bt_hci_cmd_le_encrypt.parameter_tbl[0].value=param->ir;
	bt_hci_cmd_le_encrypt.parameter_tbl[1].value=param->plaintext;


}


void COMM_Device_Address_Set_Config (u8 DUT ,Pattern_param * param)
{
	//should get a random addr for SEC
	param->random_address[0]=0x00;
	param->random_address[1]=0x01;
	param->random_address[2]=0x02;
	param->random_address[3]=0x03;
	param->random_address[4]=0x04;
	param->random_address[5]=0b11000011;

	bt_hci_cmd_le_set_random_address.parameter_tbl[0].value = param->random_address;
}

void COMM_Ch_Map_Set_Config (u8 DUT , Pattern_param * param , u64 ch_map)
{
	param->LE_Channel_Map[0]= (ch_map & 0x00000000FF)		;//ch 0~ 7
	param->LE_Channel_Map[1]= (ch_map & 0x000000FF00) >> 8	;//ch 8~ 15
	param->LE_Channel_Map[2]= (ch_map & 0x0000FF0000) >> 16 ;//ch 16~23
	param->LE_Channel_Map[3]= (ch_map & 0x00FF000000) >> 24 ;//ch 24~31
	param->LE_Channel_Map[4]= (ch_map & 0x1F00000000) >> 32 ;//ch 36	

	bt_hci_cmd_le_set_host_channel_classification.parameter_tbl[0].value = param->LE_Channel_Map;
}


void COMM_Ch_Map_Read_Config (Pattern_param * param , u8 *conn_handle)
{
	param->LE_Connection_Handle[0]= conn_handle[0]  ;
	param->LE_Connection_Handle[1]= conn_handle[1]  ;

	bt_hci_cmd_le_read_channel_map.parameter_tbl[0].value = param->LE_Connection_Handle;
}


void COMM_Conn_Update_Set_Config (u8 DUT , Pattern_param * param , u8 * conn_handle)
{

	param->conn_update_param.Connection_Handle[0]		= conn_handle[0];
	param->conn_update_param.Connection_Handle[1]		= conn_handle[1];

	param->conn_update_param.Conn_Interval_Min[0]		=24;//HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	param->conn_update_param.Conn_Interval_Min[1]		=0;//(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)	>> 8;
	param->conn_update_param.Conn_Interval_Max[0]		=40;
	param->conn_update_param.Conn_Interval_Max[1]		=0;
	param->conn_update_param.Conn_Latency[0]		    =HCI_CMD_PARAM_CONN_LATENCY_MIN;//HCI_CMD_PARAM_CONN_LATENCY_MAX & 0x00ff;
	param->conn_update_param.Conn_Latency[1]		    =HCI_CMD_PARAM_CONN_LATENCY_MIN;//(HCI_CMD_PARAM_CONN_LATENCY_MAX & 0xff00)  >> 8;
	//The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
	//superviision TO > (1+connSlaveLatency)*Conninterval
	param->conn_update_param.Supervision_Timeout[0] 	=0x64; //=0xD0;
	param->conn_update_param.Supervision_Timeout[1] 	=0x00 ; //=0x07;


	bt_hci_cmd_le_connection_update.parameter_tbl[0].value = param->conn_update_param.Connection_Handle;
	bt_hci_cmd_le_connection_update.parameter_tbl[1].value = param->conn_update_param.Conn_Interval_Min;
	bt_hci_cmd_le_connection_update.parameter_tbl[2].value = param->conn_update_param.Conn_Interval_Max;
	bt_hci_cmd_le_connection_update.parameter_tbl[3].value = param->conn_update_param.Conn_Latency;
	bt_hci_cmd_le_connection_update.parameter_tbl[4].value = param->conn_update_param.Supervision_Timeout;
	bt_hci_cmd_le_connection_update.parameter_tbl[5].value = param->conn_update_param.Minimum_CE_Length;
	bt_hci_cmd_le_connection_update.parameter_tbl[6].value = param->conn_update_param.Maximum_CE_Length;

}

verdict COMM_Send_ACL_Data_Without_event (u8 dut_fd , u8 * conn_handle , u8 pb ,u8 bc ,u16 data_len,u8* data)
{
	u8 ret;
	bt_hci_acl_data raw_data;
	//the conn_handle should be MSB->LSB
	//ex: 01 04 =>04<<8 | 01 = 401
	raw_data.conn_handle= conn_handle[0] |( conn_handle[1] << 8);
	raw_data.pb = pb & 0b00000011;
	raw_data.bc = bc & 0b00000011;
	raw_data.length =data_len;
	raw_data.data =data;

	//printf("%3x %d %d %ld\n" , row_data.conn_handle, row_data.pb ,row_data.bc ,row_data.length);
	HCI_WRITEDATA(raw_data);
	return PASS;
}


verdict COMM_Send_ACL_Data (u8 dut_fd , u8 * conn_handle , u8 pb ,u8 bc ,u16 data_len,u8* data)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;
	bt_hci_acl_data raw_data;
	//the conn_handle should be MSB->LSB
	//ex: 01 04 =>04<<8 | 01 = 401
	raw_data.conn_handle= conn_handle[0] |( conn_handle[1] << 8);
	raw_data.pb = pb & 0b00000011;
	raw_data.bc = bc & 0b00000011;
	raw_data.length =data_len;
	raw_data.data =data;

	//printf("%3x %d %d %ld\n" , raw_data.conn_handle, raw_data.pb ,raw_data.bc ,raw_data.length);
	HCI_WRITEDATA_AND_NUMPACKETS_PARSING(raw_data);
	return PASS;
}

int COMM_Scan_Response_Data_Set_Config(u8 dut_fd , u16 len, Pattern_param * param)
{   
    memset(param->scn_rsp_param.Scan_Response_Data , 0 , sizeof(param->scn_rsp_param.Scan_Response_Data));
	param->scn_rsp_param.Scan_Response_Data_Length[0] = len;
	param->scn_rsp_param.Scan_Response_Data[0] = 0x44;
	param->scn_rsp_param.Scan_Response_Data[1] = 0x55;
	param->scn_rsp_param.Scan_Response_Data[2] = 0x54;

	bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = param->scn_rsp_param.Scan_Response_Data_Length;
	bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = param->scn_rsp_param.Scan_Response_Data;

    return 0;
}

verdict COMM_Scan_Response_Data_Set(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_response_data);

	return ret;
}

int COMM_Random_Device_Address_Set (u8 dut_fd ,Pattern_param *param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;
	u8 prand[8];
	u8 irk[16];
	u8 encryptdata[16];

	u8 ir[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,0x10};
	u8 irk_pad[16] = {0};
	irk_pad[0] = 1;

    PRINT_TIME;

	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_rand);
    do{ 
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}

	memcpy(prand, buf+7, 3);
	//set bit 23 to 1, bit 24 to 0.
	prand[2] |= 0x40;
	prand[2] &= 0x7f;
	print_charray(3,prand);

	//generate IRK
	bt_hci_cmd_le_encrypt.parameter_tbl[0].value = ir;
	bt_hci_cmd_le_encrypt.parameter_tbl[1].value = irk_pad;
	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_le_encrypt);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	//irk
	memcpy(encryptdata, buf+7, 16);
	print_charray(16,encryptdata);

	memcpy(irk,encryptdata,16);   //save irk
	memset(encryptdata,0,sizeof(encryptdata));
	memcpy(encryptdata,prand,3);	//use prand as encryptdata to gen hash value

	//generate hash value
	bt_hci_cmd_le_encrypt.parameter_tbl[0].value = irk;
	bt_hci_cmd_le_encrypt.parameter_tbl[1].value = encryptdata;
	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_le_encrypt);
    do{ 
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
					buf[_BT_HCI_IDX_EVENT_LENGTH_],
					buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	//hash value
	printf("hash value:\n");
	memcpy(encryptdata, buf+7, 16);
	print_charray(3,encryptdata);

	//use the first 3 bytes of hash value as the lower 3 bytes of address
	//use the higher 3 bytes prand as the higher 3 bytes of address
	memcpy(param->random_address+3,prand,3);// higher 24 bit is prand
	memcpy(param->random_address,encryptdata,3);
	/*	  param->random_address[0] = prand[2];
	param->random_address[1] = prand[1];
	param->random_address[2] = prand[0];
	param->random_address[3] = encryptdata[2];
	param->random_address[4] = encryptdata[1];
	param->random_address[5] = encryptdata[0];
	*/
	printf("random address:\n");
	print_charray(6,param->random_address);
	bt_hci_cmd_le_set_random_address.parameter_tbl[0].value = param->random_address;
#if 0
	bt_hci_cmd_le_encrypt.parameter_tbl[0].value=encryptdata;
	bt_hci_cmd_le_encrypt.parameter_tbl[1].value=prand_shift ;
#endif
#if 0
	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_set_random_address);

    do{
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_read_bd_addr);
    do{
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
#endif
	return 0;
}

int TI_sleep_mode_configurations (u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    u8 reserved[1]              = {0}; 
    u8 sleep_enable[1]          = {0};
    u8 sleep_mode[1]            = {0};
    u8 output_io_select[1]      = {0};
    u8 output_pull_enable[1]    = {0};
    u8 input_pull_enable[1]     = {0};
    u8 input_io_select[1]       = {0};
    u8 reserved2[2]             = {0};
/*
    https://e2e.ti.com/support/wireless_connectivity/bluetooth_cc256x/f/660/t/134855
*/
#define SLEEP_MODE_HCILL       0
#define SLEEP_MODE_DONT_CHANGE 0xff

    reserved[0]                 =  1    ;
    sleep_enable[0]             =  1    ;    
    sleep_mode[0]               =  SLEEP_MODE_HCILL    ;
    output_io_select[0]         =  0xff ;
    output_pull_enable[0]       =  0xff ;
    input_pull_enable[0]        =  0xff ;
    input_io_select[0]          =  0xff ;    
    reserved2[0]                =  100  ;
    reserved2[1]                =  0    ;

    bt_hci_cmd_ti_sleep_mode_configurations.parameter_tbl[0].value = reserved;
    bt_hci_cmd_ti_sleep_mode_configurations.parameter_tbl[1].value = sleep_enable;
    bt_hci_cmd_ti_sleep_mode_configurations.parameter_tbl[2].value = sleep_mode;
    bt_hci_cmd_ti_sleep_mode_configurations.parameter_tbl[3].value = output_io_select;
    bt_hci_cmd_ti_sleep_mode_configurations.parameter_tbl[4].value = output_pull_enable;
    bt_hci_cmd_ti_sleep_mode_configurations.parameter_tbl[5].value = input_pull_enable;
    bt_hci_cmd_ti_sleep_mode_configurations.parameter_tbl[6].value = input_io_select;
    bt_hci_cmd_ti_sleep_mode_configurations.parameter_tbl[7].value = reserved2;
    
    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_sleep_mode_configurations);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);

	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}


int TI_Get_System_Status (u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_get_system_status);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}

//#define TI_BAUDRATE_115K 0x01c4e6
//#define TI_BAUDRATE_230k 0x038c6e
//#define TI_BAUDRATE_460k 0x071183
#define TI_BAUDRATE_920k 0x0E20E5


int TI_Update_Hci_Baudrate (u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    u8 baudrate[4] = {0};

    baudrate[3] = ((TI_BAUDRATE_920k)& 0xff000000)>> 24 ;
    baudrate[2] = ((TI_BAUDRATE_920k)& 0x00ff0000)>> 16 ;
    baudrate[1] = ((TI_BAUDRATE_920k)& 0x0000ff00)>> 8 ;
    baudrate[0] = ((TI_BAUDRATE_920k)& 0x000000ff)>> 0 ;

    bt_hci_cmd_ti_update_uart_hci_baudrate.parameter_tbl[0].value = baudrate;

    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_update_uart_hci_baudrate);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}

s8 pwr_lv_tbl [16]={
    -50 , 
     12 , //8 
    -23 , //-24
    -23 ,
    -23 ,
    -23 ,
    -23 ,
    -23 ,
    -23 ,
    -18 , //-18.5
    -13 , //-14
    -8  , //-9
    -3  , //-4
     2  , //0
     7  , //2 //2
     12 , //8
};

int TI_Output_power (u8 dut_fd , u8 power_lv)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    u8 power_level[1] = {power_lv} ;
    bt_hci_cmd_ti_le_output_power.parameter_tbl[0].value = power_level;

    PRINT_TIME;

    printf("\nset power_lv to [%d] dbm\n" , pwr_lv_tbl[power_level[0]]);

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_le_output_power);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}


int TI_Cont_Tx_Mode (u8 dut_fd , u8* pcmd_param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;
	u32 reserved = 0x00000000;

    bt_hci_cmd_ti_cont_tx_mode.parameter_tbl[0].value = &pcmd_param[TI_CONT_TX_MOD];
    bt_hci_cmd_ti_cont_tx_mode.parameter_tbl[1].value = &pcmd_param[TI_CONT_TX_TP];
    bt_hci_cmd_ti_cont_tx_mode.parameter_tbl[2].value = &pcmd_param[TI_CONT_TX_FREQ];
    bt_hci_cmd_ti_cont_tx_mode.parameter_tbl[3].value = &pcmd_param[TI_CONT_TX_PWR];
    bt_hci_cmd_ti_cont_tx_mode.parameter_tbl[4].value = &reserved;
    bt_hci_cmd_ti_cont_tx_mode.parameter_tbl[5].value = &reserved;

    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_cont_tx_mode);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}


int TI_Write_BD_Addr (u8 dut_fd , u8* bd_addr)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    bt_hci_cmd_ti_write_bd_addr.parameter_tbl[0].value = bd_addr;

    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_write_bd_addr);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}


int TI_Pkt_Tx_Rx (u8 dut_fd , u16* pcmd_param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;
	u8 reserved = 0x00;
	u8 disable_whitening = 0x01;

    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[0].value = &pcmd_param[TI_PKT_TXRX_FREQ_MODE];
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[1].value = &pcmd_param[TI_PKT_TXRX_TX_CH];
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[2].value = &pcmd_param[TI_PKT_TXRX_RX_CH];
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[3].value = &pcmd_param[TI_PKT_TXRX_PKT_TYPE];
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[4].value = &pcmd_param[TI_PKT_TXRX_PKT_PATTERN];
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[5].value = &reserved;
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[6].value = &pcmd_param[TI_PKT_TXRX_PKT_LEN];
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[7].value = &pcmd_param[TI_PKT_TXRX_PWR_LEVEL];
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[8].value = &disable_whitening;
    bt_hci_cmd_ti_pkt_tx_rx.parameter_tbl[9].value = &pcmd_param[TI_PKT_TXRX_PRBS9];

    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_pkt_tx_rx);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}


int TI_BER_Meter_Start (u8 dut_fd , u16* pcmd_param, u8* bd_addr)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;
	u8 reserved = 0x00;
	u8 lt_addr = 0x01;
	u8 poll_period = 0x01;

    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[0].value = &pcmd_param[TI_BER_METER_START_FREQ];
    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[1].value = &reserved;
    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[2].value = bd_addr;
    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[3].value = &lt_addr;
    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[4].value = &pcmd_param[TI_BER_METER_START_PKT_TYPE];
    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[5].value = &pcmd_param[TI_BER_METER_START_PKT_LEN];
    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[6].value = &pcmd_param[TI_BER_METER_START_NUM_OF_PKT];
    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[7].value = &pcmd_param[TI_BER_METER_START_PRBS9];
    bt_hci_cmd_ti_ber_meter_start.parameter_tbl[8].value = &poll_period;

    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_ber_meter_start);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}


int TI_Read_BER_Meter_Result (u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_ti_read_ber_meter_result);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}


int COMM_Ch_Map_Set (u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    PRINT_TIME;

	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_set_host_channel_classification);

    do{ 
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}

int COMM_Ch_Map_Check (u8 dut_fd ,Pattern_param param )
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8  status;
    u16 conn_handle;
    u16 conn_handle_config;

    PRINT_TIME;

	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_read_channel_map);

    do{ 
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
    
	status      =   buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
    
	conn_handle =   buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_EVT_LE_READ_CHANNEL_MAP_CONN_HANDLE] + \
                   (buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_EVT_LE_READ_CHANNEL_MAP_CONN_HANDLE + 1] << 8);

    conn_handle_config = (u16)(param.LE_Connection_Handle[0]) + (u16)(param.LE_Connection_Handle[1] << 8) ;

	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);

	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return status;
	}else{

        if(conn_handle !=  conn_handle_config){
            printf("conn handle mismatch %x : %x \n" , conn_handle , conn_handle_config);
            printf("%s FAILED\n" , __FUNCTION__);
            return ERROR ;
        }

        if( memcmp(buf+_BT_HCI_W_EVENT_HEADER_+_BT_HCI_EVT_LE_READ_CHANNEL_MAP_CHANNEL_MAP , 
                   &(param.LE_Channel_Map), 5 ) != 0){
        
            printf("channel map mismatch \n");
            printf("%s FAILED\n" , __FUNCTION__);
            return ERROR ;
        }  
	}
    
	return 0;
}



int COMM_Conn_Update_Set (u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
    u8 ret ;

    PRINT_TIME;
    
	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_connection_update);

    do{
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	printf("Get Event(%d):\n",dut_fd);	
	print_charray(len,buf); 
	if(SOCKET_SUCCESS != ret){	
		return FAIL;	
	}

    ret = hci_event_command_status_parsing(buf);
    
	if (CMD_SUCCESS == ret) {
        printf("command status (success)\n\n");
    }    
	else{        
        printf("command status (failed 0x%x)\n\n" , ret);
        return ret;
    }
	return PASS;

}

int COMM_Read_BD_Addr (u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    PRINT_TIME;

	bt_hci_write_cmd2socket (dut_fd, &bt_hci_cmd_read_bd_addr);
    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	print_charray(len,buf);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}

#define LOCAL_FEATURES 0x4000000000
int COMM_Read_Local_features (u8 dut_fd ,Pattern_param param)
{
	u8  buf[SOCKET_BUF_SIZE];
	u16 len;
	u8  ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_read_local_supported_features);

    u64 val = *(u64*)(buf+_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_);
    if(val != LOCAL_FEATURES){
        printf("local features mismatch %llx / %llx \n" , val , LOCAL_FEATURES );
        return FAIL;
    }else{
        printf("local features %x %x %x %x %x %x %x %x\n" , 
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 7],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 6],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 5],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 4],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 3],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 2],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 1],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 0]
        );
    }
       
	return PASS;

}

int COMM_Read_Local_commands (u8 dut_fd ,Pattern_param param)
{
	u8  buf[SOCKET_BUF_SIZE];
	u16 len;
	u8  ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_read_local_supported_commands);

    u64 val = *(u64*)(buf+_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_);
    if(0)//(val != LOCAL_FEATURES)
    {
        printf("local commands mismatch %llx / %llx \n" , val , LOCAL_FEATURES );
        return FAIL;
    }else{
        printf("local commands %x %x %x %x %x %x %x %x\n" ,
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 7],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 6],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 5],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 4],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 3],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 2],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 1],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 0]
        );
    }

	return PASS;

}
#define LE_LOCAL_FEATURES 0x01
int COMM_LE_Read_Local_features (u8 dut_fd ,Pattern_param param)
{
	u8  buf[SOCKET_BUF_SIZE];
	u16 len;
	u8  ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_read_local_supported_features);

    u64 val = *(u64*)(buf+_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_);
    if(val != LE_LOCAL_FEATURES){
        printf("LE local features mismatch %llx / %x \n" , val , LE_LOCAL_FEATURES );
        return FAIL;
    }else{
        printf("LE local features  %x %x %x %x %x %x %x %x\n" , 
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 7],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 6],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 5],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 4],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 3],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 2],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 1],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 0]
        );
    }

	return PASS;

}

#define LE_LOCAL_STATES 0xC30FFBF
int COMM_LE_Read_Local_supported_states (u8 dut_fd ,Pattern_param param)
{
	u8  buf[SOCKET_BUF_SIZE];
	u16 len;
	u8  ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_read_local_supported_states);


    u64 val = *(u64*)(buf+_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_);
    if(val != LE_LOCAL_STATES){
        printf("LE local supported states mismatch %llx / %x \n" , val , LE_LOCAL_STATES );
        return FAIL;
    }else{
        printf("LE local supported states %x %x %x %x %x %x %x %x\n" , 
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 7],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 6],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 5],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 4],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 3],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 2],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 1],
            buf[_BT_HCI_W_CMD_HEADER_ + _BT_HCI_IDX_EVENT_PARAMETER_ + 0]
        );
    }

	return PASS;

}


int COMM_Device_Address_Set (u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    PRINT_TIME;

	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_set_random_address);

    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return ERROR;
	}
	return 0;
}


void COMM_ADV_Advertising_Parameters_Set_Config (u8 DUT ,Pattern_param * param)
{
    printf("adv interval min %x %x\n" , param->adv_param.Advertising_Interval_Min[1] ,param->adv_param.Advertising_Interval_Min[0]);
    printf("adv interval max %x %x\n" , param->adv_param.Advertising_Interval_Max[1] ,param->adv_param.Advertising_Interval_Max[0]);
    printf("adv type %x\n" , param->adv_param.Advertising_Type[0]);
    printf("own addr type %x\n" , param->adv_param.Own_Address_Type[0]);
    printf("dir addr type %x\n" , param->adv_param.Direct_Address_Type[0]);
    printf("adv ch %x\n" , param->adv_param.Advertising_Channel_Map[0]);
    printf("adv filter %x\n" , param->adv_param.Advertising_Filter_Policy[0]);

	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = param->adv_param.Advertising_Interval_Min;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = param->adv_param.Advertising_Interval_Max;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = param->adv_param.Advertising_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = param->adv_param.Own_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = param->adv_param.Direct_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = param->adv_param.Direct_Address;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = param->adv_param.Advertising_Channel_Map;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = param->adv_param.Advertising_Filter_Policy;
}


int COMM_ADV_Advertising_Parameters_Set (u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

    PRINT_TIME;

	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_set_advertising_parameters);

    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return status;
	}
	return 0;
}

verdict COMM_ADV_Advertising_Data_Set(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_data);

	return PASS;
}

void COMM_ADV_Directed_Advertising_Reconfig (Pattern_param * paramDst)
{
	static u8 adv_ent =2; //start from ch39(adv_ent=2)

	//advevent(1~20)[1]+Addr[6]+Addr[2]+Ch[1]=10bytes
	//paramDst->adv_data_param.Advertising_Data_Length[0] = 10;

	paramDst->adv_data_param.Advertising_Data[0]=adv_ent;
#if 0 //mark for SM implement
	paramDst->adv_data_param.Advertising_Data[1]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[2]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[3]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[4]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[5]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[6]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[7]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[8]=paramSrc->adv_data_param.Advertising_Data[0];
#endif

	switch(adv_ent%3)
	{
		case 1:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
		break;

		case 2:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
		break;

		case 0:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
		break;
	}

	paramDst->adv_data_param.Advertising_Data[9]=37+(adv_ent % 3);

	paramDst->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;
	adv_ent++;

}


void COMM_ADV_Undirected_Advertising_Reconfig (Pattern_param * paramDst)
{
	static u8 adv_ent =2; //start from ch39(adv_ent=2)

	//advevent(1~20)[1]+Addr[6]+Addr[2]+Ch[1]=10bytes
	//paramDst->adv_data_param.Advertising_Data_Length[0] = 10;

	paramDst->adv_data_param.Advertising_Data[0]=adv_ent;
#if 0 //mark for SM implement
	paramDst->adv_data_param.Advertising_Data[1]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[2]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[3]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[4]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[5]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[6]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[7]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[8]=paramSrc->adv_data_param.Advertising_Data[0];
#endif

	switch(adv_ent%3)
	{
		case 1:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
		break;

		case 2:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
		break;

		case 0:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
		break;
	}

	paramDst->adv_data_param.Advertising_Data[9]=37+(adv_ent % 3);

	paramDst->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;
	adv_ent++;

}


void COMM_ADV_NonConnectable_Advertising_Reconfig (Pattern_param * paramDst)
{
	static u8 adv_ent =2;

	//advevent(1~20)[1]+Addr[6]+Addr[2]+Ch[1]=10bytes
	//paramDst->adv_data_param.Advertising_Data_Length[0] = 10;

	paramDst->adv_data_param.Advertising_Data[0]=adv_ent;
#if 0 //mark for SM implement
	paramDst->adv_data_param.Advertising_Data[1]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[2]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[3]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[4]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[5]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[6]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[7]=paramSrc->adv_data_param.Advertising_Data[0];
	paramDst->adv_data_param.Advertising_Data[8]=paramSrc->adv_data_param.Advertising_Data[0];
#endif

	switch(adv_ent%3)
	{
		case 1:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
		break;

		case 2:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
		break;

		case 0:
			paramDst->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
		break;
	}

	paramDst->adv_data_param.Advertising_Data[9]=37+(adv_ent % 3);//start from ch38
	paramDst->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;
	adv_ent++;
}

void COMM_ADV_NonConnectable_Advertising_Config (u8 len ,Pattern_param * param)
{
	int payload_cnt = 0;

	// P.27 to set the parameters' advertising interval and advertising channel map
	param->adv_param.Advertising_Interval_Min[0]= HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
	param->adv_param.Advertising_Interval_Min[1]=(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
	param->adv_param.Advertising_Interval_Max[0]= HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0x00ff;
	param->adv_param.Advertising_Interval_Max[1]=(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0xff00)	>> 8;
	param->adv_param.Advertising_Type[0]	= HCI_CMD_PARAM_ADV_NONCONN_IND;
	param->adv_param.Own_Address_Type[0]	= HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->adv_param.Direct_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;

    memcpy (param->adv_param.Direct_Address , adv_addr , ADDR_LENGTH);

	param->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 | HCI_CMD_PARAM_ENABLE_CHANNEL_38 |HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	param->adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	//TP p.46 ,set policy:0x03
	//HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;

	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = param->adv_param.Advertising_Interval_Min;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = param->adv_param.Advertising_Interval_Max;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = param->adv_param.Advertising_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = param->adv_param.Own_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = param->adv_param.Direct_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = param->adv_param.Direct_Address;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = param->adv_param.Advertising_Channel_Map;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = param->adv_param.Advertising_Filter_Policy;

	param->adv_data_param.Advertising_Data_Length[0]=len;
	bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = param->adv_data_param.Advertising_Data_Length;

	if (0 != len)
	{
		for ( ; payload_cnt  < len ; payload_cnt++){
			param->adv_data_param.Advertising_Data[payload_cnt]=payload_cnt;
		}
		bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = param->adv_data_param.Advertising_Data;
	}

	param->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

	bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = param->Advertising_Enable;
}


verdict COMM_ADV_NonConnectable_Advertising(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_parameters);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_data);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertise_enable);

	return PASS;

}

void COMM_ADV_Undirected_Advertising_Config (u8 len ,Pattern_param * param)
{

	int payload_cnt = 0;

	// P.27 to set the parameters' advertising interval and advertising channel map
	param->adv_param.Advertising_Interval_Min[0]=HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	param->adv_param.Advertising_Interval_Min[1]=(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	param->adv_param.Advertising_Interval_Max[0]=HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0x00ff;
	param->adv_param.Advertising_Interval_Max[1]=(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0xff00)	>> 8;
	param->adv_param.Advertising_Type[0]	= HCI_CMD_PARAM_ADV_IND;
	param->adv_param.Own_Address_Type[0]    = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->adv_param.Direct_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;

	memcpy (param->adv_param.Direct_Address , adv_addr , ADDR_LENGTH);

	param->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 | HCI_CMD_PARAM_ENABLE_CHANNEL_38 |HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	param->adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;

	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = param->adv_param.Advertising_Interval_Min;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = param->adv_param.Advertising_Interval_Max;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = param->adv_param.Advertising_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = param->adv_param.Own_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = param->adv_param.Direct_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = param->adv_param.Direct_Address;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = param->adv_param.Advertising_Channel_Map;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = param->adv_param.Advertising_Filter_Policy;


	param->adv_data_param.Advertising_Data_Length[0]=len;
	bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = param->adv_data_param.Advertising_Data_Length;

	if (0 != len)
	{
		for (; payload_cnt	< len ; payload_cnt++)
			param->adv_data_param.Advertising_Data[payload_cnt]=payload_cnt;
		bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = param->adv_data_param.Advertising_Data;
	}
	memset(param->scn_rsp_param.Scan_Response_Data , 0 , len);
	param->scn_rsp_param.Scan_Response_Data_Length[0]=len;
	param->scn_rsp_param.Scan_Response_Data[0]=0x44;
	param->scn_rsp_param.Scan_Response_Data[1]=0x55;
	param->scn_rsp_param.Scan_Response_Data[2]=0x54;

	bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = param->scn_rsp_param.Scan_Response_Data_Length;
	bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = param->scn_rsp_param.Scan_Response_Data;


	param->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

	bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = param->Advertising_Enable;
}


verdict COMM_ADV_Advertising(u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_parameters);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_data);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_response_data);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertise_enable);

	return PASS;
}


verdict COMM_ADV_Undirected_Advertising(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_parameters);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_data);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_response_data);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertise_enable);

	return PASS;
}

void COMM_ADV_Discoverable_Advertising_Config (u8 len ,Pattern_param * param)
{
	int payload_cnt = 0;

	// P.27 to set the parameters' advertising interval and advertising channel map
	param->adv_param.Advertising_Interval_Min[0]=HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
	param->adv_param.Advertising_Interval_Min[1]=(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
	param->adv_param.Advertising_Interval_Max[0]=HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0x00ff;
	param->adv_param.Advertising_Interval_Max[1]=(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0xff00)	>> 8;
	param->adv_param.Advertising_Type[0]	= HCI_CMD_PARAM_ADV_SCAN_IND;
	param->adv_param.Own_Address_Type[0] =HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->adv_param.Direct_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;

	memcpy (param->adv_param.Direct_Address , adv_addr , ADDR_LENGTH);

	param->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 | HCI_CMD_PARAM_ENABLE_CHANNEL_38 |HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	//param->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
	param->adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;

	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = param->adv_param.Advertising_Interval_Min;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = param->adv_param.Advertising_Interval_Max;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = param->adv_param.Advertising_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = param->adv_param.Own_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = param->adv_param.Direct_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = param->adv_param.Direct_Address;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = param->adv_param.Advertising_Channel_Map;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = param->adv_param.Advertising_Filter_Policy;

	param->adv_data_param.Advertising_Data_Length[0]=len;
	bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = param->adv_data_param.Advertising_Data_Length;

	//if (0 != len)
	{
		for (; payload_cnt	< len ; payload_cnt++)
			param->adv_data_param.Advertising_Data[payload_cnt]=payload_cnt;
		bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = param->adv_data_param.Advertising_Data;
	}

	param->Advertising_Enable[0]= HCI_CMD_PARAM_ADV_ENABLE;

	bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = param->Advertising_Enable;
}


verdict COMM_ADV_Discoverable_Advertising(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_parameters);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_data);
    //HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_response_data);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertise_enable);

	return PASS;
}

void COMM_ADV_Directed_Advertising_Config (u8 DUT ,Pattern_param * param)
{
	// P.27 to set the parameters' advertising interval and advertising channel map
	param->adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	param->adv_param.Advertising_Interval_Min[1] =(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	param->adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0x00ff;
	param->adv_param.Advertising_Interval_Max[1] =(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0xff00)	>> 8;
	param->adv_param.Advertising_Type[0]	     = HCI_CMD_PARAM_ADV_DIRECT_IND;
	param->adv_param.Own_Address_Type[0]         = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->adv_param.Direct_Address_Type[0]      = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;

	memcpy (param->adv_param.Direct_Address , init_addr , ADDR_LENGTH);//should be peer addr!!!

	param->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 | HCI_CMD_PARAM_ENABLE_CHANNEL_38 |HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	param->adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;

	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = param->adv_param.Advertising_Interval_Min;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = param->adv_param.Advertising_Interval_Max;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = param->adv_param.Advertising_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = param->adv_param.Own_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = param->adv_param.Direct_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = param->adv_param.Direct_Address;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = param->adv_param.Advertising_Channel_Map;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = param->adv_param.Advertising_Filter_Policy;

	param->adv_data_param.Advertising_Data_Length[0]=0;
	bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = param->adv_data_param.Advertising_Data_Length;

	param->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

	bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = param->Advertising_Enable;
}


void COMM_ADV_Low_Duty_Directed_Advertising_Config (u8 DUT ,Pattern_param * param)
{
	// P.27 to set the parameters' advertising interval and advertising channel map
	param->adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	param->adv_param.Advertising_Interval_Min[1] =(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	param->adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0x00ff;
	param->adv_param.Advertising_Interval_Max[1] =(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0xff00)	>> 8;
	param->adv_param.Advertising_Type[0]	     = 4;
	param->adv_param.Own_Address_Type[0]         = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->adv_param.Direct_Address_Type[0]      = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;

	memcpy (param->adv_param.Direct_Address , init_addr , ADDR_LENGTH);//should be peer addr!!!

	param->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 | HCI_CMD_PARAM_ENABLE_CHANNEL_38 |HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	param->adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;

	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = param->adv_param.Advertising_Interval_Min;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = param->adv_param.Advertising_Interval_Max;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = param->adv_param.Advertising_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = param->adv_param.Own_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = param->adv_param.Direct_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = param->adv_param.Direct_Address;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = param->adv_param.Advertising_Channel_Map;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = param->adv_param.Advertising_Filter_Policy;

	param->adv_data_param.Advertising_Data_Length[0]=0;
	bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = param->adv_data_param.Advertising_Data_Length;

	param->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

	bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = param->Advertising_Enable;
}
void COMM_ADV_Directed_Advertising_Config_type_addr (u8 DUT ,Pattern_param * param, u8 type, u8 addr[ADDR_LENGTH])
{
	// P.27 to set the parameters' advertising interval and advertising channel map
	param->adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	param->adv_param.Advertising_Interval_Min[1] =(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	param->adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0x00ff;
	param->adv_param.Advertising_Interval_Max[1] =(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX & 0xff00)	>> 8;
	param->adv_param.Advertising_Type[0]	     = HCI_CMD_PARAM_ADV_DIRECT_IND;
	param->adv_param.Own_Address_Type[0]         = type;
	param->adv_param.Direct_Address_Type[0]      = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;

	memcpy (param->adv_param.Direct_Address , addr , ADDR_LENGTH);//should be peer addr!!!

	param->adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 | HCI_CMD_PARAM_ENABLE_CHANNEL_38 |HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	param->adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;

	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = param->adv_param.Advertising_Interval_Min;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = param->adv_param.Advertising_Interval_Max;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = param->adv_param.Advertising_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = param->adv_param.Own_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = param->adv_param.Direct_Address_Type;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = param->adv_param.Direct_Address;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = param->adv_param.Advertising_Channel_Map;
	bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = param->adv_param.Advertising_Filter_Policy;

	param->adv_data_param.Advertising_Data_Length[0]=0;
	bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = param->adv_data_param.Advertising_Data_Length;

	param->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

	bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = param->Advertising_Enable;
}
verdict COMM_ADV_Directed_Advertising(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_parameters);
	//HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_data);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertise_enable);

	return PASS;
}
verdict COMM_ADV_Low_Duty_Directed_Advertising(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	//bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = 0x04;//low duty
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_parameters);
	//HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertising_data);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertise_enable);

	return PASS;
}
//here

void COMM_Disconnect_Config (u8 DUT ,Pattern_param * param , u8 * buf)
{
	param->disconn_param.Connection_Handle[0]	=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
	param->disconn_param.Connection_Handle[1]	=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];
	param->disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;

	bt_hci_cmd_disconnect.parameter_tbl[0].value =param->disconn_param.Connection_Handle;
	bt_hci_cmd_disconnect.parameter_tbl[1].value =param->disconn_param.Reason;
}

verdict COMM_Read_LE_White_List_Size(u8 dut_fd ,Pattern_param *param)
{
	u8  buf[SOCKET_BUF_SIZE];
	u16 len;
	u8  ret;
    u32 line;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_read_white_list_size);

    if(SUCCESS != hci_event_read_white_list_size_parsing(buf)) {
        line = __LINE__;
        return line;
    }else{
        param->white_list_param.Size[0] = 
            buf[_BT_HCI_EVT_LE_READ_WHITE_LIST_SIZE];
    }

	return PASS;
}


verdict COMM_Read_LE_Buffer_Size(u8 dut_fd ,Pattern_param *param)
{
	u8  buf[SOCKET_BUF_SIZE];
	u16 len;
	u8  ret;
    u32 line;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_read_buffer_size);

    if(SUCCESS != hci_event_read_buff_size_parsing(buf)) {
        line = __LINE__;
        return line;
    }else{
        param->buff_size_param.HCI_LE_ACL_Data_Packet_Length = 
            (buf[_BT_HCI_EVT_LE_READ_BUFF_SIZE_LE_DATA_PKT_LEN +1]<< 8) + buf[_BT_HCI_EVT_LE_READ_BUFF_SIZE_LE_DATA_PKT_LEN];
        param->buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets =
            buf[_BT_HCI_EVT_LE_READ_BUFF_SIZE_LE_DATA_PKT_NUM];
    }

    printf("check len %d num %d\n" , 
        param->buff_size_param.HCI_LE_ACL_Data_Packet_Length ,
        param->buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets 
    );

	return PASS;
}

verdict COMM_Read_Local_Version_Information(u8 dut_fd ,Pattern_param *param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_read_local_version_information);

    memcpy( &(param->local_version_information_param.HCI_Version), 
              buf + _BT_HCI_W_EVENT_HEADER_+_BT_HCI_EVT_LOCAL_VER_INFO_HCI_VER, 8);

	return PASS;
}

verdict COMM_Read_Remote_Version_Information_Config(u8 dut_fd ,Pattern_param *param ,u8 * conn_handle )
{
	param->remote_version_information_param.Connection_Handle[0]	=conn_handle[0];
	param->remote_version_information_param.Connection_Handle[1]	=conn_handle[1];

	bt_hci_cmd_read_remote_version_information.parameter_tbl[0].value =param->remote_version_information_param.Connection_Handle;

	return PASS;
}


verdict COMM_Read_Remote_Version_Information(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING_CMD_STATUS(bt_hci_cmd_read_remote_version_information);

    return ret ;
}
/*
verdict COMM_Read_Local_Supported_Features_Config(u8 dut_fd ,Pattern_param *param ,u8 * conn_handle )
{
	param->local_features_param.Connection_Handle[0]	=conn_handle[0];
	param->local_features_param.Connection_Handle[1]	=conn_handle[1];

	bt_hci_cmd_le_read_local_supported_features.parameter_tbl[0].value =param->local_features_param.Connection_Handle;

	return PASS;
}
*/
verdict COMM_Read_Local_Supported_Features(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_read_local_supported_features);

    return ret ;
}

verdict COMM_Read_Local_Supported_States(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_read_local_supported_states);

    return ret ;
}


verdict COMM_Read_Remote_Supported_Features_Config(u8 dut_fd ,Pattern_param *param ,u8 * conn_handle )
{
	param->remote_features_param.Connection_Handle[0]	=conn_handle[0];
	param->remote_features_param.Connection_Handle[1]	=conn_handle[1];

	bt_hci_cmd_le_read_remote_used_features.parameter_tbl[0].value =param->remote_features_param.Connection_Handle;

	return PASS;
}


verdict COMM_Read_Remote_Supported_Features(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING_CMD_STATUS(bt_hci_cmd_le_read_remote_used_features);

    return ret ;
}


verdict COMM_Disconnect(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	//HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_create_connection);
	PRINT_TIME;
	ret=bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_disconnect);
	if(SOCKET_SUCCESS != ret)
		return FAIL;
        do{
            ret=socket_msg_get(dut_fd,&len,buf);
        }while(len <=0);
	printf("Get Event(%d):\n",dut_fd);
	print_charray(len,buf);

	if(SOCKET_SUCCESS != ret){	
		return FAIL;	
	}

    ret = hci_event_command_status_parsing(buf);
    
	if (CMD_SUCCESS == ret) {
        printf("command status (success)\n\n");
    }    
	else{        
        printf("command status (failed 0x%x)\n\n" , ret);
        return ret;
    }

	return PASS;
}


void COMM_INI_Initiating_Config (u8 DUT ,Pattern_param * param)
{
#if 1
	param->create_conn_param.LE_Scan_Interval[0]		=   0xA0;//0x00;
	param->create_conn_param.LE_Scan_Interval[1]		=   0;//0x08;
	param->create_conn_param.LE_Scan_Window[0]			=   0xA0;//18
	param->create_conn_param.LE_Scan_Window[1]			=   0;
	param->create_conn_param.Initiator_Filter_Policy[0] =   HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_NOT_USED;
	param->create_conn_param.Peer_Address_Type[0]		=   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	memcpy(param->create_conn_param.Peer_Address ,adv_addr,ADDR_LENGTH );
	param->create_conn_param.Own_Address_Type[0]		=   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->create_conn_param.Conn_Interval_Min[0]		=   24; //HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	param->create_conn_param.Conn_Interval_Min[1]		=   0;//(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)	>> 8;
	param->create_conn_param.Conn_Interval_Max[0]		=   40;
	param->create_conn_param.Conn_Interval_Max[1]		=   0;
	param->create_conn_param.Conn_Latency[0]		    =   HCI_CMD_PARAM_CONN_LATENCY_MIN;//HCI_CMD_PARAM_CONN_LATENCY_MAX & 0x00ff;
	param->create_conn_param.Conn_Latency[1]		    =   HCI_CMD_PARAM_CONN_LATENCY_MIN;//(HCI_CMD_PARAM_CONN_LATENCY_MAX & 0xff00)  >> 8;
	//The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
	//superviision TO > (1+connSlaveLatency)*Conninterval
	param->create_conn_param.Supervision_Timeout[0] 	=   0x64 ; //=0xD0;
	param->create_conn_param.Supervision_Timeout[1] 	=   0x00 ; //=0x07;
	param->create_conn_param.Minimum_CE_Length[0]		=   0;
	param->create_conn_param.Minimum_CE_Length[1]		=   0;
	param->create_conn_param.Maximum_CE_Length[0]		=   0;
	param->create_conn_param.Maximum_CE_Length[1]		=   0;

	bt_hci_cmd_le_create_connection.parameter_tbl[0].value  =   param->create_conn_param.LE_Scan_Interval;
	bt_hci_cmd_le_create_connection.parameter_tbl[1].value  =   param->create_conn_param.LE_Scan_Window;
	bt_hci_cmd_le_create_connection.parameter_tbl[2].value  =   param->create_conn_param.Initiator_Filter_Policy;
	bt_hci_cmd_le_create_connection.parameter_tbl[3].value  =   param->create_conn_param.Peer_Address_Type;
	bt_hci_cmd_le_create_connection.parameter_tbl[4].value  =   param->create_conn_param.Peer_Address;
	bt_hci_cmd_le_create_connection.parameter_tbl[5].value  =   param->create_conn_param.Own_Address_Type;
	bt_hci_cmd_le_create_connection.parameter_tbl[6].value  =   param->create_conn_param.Conn_Interval_Min;
	bt_hci_cmd_le_create_connection.parameter_tbl[7].value  =   param->create_conn_param.Conn_Interval_Max;
	bt_hci_cmd_le_create_connection.parameter_tbl[8].value  =   param->create_conn_param.Conn_Latency;
	bt_hci_cmd_le_create_connection.parameter_tbl[9].value  =   param->create_conn_param.Supervision_Timeout;
	bt_hci_cmd_le_create_connection.parameter_tbl[10].value =   param->create_conn_param.Minimum_CE_Length;
	bt_hci_cmd_le_create_connection.parameter_tbl[11].value =   param->create_conn_param.Maximum_CE_Length;


#else
	param->create_conn_param.LE_Scan_Interval[0]	=HCI_CMD_PARAM_LE_SCAN_INT_MAX & 0x00ff;
	param->create_conn_param.LE_Scan_Interval[1]	=(HCI_CMD_PARAM_LE_SCAN_INT_MAX & 0xff00)  >> 8;
	param->create_conn_param.LE_Scan_Window[0]	=HCI_CMD_PARAM_LE_SCAN_WIN_MAX & 0x00ff;
	param->create_conn_param.LE_Scan_Window[1]	=(HCI_CMD_PARAM_LE_SCAN_WIN_MAX & 0xff00)  >> 8;
	param->create_conn_param.Initiator_Filter_Policy[0] =HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_NOT_USED;
	param->create_conn_param.Peer_Address_Type[0]		=HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	memcpy(param->create_conn_param.Peer_Address ,adv_addr,ADDR_LENGTH );
	param->create_conn_param.Own_Address_Type[0]		=HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->create_conn_param.Conn_Interval_Min[0]		=HCI_CMD_PARAM_CONN_INT_MAX& 0x00ff; //HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	param->create_conn_param.Conn_Interval_Min[1]		=(HCI_CMD_PARAM_CONN_INT_MAX & 0xff00)	>> 8;//(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;
	param->create_conn_param.Conn_Interval_Max[0]		=HCI_CMD_PARAM_CONN_INT_MAX & 0x00ff;
	param->create_conn_param.Conn_Interval_Max[1]		=(HCI_CMD_PARAM_CONN_INT_MAX & 0xff00)	>> 8;
	param->create_conn_param.Conn_Latency[0]		=HCI_CMD_PARAM_CONN_LATENCY_MIN;//HCI_CMD_PARAM_CONN_LATENCY_MAX & 0x00ff;
	param->create_conn_param.Conn_Latency[1]		=HCI_CMD_PARAM_CONN_LATENCY_MIN;//(HCI_CMD_PARAM_CONN_LATENCY_MAX & 0xff00)  >> 8;
	//The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
	//superviision TO > (1+connSlaveLatency)*Conninterval
	param->create_conn_param.Supervision_Timeout[0] 	=HCI_CMD_PARAM_SUPERVISION_TO_MAX& 0x00ff;
	param->create_conn_param.Supervision_Timeout[1] 	=(HCI_CMD_PARAM_SUPERVISION_TO_MAX & 0xff00)  >> 8;
	param->create_conn_param.Minimum_CE_Length[0]		=HCI_CMD_PARAM_CE_LENGTH_MIN& 0x00ff;
	param->create_conn_param.Minimum_CE_Length[1]		=(HCI_CMD_PARAM_CE_LENGTH_MIN& 0xff00)	>> 8;
	param->create_conn_param.Maximum_CE_Length[0]		=HCI_CMD_PARAM_CE_LENGHT_MAX& 0x00ff;
	param->create_conn_param.Maximum_CE_Length[1]		=(HCI_CMD_PARAM_CE_LENGHT_MAX& 0xff00)	>> 8;

	bt_hci_cmd_le_create_connection.parameter_tbl[0].value =param->create_conn_param.LE_Scan_Interval;
	bt_hci_cmd_le_create_connection.parameter_tbl[1].value =param->create_conn_param.LE_Scan_Window;
	bt_hci_cmd_le_create_connection.parameter_tbl[2].value =param->create_conn_param.Initiator_Filter_Policy;
	bt_hci_cmd_le_create_connection.parameter_tbl[3].value =param->create_conn_param.Peer_Address_Type;
	bt_hci_cmd_le_create_connection.parameter_tbl[4].value =param->create_conn_param.Peer_Address;
	bt_hci_cmd_le_create_connection.parameter_tbl[5].value =param->create_conn_param.Own_Address_Type;
	bt_hci_cmd_le_create_connection.parameter_tbl[6].value =param->create_conn_param.Conn_Interval_Min;
	bt_hci_cmd_le_create_connection.parameter_tbl[7].value =param->create_conn_param.Conn_Interval_Max;
	bt_hci_cmd_le_create_connection.parameter_tbl[8].value =param->create_conn_param.Conn_Latency;
	bt_hci_cmd_le_create_connection.parameter_tbl[9].value =param->create_conn_param.Supervision_Timeout;
	bt_hci_cmd_le_create_connection.parameter_tbl[10].value =param->create_conn_param.Minimum_CE_Length;
	bt_hci_cmd_le_create_connection.parameter_tbl[11].value =param->create_conn_param.Maximum_CE_Length;
#endif
}


verdict COMM_INI_Initiating(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

    PRINT_TIME ;
	//HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_create_connection);
	ret=bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_create_connection);
	if(SOCKET_SUCCESS != ret)
		return FAIL;
    do{ 
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);

	printf("Get Event(%d):\n",dut_fd);
	print_charray(len,buf);
    
	if(SOCKET_SUCCESS != ret){	
		return FAIL;	
	}

    ret = hci_event_command_status_parsing(buf);
    
	if (CMD_SUCCESS == ret) {
        printf("command status (success)\n\n");
    }    
	else{        
        printf("command status (failed 0x%x)\n\n" , ret);
        return ret;
    }
	return PASS;
}

//
verdict COMM_Set_Event_Mask(u8 dut_fd ,Pattern_param * param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

    param->Event_Mask[0]                    =   0x90;
    param->Event_Mask[1]                    =   0x88;
    param->Event_Mask[2]                    =   0x00;
    param->Event_Mask[3]                    =   0x02;
    param->Event_Mask[4]                    =   0x00;
    param->Event_Mask[5]                    =   0x80;
    param->Event_Mask[6]                    =   0x00;
    param->Event_Mask[7]                    =   0x20;

	bt_hci_cmd_set_event_mask.parameter_tbl[0].value =	 param->Event_Mask;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_set_event_mask);

	return PASS;
}

verdict COMM_Le_Set_Event_Mask(u8 dut_fd , Pattern_param * param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	param->LE_Event_Mask[0] 				=	HCI_CMD_PARAM_LE_EVENT_MASK_DEFAULT;
	bt_hci_cmd_le_set_event_mask.parameter_tbl[0].value =param->LE_Event_Mask;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_event_mask);
	return PASS;
}

verdict COMM_Dut_clean_buffer(u8 dut_fd)
{
 	u8 ret;
	HCI_WRITECMD(bt_hci_cmd_dut_clean_buff);

    MSLEEP(10);
	return PASS;
}

verdict COMM_Dut_check_payload(u8 dut_fd , u8 val)
{
    u8 enable[1];
	u8 ret;

    enable[0] = val ;

	bt_hci_cmd_dut_check_payload.parameter_tbl[0].value = enable;            //enable
	HCI_WRITECMD(bt_hci_cmd_dut_check_payload);
    
    MSLEEP(10);
	return PASS;
}

#define ADV_IND_NUM_IDX   0
#define ADV_IND_NUM_WIDTH 2
#define SCN_RSP_NUM_IDX   ADV_IND_NUM_IDX + ADV_IND_NUM_WIDTH
#define SCN_RSP_WIDTH_IDX 2

verdict COMM_Dut_check_adv_rpt_num(u8 dut_fd , u32 *adv_ind , u32 *scn_rsp)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u32 ret;

	HCI_WRITECMD(bt_hci_cmd_dut_query_adv_cnt);

    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
    
	print_charray(len,buf);

    if (adv_ind){
	    *adv_ind =((buf[ADV_IND_NUM_IDX+1]) << 8)+ buf[ADV_IND_NUM_IDX];
    }

    if (scn_rsp){
	    *scn_rsp =((buf[SCN_RSP_NUM_IDX+1]) << 8)+ buf[SCN_RSP_NUM_IDX];
    }
    
    
	return PASS;
}

verdict COMM_Dut_check_num_of_packets_num(u8 dut_fd , u32 *num)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u32 ret;

	HCI_WRITECMD(bt_hci_cmd_dut_query_num_of_packets_cnt);

    do{
        socket_msg_get(dut_fd, &len, buf);
    }while(len <=0);
    
	print_charray(len, buf);

    if (num){
	    *num =((buf[1]) << 8) + buf[0];
    }

	return PASS;
}

verdict COMM_Dut_check_data_buffer_overflow_num(u8 dut_fd , u32 *num)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u32 ret;

	HCI_WRITECMD(bt_hci_cmd_dut_query_data_buffer_overflow_cnt);

    do{
        socket_msg_get(dut_fd, &len, buf);
    }while(len <=0);
    
	print_charray(len, buf);

    if (num){
	    *num =((buf[1]) << 8) + buf[0];
    }

	return PASS;
}

verdict COMM_Dut_check_rx_acl_packets_cnt(u8 dut_fd , u32 *cnt)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u32 ret;

	HCI_WRITECMD(bt_hci_cmd_dut_query_rx_acl_packets_cnt);

    do{
        socket_msg_get(dut_fd, &len, buf);
    }while(len <=0);
    
	print_charray(len, buf);

    if (cnt){
	    *cnt =((buf[1]) << 8) + buf[0];
    }

	return PASS;
}

verdict COMM_Reset(u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_reset);

    MSLEEP(10);
	return PASS;
}

verdict SSV_Ble_init(u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;
    
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_ssv_ble_init);

	return PASS;
}

verdict SSV_Slave_subrate(u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;
    
    u8 enable[1];
    u8 min_tx_latency[1];

    enable[0]           =   1;
    min_tx_latency[0]   =   0; // # if 0 , sleep
    
	bt_hci_cmd_ssv_slave_subrate.parameter_tbl[0].value = enable;            //enable
	bt_hci_cmd_ssv_slave_subrate.parameter_tbl[1].value = min_tx_latency;    //tx latency = 0

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_ssv_slave_subrate);

	return PASS;
}

verdict SSV_Set_adv_channel_priority(u8 dut_fd , ADVERTISING_CHANNEL_PRIORITY adv_ch_priority)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;
    
    u8 priority[1];

    priority[0]           =   adv_ch_priority;
    
	bt_hci_cmd_ssv_set_advertising_channel_priority.parameter_tbl[0].value = priority;            //enable

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_ssv_set_advertising_channel_priority);

	return PASS;
}

verdict SSV_acl_evt_to_external_host(u8 dut_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;
    
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_ssv_acl_evt_to_external_host);

	return PASS;
}

void COMM_SCN_Parameters_Set_Config (u8 DUT ,Pattern_param * param)
{
    printf("scan type %x\n" ,           param->scn_param.LE_Scan_Type[0]);
    printf("scan interval %x %x\n" ,    param->scn_param.LE_Scan_Interval[1] ,param->scn_param.LE_Scan_Interval[0]);
    printf("scan window %x %x\n" ,      param->scn_param.LE_Scan_Window[1], param->scn_param.LE_Scan_Window[0]);
    printf("own addr type %x\n" ,       param->scn_param.Own_Address_Type[0]);
    printf("scan filter %x\n" ,         param->scn_param.Scanning_Filter_Policy[0]);

	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =	param->scn_param.LE_Scan_Type;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =	param->scn_param.LE_Scan_Interval;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =	param->scn_param.LE_Scan_Window;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =	param->scn_param.Own_Address_Type;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =	param->scn_param.Scanning_Filter_Policy;

}


int COMM_SCN_Parameters_Set (u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 status;

	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_set_scan_parameters);

    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	status=buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_];
	//print_charray(len,buf);
	bt_hci_event_parsing(buf[_BT_HCI_IDX_EVENT_CODE_],
						buf[_BT_HCI_IDX_EVENT_LENGTH_],
						buf+_BT_HCI_IDX_EVENT_PARAMETER_);

	printf("Status =%d\n" , status);
	if( 0 != status)
	{
		printf("%s FAILED\n" , __FUNCTION__);
		return status;
	}
	return 0;
}


verdict COMM_SCN_Passive_Scanning_Config (u8 DUT ,Pattern_param * param)
{

	param->scn_param.LE_Scan_Type[0]		=	HCI_CMD_PARAM_PASSIVE_SCAN;
	//if scan_interval = scan_windows , ll should scan continuously P.65
	param->scn_param.LE_Scan_Interval[0]	=	HCI_CMD_PARAM_SCAN_INT_MAX & 0x00ff ;
	param->scn_param.LE_Scan_Interval[1]	=  (HCI_CMD_PARAM_SCAN_INT_MAX & 0xff00) >> 8;
	param->scn_param.LE_Scan_Window[0]		=	HCI_CMD_PARAM_SCAN_WIN_MAX & 0x00ff ;
	param->scn_param.LE_Scan_Window[1]		=  (HCI_CMD_PARAM_SCAN_WIN_MAX & 0xff00) >> 8;
	param->scn_param.Own_Address_Type[0]	=	HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;

	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =param->scn_param.LE_Scan_Type;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =param->scn_param.LE_Scan_Interval;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =param->scn_param.LE_Scan_Window;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =param->scn_param.Own_Address_Type;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =param->scn_param.Scanning_Filter_Policy;

	param->Scan_Enable[0] = HCI_CMD_PARAM_SCAN_ENABLE;
	param->Filter_Duplicates[0] = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

	bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = param->Scan_Enable;
	bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = param->Filter_Duplicates;
	return PASS;

}


verdict COMM_SCN_Passive_Scanning(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_parameters);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_enable);

	return PASS;

}

void COMM_SCN_Active_Scanning_Config (u8 DUT ,Pattern_param * param)
{

	param->scn_param.LE_Scan_Type[0]		=	    HCI_CMD_PARAM_ACTIVE_SCAN;
	param->scn_param.LE_Scan_Interval[0]	=	    HCI_CMD_PARAM_SCAN_INT_MAX & 0x00ff ;
	param->scn_param.LE_Scan_Interval[1]	=	   (HCI_CMD_PARAM_SCAN_INT_MAX & 0xff00) >> 8;
	param->scn_param.LE_Scan_Window[0]	=	        HCI_CMD_PARAM_SCAN_WIN_MAX & 0x00ff ;
	param->scn_param.LE_Scan_Window[1]	=	       (HCI_CMD_PARAM_SCAN_WIN_MAX & 0xff00) >> 8;
	param->scn_param.Own_Address_Type[0]	=	    HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	param->scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;

	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =	param->scn_param.LE_Scan_Type;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =	param->scn_param.LE_Scan_Interval;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =	param->scn_param.LE_Scan_Window;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =	param->scn_param.Own_Address_Type;
	bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =	param->scn_param.Scanning_Filter_Policy;

	param->Scan_Enable[0] = HCI_CMD_PARAM_SCAN_ENABLE;
	param->Filter_Duplicates[0] = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;


	bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value =		param->Scan_Enable;
	bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value =		param->Filter_Duplicates;


}


int COMM_SCN_Active_Scanning(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_parameters);
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_enable);

	return PASS;
}

void COMM_SCN_Disable_Config (u8 DUT ,Pattern_param * param)
{
	param->Scan_Enable[0] = HCI_CMD_PARAM_SCAN_DISABLE;
	param->Filter_Duplicates[0] =HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

	bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value =param->Scan_Enable;
	bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value =param->Filter_Duplicates;
}

void COMM_SCN_Enable_Config (u8 DUT ,Pattern_param * param)
{
	param->Scan_Enable[0] = HCI_CMD_PARAM_SCAN_ENABLE;
	param->Filter_Duplicates[0] =HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;
	bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value =param->Scan_Enable;
	bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value =param->Filter_Duplicates;
}


int COMM_SCN_Enable(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;
	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_enable);
	return PASS;
}


int COMM_SCN_Disable(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_scan_enable);
	return PASS;
}

void COMM_ADV_Disable_Config (u8 DUT ,Pattern_param * param)
{
	param->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_DISABLE;
	bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value =param->Advertising_Enable;

}

void COMM_ADV_Enable_Config (u8 DUT ,Pattern_param * param)
{
	param->Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;
	bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value =param->Advertising_Enable;

}


int COMM_ADV_Disable(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertise_enable);

    return ret;
}

int COMM_ADV_Enable(u8 dut_fd ,Pattern_param param)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_set_advertise_enable);

    return ret;
}

static void  COMM_Add_Device_To_White_List_Config(u8 addr_type ,u8 * addr  ,Pattern_param *param)
{
	param->white_list_param.Address_Type[0]	= addr_type;
	memcpy( param->white_list_param.Address	,addr,ADDR_LENGTH);

	bt_hci_cmd_le_add_device_to_white_list.parameter_tbl[0].value = param->white_list_param.Address_Type;
	bt_hci_cmd_le_add_device_to_white_list.parameter_tbl[1].value = param->white_list_param.Address;
}

static void  COMM_Remove_Device_From_White_List_Config(u8 addr_type ,u8 * addr  ,Pattern_param *param)
{
	param->white_list_param.Address_Type[0]	= addr_type;
	memcpy( param->white_list_param.Address	,addr,ADDR_LENGTH);

	bt_hci_cmd_le_remove_device_from_white_list.parameter_tbl[0].value = param->white_list_param.Address_Type;
	bt_hci_cmd_le_remove_device_from_white_list.parameter_tbl[1].value = param->white_list_param.Address;
}

//bt_hci_cmd_le_read_white_list_size


verdict  COMM_Add_Device_To_White_List(u8 dut_fd , Pattern_param param)
{
	  u8 buf[SOCKET_BUF_SIZE];
	  u16 len;
	  u8 ret;

	  HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_add_device_to_white_list);

      return ret;
}

verdict  COMM_Remove_Device_From_White_List(u8 dut_fd , Pattern_param param)
{
	  u8 buf[SOCKET_BUF_SIZE];
	  u16 len;
	  u8 ret;

	  HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_remove_device_from_white_list);

      return ret;
}


verdict COMM_Clear_White_List(u8 dut_fd)
{
	  u8 buf[SOCKET_BUF_SIZE];
	  u16 len;
	  u8 ret;

	  HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_clear_white_list);

      return ret;
}

static void  COMM_INI_Connection_Setup_White_Listed_Config(u8 DUT ,Pattern_param *param)
{
	param->white_list_param.Address_Type[0]	= HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
	memcpy( param->white_list_param.Address	,scan_addr,ADDR_LENGTH);

	bt_hci_cmd_le_add_device_to_white_list.parameter_tbl[0].value = param->white_list_param.Address_Type;
	bt_hci_cmd_le_add_device_to_white_list.parameter_tbl[1].value = param->white_list_param.Address;
}

verdict  COMM_INI_Connection_Setup_White_Listed(u8 dut_fd , Pattern_param param)
{
	 u8 buf[SOCKET_BUF_SIZE];
	 u16 len;
	 u8 ret;

	 HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_clear_white_list);
	 HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_add_device_to_white_list);

     return ret;
}

verdict  COMM_Start_Encryption(u8 dut_fd , Pattern_param param)
{
	 u8 buf[SOCKET_BUF_SIZE];
	 u16 len;
	 u8 ret;

	 HCI_WRITECMD_AND_GETEVENT_PARSING_CMD_STATUS(bt_hci_cmd_le_start_encryption);

     return ret;
}

verdict  COMM_Ltk_Req_Rep(u8 dut_fd , Pattern_param param)
{
	 u8 buf[SOCKET_BUF_SIZE];
	 u16 len;
	 u8 ret;

	 HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_long_term_key_request_reply);

     return ret;
}

verdict  COMM_Ltk_Req_Negative_Rep(u8 dut_fd , Pattern_param param)
{
	 u8 buf[SOCKET_BUF_SIZE];
	 u16 len;
	 u8 ret;

	 HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_le_long_term_key_request_negative_reply);

     return ret;
}

// 5.2.1.1
verdict DDI_ADV_NonConnectable_Advertising_Events(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line;    
    u32 adv_cnt = 0;    
	struct itimerval timer;	  
    u16 time_reduce = 3;
    u16 test_time   = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
	Calculate_Execution_Time_Start();
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	// 1.	Configure Lower Tester to monitor advertising packets from the IUT.
	// scan_window = scan_Interval = 0x4000
	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);	
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0xff00) >> 8;
    
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	// 2.	Upper Tester enables non connectable advertising in the IUT 
	//		using all supported advertising channels and minimum advertising interval
	COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
    
	//The timing range detected for advertising events(ADV_NONCONN_IND) is from 100.0 ms to 110.0 ms
	//interval : 160(0x00a0) * 0.625ms = 100ms
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
	verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();	

	// step 4-5 
	read_le_event_enable();    
    
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
    		// start the scanning time : 30 sec
    		event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
    		event_query_timer_start(timer, read_le_event_disable);

    		printf("****wait for %d sec****\n" , test_time / time_reduce);

    		while(read_le_event_get()) {

                MSLEEP(10);
                
    			if(SUCCESS != QUERY_LE_Event(dut1_fd,buf,   _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_ , 
                                                            HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {              
    								
    				continue;
    			}			 
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param))	{
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}
		    }
                
        // the ideal value : 30(s) / 110(ms) = 272
        if (((float)((adv_cnt * 100) / (272/time_reduce))) <= 50) {
            LOG_INFO("[Pattern][%s]FAIL, Counter : %d\n", __FUNCTION__, adv_cnt);
    		LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 272/time_reduce);
    		LOG_INFO("[Pattern][%s]Exp   value : %d\n", __FUNCTION__, adv_cnt);
    		LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / (272/time_reduce)));            
            line=__LINE__;
			goto FUN_FAIL;
        }
        else {			

            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 272/time_reduce);
		    LOG_INFO("[Pattern][%s]Exp   value : %d\n", __FUNCTION__, adv_cnt);
		    LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / (272/time_reduce)));
        }        

		return PASS;
    	}
    }
	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;
}

// 5.2.1.2
verdict DDI_ADV_Undirected_Advertising_Events(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 3;
    u16 test_time   = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
    Calculate_Execution_Time_Start();
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	//The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
	//interval : 32(0x0020) * 0.625ms = 20ms
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
    
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
            
            printf("****wait for %d sec****\n" , test_time / time_reduce);

		    while(read_le_event_get()) {
                
                MSLEEP(10);
                
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            // the ideal value : 30(s) / 30(ms) = 1000
            if (((float)((adv_cnt * 100) / (1000/time_reduce))) <= 50) {
                LOG_INFO("[Pattern][%s]FAIL, Counter : %d\n", __FUNCTION__, adv_cnt);
        		LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1000/time_reduce);
        		LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
        		LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / 1000/time_reduce));
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1000/time_reduce);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / 1000/time_reduce));
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.2.1.3
verdict DDI_ADV_Advertising_Data_Non_Connectable(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 line;
	int verdict = FAIL;
	int dut1 = 0;
	int repeat = 0;
	int i = 0;
	int data1_cnt, data2_cnt, data3_cnt, data4_cnt;
	struct itimerval timer;	
	u16 adv_cnt1 = 0;
	u16 adv_cnt2 = 0;	
    u16 time_reduce = 3;
    u16 test_time   = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
        
    Calculate_Execution_Time_Start();       

REPEAT:

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
	adv_cnt1 = 0;
	adv_cnt2 = 0;
	repeat++;
	
	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
	
    //The timing range detected for advertising events(ADV_NONCONN_IND) is from 100.0 ms to 110.0 ms
	//interval : 160(0x00a0) * 0.625ms = 100ms
    if (1 == repeat) {
		COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
		g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
	    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
	    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
	    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
		g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x01;
		g_pattern_param.adv_data_param.Advertising_Data[0] = 0x01;
		verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
		VERDICT_RESULT_WITH_LINE();
	}
	else if(2 == repeat) {
		COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
		g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
	    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
	    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
	    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
		g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x1f;
		g_pattern_param.adv_data_param.Advertising_Data[0] = 0x1f;
		for(i = 1; i < 31; i++) {
			g_pattern_param.adv_data_param.Advertising_Data[i] = 0x00;
		}
		verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
		VERDICT_RESULT_WITH_LINE();
	}
	else {
		printf("[Pattern][%s]FAIL : ERROR Repeat = %d\n", __FUNCTION__, repeat);
		line = __LINE__;
		goto FUN_FAIL;
	}

	while(1)//waiting adv report event , timer or counter
	{
		read_le_event_enable();
        event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
		event_query_timer_start(timer ,read_le_event_disable);

        printf("****wait for %d sec****\n" , test_time / time_reduce);

		while (read_le_event_get()){

            MSLEEP(50);
            
			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {
				continue;				 
			}
			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param)) {
				continue;
			}
			else {
				adv_cnt1++ ;
				printf("** Data_1 : check advertising intervals : %d time **\n" , adv_cnt1);					
			}			  
		}
		if(1 == repeat) {
			data1_cnt = adv_cnt1;
		}
		else {
			data3_cnt = adv_cnt1;
		}
        dut_reset_with_mask_en(dut1_fd);
        dut_reset_with_mask_en(dut2_fd);

		break;		  
	}

    sleep(5);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
	
	//second round
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;    
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
	COMM_ADV_NonConnectable_Advertising_Config(0,&g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	g_pattern_param.adv_data_param.Advertising_Data[0] = 0x00;
	verdict=COMM_ADV_NonConnectable_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    //waiting adv report event , timer or counter
	while(1) {
		read_le_event_enable();
		event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
		event_query_timer_start(timer, read_le_event_disable);
        
        printf("****wait for %d sec****\n" , test_time / time_reduce);

		while(read_le_event_get()) {									
            MSLEEP(50);

			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {
				continue;
			}
			if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND,	buf, g_pattern_param)) {
				continue;
			}
			else {
				adv_cnt2++ ;
				printf("** Data_2 : check advertising intervals : %d time **\n" , adv_cnt2);					
			}			  
		} 
        dut_reset_with_mask_en(dut1_fd);
        dut_reset_with_mask_en(dut2_fd);

		if(1 == repeat) {
			data2_cnt = adv_cnt2;
		}
		else {
			data4_cnt = adv_cnt2;
		}
		break;

	}
	
	if(repeat != 2)	{
		printf("[Pattern][%s]REPEAT\n", __FUNCTION__);
		goto REPEAT;
	}
	else {
        if ((((float)((data1_cnt * 100) / (272/time_reduce))) <= 50) || (((float)((data2_cnt * 100) / (272/time_reduce))) <= 50) ||
             (((float)((data3_cnt * 100) / (272/time_reduce))) <= 50) || (((float)((data4_cnt * 100) / (272/time_reduce))) <= 50)) {

            line = __LINE__;
			goto FUN_FAIL;
        }
        else {			

            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
		    LOG_INFO("Ideal Value : %d\n", 272/time_reduce);
    		LOG_INFO("Data1(0x01) : %d, Ratio : %.2f %%\n", data1_cnt, (float)((data1_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data2_cnt, (float)((data2_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x1f) : %d, Ratio : %.2f %%\n", data3_cnt, (float)((data3_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data4_cnt, (float)((data4_cnt * 100) / (272/time_reduce)));  
            return PASS;
        }		
	}
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__, line);
    LOG_INFO("Ideal Value : %d\n", 272);
    LOG_INFO("Data1(0x01) : %d, Ratio : %.2f %%\n", data1_cnt, (float)((data1_cnt * 100) / 272));
    LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data2_cnt, (float)((data2_cnt * 100) / 272));
    LOG_INFO("Data1(0x1f) : %d, Ratio : %.2f %%\n", data3_cnt, (float)((data3_cnt * 100) / 272));
    LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data4_cnt, (float)((data4_cnt * 100) / 272));

    return FAIL;
}


// 5.2.1.4
verdict DDI_ADV_Advertising_Data_Undirected(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 line;
	int verdict = FAIL;
	int dut1 = 0;
	int repeat = 0;
	int i = 0;
	int data1_cnt, data2_cnt, data3_cnt, data4_cnt;
	struct itimerval timer;	
	u16 adv_cnt1 = 0;
	u16 adv_cnt2 = 0;
    u16 time_reduce = 3;
    u16 test_time = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

REPEAT:

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();    

	adv_cnt1 = 0;
	adv_cnt2 = 0;
	repeat++;

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = ((HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce) & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   ((HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce) & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    //The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
	//interval : 32(0x0020) * 0.625ms = 20ms
	if (1 == repeat) {
		COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
		g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
		g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
		g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
		g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
		g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x01;
		g_pattern_param.adv_data_param.Advertising_Data[0]      = 0x01;
		verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
		VERDICT_RESULT_WITH_LINE();
	}
	else if(2 == repeat) {
		COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
		g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
		g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
		g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
		g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
		g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x1f;
		for(i = 1; i < 31; i++) {
			g_pattern_param.adv_data_param.Advertising_Data[i]  = 0x00;
		}
		g_pattern_param.adv_data_param.Advertising_Data[0]      = 0x01f;
		verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
		VERDICT_RESULT_WITH_LINE();
	}
	else {
		printf("[Pattern][%s]FAIL : ERROR Repeat\n", __FUNCTION__);
		line = __LINE__;
		goto FUN_FAIL;
	}

	//waiting adv report event , timer or counter
	while(1) {
		read_le_event_enable();
		event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
		event_query_timer_start(timer, read_le_event_disable);
        printf("****wait for %d sec****\n" , test_time / time_reduce);

		while (read_le_event_get()){							

            MSLEEP(10);

			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
				continue;
				
				
			}			 
			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
				continue;
			}
			else {
				adv_cnt1++ ;
				printf("** Data_1 : check advertising intervals : %d time **\n", adv_cnt1);
			}
			 
	    } 
        dut_reset_with_mask_en(dut1_fd);
        dut_reset_with_mask_en(dut2_fd);

		if(1 == repeat) {
			data1_cnt = adv_cnt1;
		}
		else {
			data3_cnt = adv_cnt1;
		}
		break;
	}


    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();        

//second round
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  (HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce) & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = ((HCI_CMD_PARAM_SCAN_INT_MAX/time_reduce) & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 (HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce) & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   ((HCI_CMD_PARAM_SCAN_WIN_MAX/time_reduce) & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0]   = 0x00;	 
	g_pattern_param.adv_data_param.Advertising_Data[0]          = 0x00;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    //waiting adv report event , timer or counter
	while(1) {
		read_le_event_enable();
		event_query_timer_config(test_time / time_reduce, 0, 0, 0, &timer);
		event_query_timer_start(timer, read_le_event_disable);
        printf("****wait for %d sec****\n" , test_time / time_reduce);

		while(read_le_event_get()){

            MSLEEP(10);

			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
				continue;				 
			}
			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
				continue;
			}
			else {
				adv_cnt2++ ;
				printf("** Data_2 : check advertising intervals : %d time **\n", adv_cnt2);					
			}			  
	    }
        dut_reset_with_mask_en(dut1_fd);
        dut_reset_with_mask_en(dut2_fd);

		if(1 == repeat) {
			data2_cnt = adv_cnt2;
		}
		else {
			data4_cnt = adv_cnt2;
		}
		break;	 
	}
	
	if(repeat != 2) {
		printf("[Pattern][%s]REPEAT\n", __FUNCTION__);
		goto REPEAT;
	}
	else {		
        if ((((float)((data1_cnt * 100) / (1000/time_reduce))) <= 50) || (((float)((data2_cnt * 100) / (1000/time_reduce))) <= 50) ||
             (((float)((data3_cnt * 100) / (1000/time_reduce))) <= 50) || (((float)((data4_cnt * 100) / (1000/time_reduce))) <= 50)) {
            line = __LINE__;
			goto FUN_FAIL;
        }
        else {			

            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
		    LOG_INFO("Ideal Value : %d\n", 1000/time_reduce);
    		LOG_INFO("Data1(0x01) : %d, Ratio : %.2f %%\n", data1_cnt, (float)((data1_cnt * 100) / (1000/time_reduce)));
            LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data2_cnt, (float)((data2_cnt * 100) / (1000/time_reduce)));
            LOG_INFO("Data1(0x1f) : %d, Ratio : %.2f %%\n", data3_cnt, (float)((data3_cnt * 100) / (1000/time_reduce)));
            LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data4_cnt, (float)((data4_cnt * 100) / (1000/time_reduce)));  
            return PASS;
        }
	}
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);

    LOG_INFO("Ideal Value : %d\n", 1000/time_reduce);
    LOG_INFO("Data1(0x01) : %d, Ratio : %.2f %%\n", data1_cnt, (float)((data1_cnt * 100) / (1000/time_reduce)));
    LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data2_cnt, (float)((data2_cnt * 100) / (1000/time_reduce)));
    LOG_INFO("Data1(0x1f) : %d, Ratio : %.2f %%\n", data3_cnt, (float)((data3_cnt * 100) / (1000/time_reduce)));
    LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data4_cnt, (float)((data4_cnt * 100) / (1000/time_reduce)));

    return FAIL;

}


// 5.2.1.5
verdict DDI_ADV_Scan_Request_Undirected_Connectable(u8 dut1_fd ,u8 dut2_fd)
{  
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int line;
    struct itimerval timer;
    int query_time = 15;

    u32 ch = 36; // default
    u32 adv_cnt_37 = 0;
    u32 adv_cnt_38 = 0;
    u32 adv_cnt_39 = 0;

    u32 scn_rsp_37 = 0;
    u32 scn_rsp_38 = 0;
    u32 scn_rsp_39 = 0;   

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();    

LOOP1: //case 1 ,policy = 0 , scn_rsp len =0 ;
    ch ++ ;
    
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data(using device name length of 0 as response data).  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x00A0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x00A0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x00A0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x00A0 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(31, &g_pattern_param);    
    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }        
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
        
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 
                MSLEEP(10);
               
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf, g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP1\n");
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 1 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP1\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    
                    
                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);


            if(ch != 39){
                goto LOOP1;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ) {
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP2: //case 2 ,policy = 1 , scn_rsp len =0 ;
    ch ++ ;
    
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd, 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;    
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from White List, Allow Connect Request from Any (0x01)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);    
    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }        
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP2\n");
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 2 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP2\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    
                   
                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);
                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);


            if(ch != 39){
                goto LOOP2;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
               (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP3: //policy = 0 , scan data = 31
    ch ++ ;

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd, 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP3\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 3 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);
                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP3\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);

            if(ch != 39){
                goto LOOP3;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
    
LOOP4: //policy = 1 , scan data = 31
    ch ++ ;

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd, 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);    
    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
   
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP4\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 4 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP4\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    
                    
                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);
                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);


            if(ch != 39){
                goto LOOP4;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }    

            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
        
LOOP5: //policy = 0 , dev_addr =diff comp id ,scan data = 0     
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP5\n");
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 5 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);
                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP5\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);


            if(ch != 39){
                goto LOOP5;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }


    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
            
LOOP6: //policy = 1 , dev_addr =diff comp id ,scan data = 0   
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;    
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    //waiting adv report event , timer or counter  
    while(1) {
        if(1 == read_le_event_get()) {
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP6\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 6 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP6\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);

            if(ch != 39){
                goto LOOP6;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   


            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP7: //policy = 0 , dev_addr =diff comp id ,scan data = 31     
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP7\n");
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 7 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);
                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP7\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);


            if(ch != 39){
                goto LOOP7;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }


    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
            
LOOP8: //policy = 1 , dev_addr =diff comp id ,scan data = 31   
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;    
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    //waiting adv report event , timer or counter  
    while(1) {
        if(1 == read_le_event_get()) {
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP8\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 8 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP8\n");
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);

            if(ch != 39){
                goto LOOP8;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   


            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP9: //policy = 0 , dev_addr =diff both id ,scan data = 0     
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP9\n");
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 9 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);
                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP9\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);


            if(ch != 39){
                goto LOOP9;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }


    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
            
LOOP10: //policy = 1 , dev_addr =both id ,scan data = 0   
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;    
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    //waiting adv report event , timer or counter  
    while(1) {
        if(1 == read_le_event_get()) {

            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP10\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 10 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP10\n");
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);

            if(ch != 39){
                goto LOOP10;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   


            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP11: //policy = 0 , dev_addr =both id ,scan data = 31     
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {

            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP11\n");
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 11 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);
                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP11\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);


            if(ch != 39){
                goto LOOP11;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }


    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
            
LOOP12: //policy = 1 , dev_addr =both id ,scan data = 31   
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;    
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Undirected_Advertising_Config(0, &g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }    
    else if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }    
    else if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    //waiting adv report event , timer or counter  
    while(1) {
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf,g_pattern_param)) {
                    printf("****parsing ADV non EQUAL**** LOOP12\n");
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 12 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****parsing SCN non EQUAL**** LOOP12\n");
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****parsing SCN EQUAL**** %d %d %d %d\n" , ch ,scn_rsp_37 ,scn_rsp_38 ,scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);

            if(ch != 39){
                goto LOOP12;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || 
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   


            break;
        }
    }

    FUNC_END();
    
    // the ideal value : 30(s) / 30(ms) = 1000
    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);    
    LOG_INFO("adv cnt 37 =%d \n" , adv_cnt_37);
    LOG_INFO("adv cnt 38 =%d \n" , adv_cnt_38);
    LOG_INFO("adv cnt 39 =%d \n" , adv_cnt_39);
    LOG_INFO("scn rsp 37 =%d \n" , scn_rsp_37);
    LOG_INFO("scn rsp 38 =%d \n" , scn_rsp_38);
    LOG_INFO("scn rsp 39 =%d \n" , scn_rsp_39);
    return PASS;
    
FUN_FAIL:
    FUNC_END();
    
    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("adv cnt 37 =%d \n" , adv_cnt_37);
    LOG_INFO("adv cnt 38 =%d \n" , adv_cnt_38);
    LOG_INFO("adv cnt 39 =%d \n" , adv_cnt_39);
    LOG_INFO("scn rsp 37 =%d \n" , scn_rsp_37);
    LOG_INFO("scn rsp 38 =%d \n" , scn_rsp_38);
    LOG_INFO("scn rsp 39 =%d \n" , scn_rsp_39);
    return FAIL;
}

// 5.2.1.6
verdict DDI_ADV_Connection_Request(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;	
	u32 adv_cnt = 1;
    u32 check_cnt = 0;
    u32 err_cnt = 0;
    int adv_Channel = 37;
	struct itimerval timer;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
    Calculate_Execution_Time_Start();    
    LOOP1: 
    /****************************************************************************  
        case 1,
        INI:
            Address : scan_addr
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
        ADV:
            adv_policy = 0x00(HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY),

        Result : Expect the IUT stop advertising.
    *****************************************************************************/    
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************            
    // Lwtest(Init) config    
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************            
    // IUT(ADV) config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    
    
    sleep(1);
    CHECK_CONNECT();    
     
	dut_reset_with_mask_en(dut1_fd);

    MSLEEP(500);

    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0200 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0200 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();                

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run Loop : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Lower Tester expects the IUT stop advertising : %d / 20 times **\n" , check_cnt);
        }
        
        MSLEEP(500);
    }

    dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);
	
	printf("** CH : %d, Lower Tester expects IUT don't advertise : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt   = 0;
		err_cnt     = 0;
        goto LOOP1;
    }
    else {
        adv_cnt++;
        check_cnt   = 0;
		err_cnt     = 0;
		adv_Channel = 37; // default
    }   

    /****************************************************************************  
        case 2,
        INI:
            Address : dut1_error_com_ass
            Type    : HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
        ADV:
            adv_policy = 0x00(HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY),

        Result : Expect the IUT stop advertising.
    *****************************************************************************/
    LOOP2: 
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************            
    // Lwtest(Init) config
    COMM_Static_Random_Device_Address_Set_Config(dut1_error_com_ass);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************            
    // IUT(ADV) config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
    memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    

    sleep(1);
    CHECK_CONNECT();   
     
    dut_reset_with_mask_en(dut1_fd);	
    MSLEEP(500);
	
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0200 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0200 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();                

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Lower Tester expects the IUT stop advertising : %d / 20 times **\n" , check_cnt);
         }
        MSLEEP(500);
    }
	
	dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);
	
	printf("** CH : %d, Lower Tester expects IUT continue advertise : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt   = 0;
		err_cnt     = 0;
        goto LOOP2;
    }
    else {
        adv_cnt++;
        check_cnt   = 0;
		err_cnt     = 0;
		adv_Channel = 37; // default
    }

    /****************************************************************************  
        case 3,
        INI:
            Address : dut1_error_com_idf
            Type    : HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
        ADV:
            adv_policy = 0x00(HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY),

        Result : Expect the IUT stop advertising.
    *****************************************************************************/
    LOOP3: 
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************            
    // Lwtest(Init) config
    COMM_Static_Random_Device_Address_Set_Config(dut1_error_com_idf);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************            
    // IUT(ADV) config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
    memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();  
    
    sleep(1);
    CHECK_CONNECT();   
    
    dut_reset_with_mask_en(dut1_fd);	
    MSLEEP(500);
	
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0200 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0200 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();                

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Lower Tester expects the IUT stop advertising : %d / 20 times **\n" , check_cnt);
         }
        MSLEEP(500);
    }   

	dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);
	
	printf("** CH : %d, Lower Tester expects IUT continue advertise : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt   = 0;
		err_cnt     = 0;
        goto LOOP3;
    }
    else {
        adv_cnt++;
        check_cnt   = 0;
		err_cnt     = 0;
		adv_Channel = 37; // default
    }

    /****************************************************************************  
        case 4,
        INI:
            Address : dut1_error_both
            Type    : HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
        ADV:
            adv_policy = 0x00(HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY),

        Result : Expect the IUT stop advertising.
    *****************************************************************************/
    LOOP4: 
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************            
    // Lwtest(Init) config
    COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************            
    // IUT(ADV) config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
    memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    

    sleep(1);
    CHECK_CONNECT();

    dut_reset_with_mask_en(dut1_fd);
    MSLEEP(500);
    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0200 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0200 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();                

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Lower Tester expects the IUT stop advertising : %d / 20 times **\n" , check_cnt);
         }
        MSLEEP(500);
    }   

	dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);
	
	printf("** CH : %d, Lower Tester expects IUT continue advertise : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt   = 0;
		err_cnt     = 0;
        goto LOOP4;
    }
    else {
        adv_cnt++;
        check_cnt   = 0;
		err_cnt     = 0;
		adv_Channel = 37; // default
    }

    /****************************************************************************  
        case 5,
        INI:
            Address : scan_addr
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
        ADV:
            adv_policy = 0x01(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY),

        Result : Expect the IUT stop advertising.
    *****************************************************************************/
    LOOP5: 
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************            
    // Lwtest(Init) config
    //COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    //COMM_Device_Address_Set(dut1_fd, g_pattern_param);
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************            
    // IUT(ADV) config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
    memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    

    sleep(1);
    CHECK_CONNECT();   
    
    dut_reset_with_mask_en(dut1_fd);
    MSLEEP(500);
    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0200 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0200 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;    
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();                

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Lower Tester expects the IUT stop advertising : %d / 20 times **\n" , check_cnt);
         }
        MSLEEP(500);
    }   

	dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);
	
	printf("** CH : %d, Lower Tester expects IUT continue advertise : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt   = 0;
		err_cnt     = 0;
        goto LOOP5;
    }
    else {
        adv_cnt++;
        check_cnt   = 0;
		err_cnt     = 0;
		adv_Channel = 37; // default
    }

    /****************************************************************************  
        case 6,
        INI:
            Address : dut1_error_com_ass
            Type    : HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
        ADV:
            adv_policy = 0x01(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY),

        Result : Expect the IUT stop advertising.
    *****************************************************************************/
    LOOP6: 
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************            
    // Lwtest(Init) config
    COMM_Static_Random_Device_Address_Set_Config(dut1_error_com_ass);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************            
    // IUT(ADV) config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
    memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    

    sleep(1);
    CHECK_CONNECT();   
    
    dut_reset_with_mask_en(dut1_fd);
    MSLEEP(500);
    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0200 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0200 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();                

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Lower Tester expects the IUT stop advertising : %d / 20 times **\n" , check_cnt);
         }
        MSLEEP(500);
    }

	dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);
	
	printf("** CH : %d, Lower Tester expects IUT continue advertise : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt   = 0;
		err_cnt     = 0;
        goto LOOP6;
    }
    else {
        adv_cnt++;
        check_cnt   = 0;
		err_cnt     = 0;
		adv_Channel = 37; // default
    }
    
    /****************************************************************************  
        case 7,
        INI:
            Address : dut1_error_com_ass
            Type    : HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
        ADV:
            adv_policy = 0x01(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY),

        Result : Expect the IUT stop advertising.
    *****************************************************************************/
    LOOP7: 
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************            
    // Lwtest(Init) config
    COMM_Static_Random_Device_Address_Set_Config(dut1_error_com_ass);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************            
    // IUT(ADV) config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
    memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    

    sleep(1);
    CHECK_CONNECT();
    
    dut_reset_with_mask_en(dut1_fd);
    MSLEEP(500);
    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0200 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0200 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;    
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();                

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Lower Tester expects the IUT stop advertising : %d / 20 times **\n" , check_cnt);
         }
        MSLEEP(500);
    }

    dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);
    
	printf("** CH : %d, Lower Tester expects IUT continue advertise : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt   = 0;
		err_cnt     = 0;
        goto LOOP7;
    }
    else {
        adv_cnt++;
        check_cnt   = 0;
		err_cnt     = 0;
		adv_Channel = 37; // default
    }

    /****************************************************************************  
        case 8,
        INI:
            Address : dut1_error_both
            Type    : HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
        ADV:
            adv_policy = 0x01(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY),

        Result : Expect the IUT stop advertising.
    *****************************************************************************/
    LOOP8: 
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************            
    // Lwtest(Init) config
    COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************            
    // IUT(ADV) config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
    memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    

    sleep(1);
    CHECK_CONNECT();   

    dut_reset_with_mask_en(dut1_fd);
    MSLEEP(500);
    
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0200 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0200 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0200 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();                

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Lower Tester expects the IUT stop advertising : %d / 20 times **\n" , check_cnt);
         }
        MSLEEP(500);
    }

	dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);
	
	printf("** CH : %d, Lower Tester expects IUT continue advertise : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt   = 0;
		err_cnt     = 0;
        goto LOOP8;
    }
    else {
        adv_cnt++;
        check_cnt   = 0;
		err_cnt     = 0;
		adv_Channel = 37; // default
    }    
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS;
        
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL, \n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.2.1.7
verdict DDI_ADV_Scan_Request_Connection_Request(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;
	u8 check_cnt = 0;
	u8 conn_handles_mas[2];
	int num = 0;
    int err_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT:

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
	
	// # set dut1 for scan
	// # p1:
	// # a.all adv channel
	// # b.min adv interval
	// # c.filter policy to 0
	COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0500 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	// # set dut2 for adv
	// # p2:
	// # a.adv report
	// # b.scan rsp
	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    if(num == 0){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
	}
	else if(num == 1){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
	}
	else if(num == 2){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	}
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;	
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();	

	event_query_timer_config(1, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {

			read_le_event_disable();
			// # query adv_ind
			// # p3 : monitor adv report
			// # p4 : monitor scan rsp
			// # p5 : check for 30 times
            while (check_cnt < 30) {
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    printf("****SUCCESS != QUERY_LE_Event****\n");
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                     err_cnt++;
                     if (err_cnt > 100) {
                         line=__LINE__;
                        goto FUN_FAIL;
                     }
                }        
                else {
                     check_cnt ++ ;
                     err_cnt = 0;                     
                     printf("** 1.Upper Tester expects an RSP event from the IUT : %d / 30 times **\n" , check_cnt);
                 }
                MSLEEP(300);
            }
				 

			// # stop scn before reconfig adv
			COMM_SCN_Disable_Config(dut1, &g_pattern_param);
			verdict = COMM_SCN_Disable(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			// # start creat connection
			COMM_INI_Initiating_Config(dut1, &g_pattern_param);
			verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1);

			// # p6 : check conn complete with CONN_REQ 
			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
			    line = __LINE__;
			    goto FUN_FAIL;
		    }
		    else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
			    line = __LINE__;
			    goto FUN_FAIL;
		    }

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
			    line = __LINE__;
			    goto FUN_FAIL;
		    }
		    else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
			    line = __LINE__;
			    goto FUN_FAIL;
		    }

            // # p7 : check no adv ind
            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
				line = __LINE__;
				goto FUN_FAIL;
			}						  
			else if(EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND,	buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1, &g_pattern_param, buf);
			verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            sleep(5);

			// # p9 : check conn terminated
			if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


			dut_reset_with_mask_en(dut1_fd);
    		dut_reset_with_mask_en(dut2_fd);
            MSLEEP(500);

			num++;
			if(num <3){
				goto REPEAT;
			}
			else{
				break;
			}
		}
	}


    FUNC_END();

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
	return PASS;	
    
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
	return FAIL;

}

// 5.2.1.8
verdict DDI_ADV_Scan_Request_Device_Filtering(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
    int adv_Channel = 37;
	int verdict = FAIL;
	int dut1 = 0, dut2 = 0;
    int check_cnt = 0;
    u16 line = 0;	
	struct itimerval timer;
	u32 adv_cnt = 1;	
    int scn_rsp_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT:    
    check_cnt = 0;
	printf("###run case %d###\n", adv_cnt);
	switch (adv_cnt)
	{
		case 1:			
			/*// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public, addr error(black); 
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
			// Uptest(white list) config
			COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);            
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] = 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] = (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();*/
		break;

		case 2:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 3:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;
		
		case 4:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random, addr error(black); 
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 5:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random(error)
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 6:
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		//part E : filter policy = 0x01 ;	repeat case1~3=>7~9
		case 7:			
			/*// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public, addr error(black); 
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
			// Uptest(white list) config
			COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);            
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] = 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] = (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();*/

		break;

		case 8:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random(error)
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 9:
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;


		//part F : filter policy = 0x01 ; Lwtest :addr_type=random repeat case 1~3=10~12
		case 10:			
            // Uptest   : addr_type = public 
			// Lwtest   : addr_type = random, addr error(black); 
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
			// Uptest(white list) config
			COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);            
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

		break;

		case 11:
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random(error)
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
			// Uptest(white list) config
			COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            //COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
			//COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 12:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;


	}

	//uptest_part++;
	event_query_timer_config(2 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );


	while(adv_cnt <= 12)//waiting adv report event , timer or counter
	{
		if ( 1== read_le_event_get() )
		{
			//reset event flag
			read_le_event_disable();
CONT:
			//##################################################
     

			if ( 1 == (adv_cnt % 3) ){
                //because the TI SCN can't set public type and change the addr at the same time,
                //so we don't verify the behavior at case 1 & 7     
                if ((1 != adv_cnt) && (7 != adv_cnt)) {
                    while (check_cnt < 30) {
				        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                            //query scan_rsp
                            line = __LINE__;
					        goto FUN_FAIL;
				        }				    
				        else if(EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                            //there is no scan_rsp here ,so should not be equal
                            line = __LINE__;
					        goto FUN_FAIL;
				        }
                        else {
					        check_cnt ++ ;
                            printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
					        printf("** Low Test expects no response from the IUT : %d / 30 times **\n" , check_cnt);
				        }
                        MSLEEP(200);
                    }    
                }                				
			}
			else if ( 2 == (adv_cnt % 3)) {
                while (check_cnt < 30) {
				    //query scan_rsp
				    if (SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
					    line = __LINE__;
					    goto FUN_FAIL;
				    }				
				    else if(EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                        //there is no scan_rsp here ,so should not be equal
                        line = __LINE__;
					    goto FUN_FAIL;
				    }
                    else {
					    check_cnt ++ ;
                        printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
					    printf("** Low Test expects no response from the IUT : %d / 30 times **\n" , check_cnt);
				    }
                    MSLEEP(200);
                }
			}
			else {                
		        //query scan_rsp
				if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
				    line = __LINE__;
				    goto FUN_FAIL;
		        }				
				else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    //expects a scan_rsp packet from thr IUT
                    if (scn_rsp_cnt < 100){
                        printf("check scn rsp cnt %d \n" , scn_rsp_cnt);
                        scn_rsp_cnt ++;
                        MSLEEP(300);

                        goto CONT;
                    }else{
                        line = __LINE__;
    					goto FUN_FAIL;
                    }                    
		        }
                else {
				    check_cnt ++ ;
                    printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
					printf("** Low Test expects response from the IUT **\n");
				}
                MSLEEP(200);
			}
			//event add

			//because the TI SCN can't set public type and change the addr at the same time,
            //so we don't verify the behavior at case 1 & 7     
            if ((1 != adv_cnt) && (7 != adv_cnt)) {
                dut_reset_with_mask_en(dut1_fd);
                dut_reset_with_mask_en(dut2_fd);

                sleep(1);                
            }       
            
			if (37 == adv_Channel) {
                adv_Channel++;
            }
            else if(38 == adv_Channel) {
                adv_Channel++;
            }
            else {
                adv_Channel = 37;
                adv_cnt++;
            }
			goto REPEAT;
		}
	}

    FUNC_END();

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
	return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL %d \n" ,__FUNCTION__,line ,adv_cnt);
    return FAIL;

}

// 5.2.1.9
verdict DDI_ADV_Connection_Request_Device_Filtering(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int adv_Channel = 37;
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    int check_cnt = 0;
    u16 line = 0;   
    struct itimerval timer;
    u32 adv_cnt = 1;
    u32 err_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT:
    check_cnt = 0;
    printf("###run case %d###\n", adv_cnt);
    switch (adv_cnt)
    {
        case 1:         
          /*// Uptest   : addr_type = public 
            // Lwtest   : addr_type = public, addr error(black); 
            // IUT      : undirected advertising, filter policy = 0x03
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config            
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();*/
        break;
 
        case 2:         
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = random
            // IUT      : undirected advertising, filter policy = 0x03
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            //memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;
          case 3:         
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = public
            // IUT      : undirected advertising, filter policy = 0x03
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
            
            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
             
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            //memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;
        
        case 4:         
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = random, addr error(black); 
            // IUT      : undirected advertising, filter policy = 0x03
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;

        case 5:         
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = random(error)
            // IUT      : undirected advertising, filter policy = 0x03
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            //memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;

        case 6:
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = public
            // IUT      : undirected advertising, filter policy = 0x03
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
             
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;

        //part E : filter policy = 0x01 ;   repeat case1~3=>7~9
        case 7:         
            /*// Uptest   : addr_type = public 
            // Lwtest   : addr_type = public, addr error(black); 
            // IUT      : undirected advertising, filter policy = 0x02
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_ANY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();*/

        break;

        case 8:         
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = random(error)
            // IUT      : undirected advertising, filter policy = 0x02
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


        	// Lwtest(white list) config
        	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
        	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
        	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
        	VERDICT_RESULT_WITH_LINE();            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            //memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_ANY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;

        case 9:
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = public
            // IUT      : undirected advertising, filter policy = 0x02
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_ANY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;


        //part F : filter policy = 0x01 ; Lwtest :addr_type=random repeat case 1~3=10~12
        case 10:            
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = random, addr error(black); 
            // IUT      : undirected advertising, filter policy = 0x02
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_ANY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

        break;

        case 11:
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = random(error)
            // IUT      : undirected advertising, filter policy = 0x02
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            
            // ***********************************************************************************            
            // Lwtest(CON) config
            //COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            //COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            //memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_ANY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;

        case 12:            
            // Uptest   : addr_type = public 
            // Lwtest   : addr_type = public
            // IUT      : undirected advertising, filter policy = 0x02
            // ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // Lwtest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(CON) config
            COMM_INI_Initiating_Config(dut1, &g_pattern_param);
            memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
            g_pattern_param.create_conn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;

            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            memcpy(g_pattern_param.adv_param.Direct_Address, adv_addr, ADDR_LENGTH);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_ANY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        break;


    }

    //uptest_part++;
    event_query_timer_config(2 , 0 , 0 , 0, &timer);
    event_query_timer_start(timer ,read_le_event_enable );


    while(adv_cnt <= 12)//waiting adv report event , timer or counter
    {
        if ( 1== read_le_event_get() )
        {
            //reset event flag
            read_le_event_disable();               

            if ( 1 == (adv_cnt % 3) ){
                //because the TI SCN can't set public type and change the Addr at the same time,
                //so we don't verify the behavior at case 1 & 7 
                if ((1 != adv_cnt) && (7 != adv_cnt)) {
                    //dut_reset_with_mask_en(dut1_fd);					
                    COMM_SCN_Disable_Config(dut1, &g_pattern_param);
                    COMM_SCN_Disable(dut1_fd, g_pattern_param);

                    MSLEEP(500);

                    // # for check ADV_IND after Master send CONN_REQ
                    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
                    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
                    g_pattern_param.scn_param.LE_Scan_Interval[0] = 0x0500 & 0x00ff;
                    g_pattern_param.scn_param.LE_Scan_Interval[1] =(0x0500 & 0xff00) >> 8;
                    g_pattern_param.scn_param.LE_Scan_Window[0] =   0x0500 & 0x00ff;
                    g_pattern_param.scn_param.LE_Scan_Window[1] =  (0x0500 & 0xff00) >> 8;
                    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
                    VERDICT_RESULT_WITH_LINE();
                    
                    while (check_cnt < 30) {
                        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                            //query ADV report
                            printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
                            printf("****SUCCESS != QUERY_LE_Event****\n");                        
                            continue;
    			        }				    
                       else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
                            // Expect the IUT to continue advertising                        
                            printf("****EQUAL != HCI : %d****\n", err_cnt);
                            printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
                            err_cnt++;
                            if (200 <= err_cnt) {
                                line=__LINE__;
    				            goto FUN_FAIL;
                            }    				        
                       }                        
                       else {                        
                            err_cnt = 0;
                            check_cnt ++ ;
                            printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
                            printf("** Low Test expects the IUT to continue advertising : %d / 30 times **\n" , check_cnt);
                        }
                       MSLEEP(100);
                    }
                }                               
            }
            else if ( 2 == (adv_cnt % 3)) {                
                //dut_reset_with_mask_en(dut1_fd);
                COMM_SCN_Disable_Config(dut1, &g_pattern_param);
                COMM_SCN_Disable(dut1_fd, g_pattern_param);

                MSLEEP(500);

                // # for check ADV_IND after Master send CONN_REQ                
                COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
                g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
                g_pattern_param.scn_param.LE_Scan_Interval[0] = 0x0500 & 0x00ff;
                g_pattern_param.scn_param.LE_Scan_Interval[1] =(0x0500 & 0xff00) >> 8;
                g_pattern_param.scn_param.LE_Scan_Window[0] =   0x0500 & 0x00ff;
                g_pattern_param.scn_param.LE_Scan_Window[1] =  (0x0500 & 0xff00) >> 8;
                verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
                VERDICT_RESULT_WITH_LINE();
                while (check_cnt < 30) {
                    if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                        //query ADV report
                        printf("****SUCCESS != QUERY_LE_Event****\n");
                        printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
				        continue;
			        }				    
                   else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
                        // Expect the IUT to continue advertising                            
                        printf("****EQUAL != HCI : %d****\n", err_cnt);
                        printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
                        err_cnt++;
                        if (200 <= err_cnt) {
                            line=__LINE__;
				            goto FUN_FAIL;
                        }				        
                   }                        
                   else {
                        check_cnt ++ ;
                        err_cnt = 0;
                        printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
                        printf("** Low Test expects the IUT to continue advertising : %d / 30 times **\n" , check_cnt);
                    }
                   MSLEEP(100);
                }
            }
            else {
                // Upper Tester expects an HCI_LE_Connection_Complete event from the IUT including the parameters sent to the IUT
		        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				    line = __LINE__;
				    goto FUN_FAIL;
			    }
			    else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				    line = __LINE__;
				    goto FUN_FAIL;
			    }

                if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				    line = __LINE__;
				    goto FUN_FAIL;
			    }
			    else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				    line = __LINE__;
				    goto FUN_FAIL;
			    }
                
		        //dut_reset_with_mask_en(dut1_fd);				
                COMM_SCN_Disable_Config(dut1, &g_pattern_param);
                COMM_SCN_Disable(dut1_fd, g_pattern_param);

                MSLEEP(500);

                // # for check ADV_IND after Master send CONN_REQ                
                COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
                g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
                g_pattern_param.scn_param.LE_Scan_Interval[0] = 0x0500 & 0x00ff;
                g_pattern_param.scn_param.LE_Scan_Interval[1] =(0x0500 & 0xff00) >> 8;
                g_pattern_param.scn_param.LE_Scan_Window[0] =   0x0500 & 0x00ff;
                g_pattern_param.scn_param.LE_Scan_Window[1] =  (0x0500 & 0xff00) >> 8;
                verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
                VERDICT_RESULT_WITH_LINE();                

                while (check_cnt < 30) {
                   if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                        //query ADV report
                        printf("****SUCCESS != QUERY_LE_Event****\n");
				        continue;
			       }				    
                   else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
                        // Expect the IUT to continue advertising                        
                        printf("****EQUAL != HCI : %d****\n", err_cnt);
                        printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
                        err_cnt++;
                        if (50 <= err_cnt) {
                            line=__LINE__;
				            goto FUN_FAIL;
                        }                        
                   }                        
                   else {
                        check_cnt ++ ;
                        err_cnt = 0;
                        printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
                        printf("** Lower Tester expects the IUT to stop advertising : %d / 30 times **\n" , check_cnt);
                    }
                   MSLEEP(100);
                }                          
            }
            //event add
            if (37 == adv_Channel) {
                adv_Channel++;
            }
            else if(38 == adv_Channel) {
                adv_Channel++;
            }
            else {
                adv_Channel = 37;
                adv_cnt++;
            }
            //##################################################
            dut_reset_with_mask_en(dut1_fd);
			dut_reset_with_mask_en(dut2_fd);
            MSLEEP(500);
            goto REPEAT;
        }
    }

    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL %d\n" ,__FUNCTION__, line , adv_cnt);
	return FAIL;
}

// 5.2.1.10
verdict DDI_ADV_Directed_Advertising_Events(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;		
	int try_num = 0;
    int err_cnt = 0;
	int adv_TimeCnt = 0;
    int adv_Channel = 37;
	struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();    

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);	
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);	
	verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
            
	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;     
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	//the interval of Man/Min must use 0x0500 instead of HCI_CMD_PARAM_SCAN_INT_MAX 
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x01E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x01E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =    0x01E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x01E0 & 0xff00) >> 8;    
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
Case1:  
    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
   	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	if(adv_Channel == 37){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
	}
	else if(adv_Channel == 38){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
	}
	else if(adv_Channel == 39){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	}
	//the interval of Man/Min must use 0x00a0 instead of HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN 
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();		


    while (try_num < 300) {
        // # restart the ADV_DIRECT
		if(adv_TimeCnt > 100) {
			adv_TimeCnt = 0;
            COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
		}        
        
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf, g_pattern_param)) {
             
             printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, try_num);             
             err_cnt++;
             if (err_cnt > 900) {
                line=__LINE__;
	            goto FUN_FAIL;
             }                 
        }                        
        else {
             try_num ++ ;
             err_cnt = 0;
             printf("** Upper Tester expects an HCI_LE_Advertising_Report event from the IUT : %d / 300 times **\n" , try_num);
        }
        
		adv_TimeCnt++;
        MSLEEP(1);
    }
   
    sleep(5);
    
	if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
		line = __LINE__;
		goto FUN_FAIL;
	}

	if(_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto FUN_FAIL;
	}
    else{

        if ( 0 != memcmp (g_pattern_param.adv_param.Direct_Address , 
             buf + _BT_HCI_EVT_CON_COMP_PEER_ADDR0 ,
             ADDR_LENGTH)){

            line = __LINE__;
            goto FUN_FAIL;

        }
    }
    

    if(adv_Channel != 39){        
        adv_Channel ++;		
        try_num = 0;
        err_cnt = 0;
        goto Case1;
    }
    else {
        adv_Channel= 37;
        try_num = 0;
        err_cnt = 0;
    }

    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);

    MSLEEP(500);

Case2:

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);	
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);	
	verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;     
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	//the interval of Man/Min must use 0x0500 instead of HCI_CMD_PARAM_SCAN_INT_MAX 
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x01E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x01E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =    0x01E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x01E0 & 0xff00) >> 8;    
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8; 
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);    
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1,&g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(3, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

 
    while(1)//waiting adv report event , timer or counter
	{
		if(1 == read_le_event_get())
		{
            read_le_event_disable();
            
			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			else if(EQUAL == hci_le_event_advertising_report_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}			

            if(adv_Channel != 39){        
                adv_Channel ++;             

                dut_reset_with_mask_en(dut1_fd);
                dut_reset_with_mask_en(dut2_fd);

                MSLEEP(500);
                goto Case2;
            }else{
                break;
            }
		}
	}

    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;
    
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL, ADV_Channel = %d\n" ,__FUNCTION__, line, adv_Channel);	
	return FAIL;

}

// 5.2.1.11
verdict DDI_ADV_Discoverable_Advertising_Events(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut1=0;
	int ret;
	int line=0;
	int ch_num=0;
	u32 adv_cnt=0;
    u16 adv_chk_err = 0;
	struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
    Calculate_Execution_Time_Start();

REPEAT:

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	//p1: set dut1 for scan
	COMM_SCN_Passive_Scanning_Config(dut1,&g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x01E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x01E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x01E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x01E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict=COMM_SCN_Passive_Scanning(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	//p2: set dut2 for adv
	COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = 0x03;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;

	if(ch_num == 0){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
	}
	else if(ch_num == 1){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
	}
	else if(ch_num == 2){
		g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	}
	//g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
	verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


	// # timer for 2 sec
	event_query_timer_config(0 , 100 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );
	//read_le_event_enable();
	

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{

			//read_le_event_disable();

			//p3, p4, p5
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_,
										HCI_CMD_PARAM_ADV_SCAN_IND))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			ret=hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_SCAN_IND,buf,g_pattern_param);
			
			if (EQUAL == ret)
			{
				adv_cnt++;
                adv_chk_err = 0;
				//p6: until a number advertising intervals (100) have been detected.
				if (100 == adv_cnt) //after 100 scan_interval stop?
				{
                    printf("receive 100 adv , change channel\n");
                    
                    dut_reset_with_mask_en(dut1_fd);
                    dut_reset_with_mask_en(dut2_fd);

    				adv_cnt=0;
    				read_le_event_disable();

					ch_num ++;
					if(ch_num <3){
						goto REPEAT;
					}
					else{
						break;
					}

				}
			}
            else{
                printf("no adv coming, chk %d\n" , adv_chk_err);

                adv_chk_err ++ ;
                if(adv_chk_err == 100){
                    line = __LINE__;
                    goto FUN_FAIL;
                }
            }
            MSLEEP(20);
            
		}
	}

    FUNC_END();

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
	return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.2.1.12
verdict DDI_ADV_Advertising_Data_Discoverable(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 line;
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;	
	int repeat = 0;
	int i = 0;
	int data1_cnt, data2_cnt, data3_cnt, data4_cnt;
	struct itimerval timer;	
	u16 adv_cnt1 = 0;
	u16 adv_cnt2 = 0;
    u16 time_reduce = 3;
    u16 test_time = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();    

REPEAT:
	adv_cnt1 = 0;
	adv_cnt2 = 0;
	repeat++;

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x1E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x1E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x1E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x1E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    //The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
	//interval : 32(0x0020) * 0.625ms = 20ms
	if (1 == repeat) {
		COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
		g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
		g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
		g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
		g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
		g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x01;
		g_pattern_param.adv_data_param.Advertising_Data[0] = 0x01;
		verdict = COMM_ADV_Discoverable_Advertising(dut2_fd, g_pattern_param);
		VERDICT_RESULT_WITH_LINE();
	}
	else if(2 == repeat) {
		COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
		g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
		g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
		g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
		g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
		g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x1f;
		for(i = 1; i < 31; i++) {
			g_pattern_param.adv_data_param.Advertising_Data[i] = 0x00;
		}
		g_pattern_param.adv_data_param.Advertising_Data[0] = 0x01f;
		verdict = COMM_ADV_Discoverable_Advertising(dut2_fd, g_pattern_param);
		VERDICT_RESULT_WITH_LINE();
	}
	else {
		printf("[Pattern][%s]FAIL : ERROR Repeat\n", __FUNCTION__);
		line = __LINE__;
		goto FUN_FAIL;
	}

	//waiting adv report event , timer or counter
	while(1) {
		read_le_event_enable();
		event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
		event_query_timer_start(timer, read_le_event_disable);

		while (read_le_event_get()){							

            MSLEEP(50);

			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND)) {
				continue;								
			}			 
			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_SCAN_IND, buf, g_pattern_param)) {
				continue;
			}
			else {
				adv_cnt1++ ;
				printf("** Data_1 : check advertising intervals : %d time **\n", adv_cnt1);
			}
	    }
        
        COMM_SCN_Disable_Config(dut1, &g_pattern_param);
		verdict = COMM_SCN_Disable(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
		COMM_ADV_Disable_Config(dut2, &g_pattern_param);
		verdict = COMM_ADV_Disable(dut2_fd, g_pattern_param);
		//VERDICT_RESULT_WITH_LINE();
        
		if(1 == repeat) {
			data1_cnt = adv_cnt1;
		}
		else {
			data3_cnt = adv_cnt1;
		}
        
		break;
	}
	
//second round
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x1E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x1E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x1E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x1E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Discoverable_Advertising_Config(0, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;	 
	g_pattern_param.adv_data_param.Advertising_Data[0] = 0x00;
	verdict = COMM_ADV_Discoverable_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    //waiting adv report event , timer or counter
	while(1) {
		read_le_event_enable();
		event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
		event_query_timer_start(timer, read_le_event_disable);

		while(read_le_event_get()){

            MSLEEP(50);

			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND)) {
				continue;				 
			}
			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_SCAN_IND, buf, g_pattern_param)) {
				continue;
			}
			else {
				adv_cnt2++ ;
				printf("** Data_2 : check advertising intervals : %d time **\n", adv_cnt2);					
			}			  
	    }
        
        COMM_SCN_Disable_Config(dut1, &g_pattern_param);
		verdict = COMM_SCN_Disable(dut1_fd, g_pattern_param);
        //VERDICT_RESULT_WITH_LINE();
        
		COMM_ADV_Disable_Config(dut2, &g_pattern_param);
		verdict = COMM_ADV_Disable(dut2_fd, g_pattern_param);
		//VERDICT_RESULT_WITH_LINE();
        sleep(1);
		if(1 == repeat) {
			data2_cnt = adv_cnt2;
		}
		else {
			data4_cnt = adv_cnt2;
		}
		break;	 
	}
	
	if(repeat != 2) {
		printf("[Pattern][%s]REPEAT\n", __FUNCTION__);
		goto REPEAT;
	}
	else {		
        if ((((float)((data1_cnt * 100) / (272/time_reduce))) <= 50) || (((float)((data2_cnt * 100) / (272/time_reduce))) <= 50) ||
             (((float)((data3_cnt * 100) / (272/time_reduce))) <= 50) || (((float)((data4_cnt * 100) / (272/time_reduce))) <= 50)) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
    		LOG_INFO("Ideal Value : %d\n", 272/time_reduce);
    		LOG_INFO("Data1(0x01) : %d, Ratio : %.2f %%\n", data1_cnt, (float)((data1_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data2_cnt, (float)((data2_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x1f) : %d, Ratio : %.2f %%\n", data3_cnt, (float)((data3_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data4_cnt, (float)((data4_cnt * 100) / (272/time_reduce)));
            line = __LINE__;
			goto FUN_FAIL;
        }
        else {			

            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
		    LOG_INFO("Ideal Value : %d\n", 272/time_reduce);
    		LOG_INFO("Data1(0x01) : %d, Ratio : %.2f %%\n", data1_cnt, (float)((data1_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data2_cnt, (float)((data2_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x1f) : %d, Ratio : %.2f %%\n", data3_cnt, (float)((data3_cnt * 100) / (272/time_reduce)));
            LOG_INFO("Data1(0x00) : %d, Ratio : %.2f %%\n", data4_cnt, (float)((data4_cnt * 100) / (272/time_reduce)));  
            return PASS;
        }
	}
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.2.1.13
verdict DDI_ADV_Scan_Request_Discoverable(u8 dut1_fd ,u8 dut2_fd)
{  
    u8 buf[SOCKET_BUF_SIZE];
    int verdict=FAIL;
    int dut1=0;
    int line;
    struct itimerval timer;
    int query_time = 15;

    u32 ch = 36; // default
    u32 adv_cnt_37 = 0;
    u32 adv_cnt_38 = 0;
    u32 adv_cnt_39 = 0;

    u32 scn_rsp_37 = 0;
    u32 scn_rsp_38 = 0;
    u32 scn_rsp_39 = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
LOOP1: //case 1 ,policy = 0
    ch ++ ;

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 3, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0160 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(31,&g_pattern_param);


    if (ch == 37){
    	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
    	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
    	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
        
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {

            event_query_timer_config(query_time, 0, 0, 0, &timer);
    		event_query_timer_start(timer, read_le_event_disable);
            
    		while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 
                MSLEEP(10);
               
    			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
    			{				
    				    				
    				continue;
    			} 
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
    			{
    				
    				continue;
    			}
    			else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 1 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

			    }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 1 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);


                }
 
		    }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);

            sleep(1);

            if(ch != 39){
                goto LOOP1;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

    		break;
		}
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP2: //case 2 ,policy = 1
    ch ++ ;
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 3, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

            MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {
                                        
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                     

                    printf("****LOOP 2 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 2 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP2;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
               (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP3: //policy = 0 , scan data = 31
    ch ++ ;
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 3 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 3 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP3;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
    
LOOP4: //policy = 1 , scan data = 31
    ch ++ ;
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    
    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }

                    printf("****LOOP 4 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);
                    
                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 4 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP4;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }    

            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
        
LOOP5: //policy = 0 , dev_addr =diff comp id ,scan data = 0		
    ch ++ ;

	COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 5 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 5 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP5;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }


    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
            
LOOP6: //policy = 1 , dev_addr =diff comp id ,scan data = 0   
    ch ++ ;

	COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    
    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 6 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 6 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP6;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   


            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP7: //policy = 0 , dev_addr =diff comp id ,scan data = 0   
    ch ++ ;

	COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 7 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 7 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }
            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP7;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }


    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP8: //policy = 1 , dev_addr =diff comp id ,scan data = 0   
    ch ++ ;

	COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    
    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 8 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 8 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);
                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP8;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }    

            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
        
LOOP9: //policy = 0 , dev_addr =diff both id ,scan data = 0     
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 9 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 9 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP9;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }


    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;
            
LOOP10: //policy = 1 , dev_addr =diff both id ,scan data = 0   
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 0, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    
    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 10 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 10 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP10;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   


            break;
        }
    }

    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP11: //policy = 0 , dev_addr =both comp id ,scan data = 31   
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
    COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {
                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 11 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 11 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);

                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP11;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
               (scn_rsp_37 < 30) || (scn_rsp_38 < 30) || (scn_rsp_39 < 30) ){
                line = __LINE__;
                goto FUN_FAIL;
            }   

            break;
        }
    }


    ch = 36; // default
    adv_cnt_37 = 0;
    adv_cnt_38 = 0;
    adv_cnt_39 = 0;

    scn_rsp_37 = 0;
    scn_rsp_38 = 0;
    scn_rsp_39 = 0;

LOOP12: //policy = 1 , dev_addr =diff both id ,scan data = 31   
    ch ++ ;

    COMM_Static_Random_Device_Address_Set_Config(dut1_error_both);
    COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    
    // # p1 : Upper Tester sends an HCI_LE_Set_Scan_Response_Data.  
    COMM_Scan_Response_Data_Set_Config(dut2_fd , 31, &g_pattern_param);
    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // # p2 : Configure Lower Tester to monitor the advertising and scan response packets of the IUT    
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0x0160  & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0160  & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    
    verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # p3 : Upper Tester enables discoverable undirected advertising in the IUT using all 
    // supported advertising channels, minimum advertising intervals and filtering policy 
    //set to Allow Scan Request from Any, Allow Connect Request from Any (Default) (0x00)'. 
    COMM_ADV_Discoverable_Advertising_Config(0,&g_pattern_param);

    if (ch == 37){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    if (ch == 38){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }

    if (ch == 39){
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    printf("****timer for 30sec****\n" );
    
    while(1) {//waiting adv report event , timer or counter  
        if(1 == read_le_event_get()) {
        // start the scanning time :30 sec
            event_query_timer_config(query_time, 0, 0, 0, &timer);
            event_query_timer_start(timer, read_le_event_disable);
            
            while(read_le_event_get()) {
                // # p4 :Lower Tester sends a SCAN_REQ packet on the selected advertising channel 
                //after receiving an ADV_DISCOVER_IND packet from IUT on the advertising 
                //channel configured in Step 3. The SCAN_REQ is sent T_IFS after the end of an 
                //ADV_IND packet. 

                MSLEEP(10);
                
                if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND))
                {               
                    
                    
                    continue;
                } 
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf,g_pattern_param))
                {
                    
                    continue;
                }
                else {

                    if (ch == 37){
                        adv_cnt_37++; 
                    }
                    
                    if (ch == 38){
                        adv_cnt_38++; 
                    }
                    
                    if (ch == 39){
                        adv_cnt_39++; 
                    }                    

                    printf("****LOOP 12 adv ch %d | adv cnt %d %d %d ****\n" ,ch , adv_cnt_37 , adv_cnt_38 , adv_cnt_39);

                }

                // # p5 : Lower Tester expects a SCAN_RSP packet from the IUT T_IFS after the end of the SCAN_REQ packet.  
                if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                    continue;
                    
                    
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    
                    if (ch == 37){
                        scn_rsp_37++; 
                    }
                    
                    if (ch == 38){
                        scn_rsp_38++; 
                    }
                    
                    if (ch == 39){
                        scn_rsp_39++; 
                    }                    

                    printf("****LOOP 12 adv ch %d | scn cnt %d %d %d ****\n" ,ch , scn_rsp_37 , scn_rsp_38 , scn_rsp_39);
                }
 
            }

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            sleep(1);


            if(ch != 39){
                goto LOOP12;
            }

            // # p6 Repeat steps 4-5 30 times. 
            if((adv_cnt_37 < 30) || (adv_cnt_38 < 30) || (adv_cnt_39 < 30) || \
                (scn_rsp_37 > 0) || (scn_rsp_38 > 0) || (scn_rsp_39 > 0) ){
                line = __LINE__;
                goto FUN_FAIL;
            }    

            break;
        }
    }



    // ========
    // # finish
    FUNC_END();


    // the ideal value : 30(s) / 30(ms) = 1000
    LOG_INFO("[Pattern][%s]SUCCESS\n" , __FUNCTION__);    
    LOG_INFO("adv cnt 37 =%d \n" , adv_cnt_37);
    LOG_INFO("adv cnt 38 =%d \n" , adv_cnt_38);
    LOG_INFO("adv cnt 39 =%d \n" , adv_cnt_39);
    LOG_INFO("scn rsp 37 =%d \n" , scn_rsp_37);
    LOG_INFO("scn rsp 38 =%d \n" , scn_rsp_38);
    LOG_INFO("scn rsp 39 =%d \n" , scn_rsp_39);
    return PASS;
    
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]FAIL :%d\n" ,__FUNCTION__ , line);
    LOG_INFO("adv cnt 37 =%d \n" , adv_cnt_37);
    LOG_INFO("adv cnt 38 =%d \n" , adv_cnt_38);
    LOG_INFO("adv cnt 39 =%d \n" , adv_cnt_39);
    LOG_INFO("scn rsp 37 =%d \n" , scn_rsp_37);
    LOG_INFO("scn rsp 38 =%d \n" , scn_rsp_38);
    LOG_INFO("scn rsp 39 =%d \n" , scn_rsp_39);
    return FAIL;
}

// 5.2.1.14
verdict DDI_ADV_Device_Filtering_Discoverable(u8 dut1_fd ,u8 dut2_fd)
{        
	u8 buf[SOCKET_BUF_SIZE];
    int adv_Channel = 37;
	int verdict = FAIL;
	int dut1 = 0, dut2 = 0;
    int check_cnt = 0;
    int err_cnt = 0;
    u16 line = 0;	
	struct itimerval timer;
	u32 adv_cnt = 1;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT:
    check_cnt = 0;
	LOG_INFO("###run case %d###\n", adv_cnt);

    //# ignore case 1 and 7
    if((adv_cnt == 1) || (adv_cnt == 7)){
        adv_cnt ++;
    }
    
	switch (adv_cnt)
	{
		case 1:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public, addr error(black); 
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
			// Uptest(white list) config
			COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
			
			COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);            
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] = 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] =(0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =  (0x0500 & 0xff00) >> 8;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);            
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 2:			

			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

		break;

		case 3:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;     
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;
		
		case 4:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random, addr error(black); 
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 5:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random(error)
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 6:
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public
			// IUT      : undirected advertising, filter policy = 0x03
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] = 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] = (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		//part E : filter policy = 0x01 ;	repeat case1~3=>7~9
		case 7:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public, addr error(black); 
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
			// Uptest(white list) config
			COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
			
			COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);            
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] = 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] = (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 8:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random(error)
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 9:
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;


		//part F : filter policy = 0x01 ; Lwtest :addr_type=random repeat case 1~3=10~12
		case 10:			
            // Uptest   : addr_type = public 
			// Lwtest   : addr_type = random, addr error(black); 
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
			// Uptest(white list) config
			COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
			COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_Static_Random_Device_Address_Set_Config(error_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);            
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

		break;

		case 11:
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = random(error)
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
			// Uptest(white list) config
			COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
			COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            //COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
			//COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);  
            COMM_Static_Random_Device_Address_Set_Config(scan_addr);
			COMM_Device_Address_Set(dut1_fd, g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;

		case 12:			
			// Uptest   : addr_type = public 
			// Lwtest   : addr_type = public
			// IUT      : undirected advertising, filter policy = 0x01
			// ***********************************************************************************
            // Uptest(white list) config
            COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
			memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
            g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
			verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // Lwtest(SCN) config
            COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
            g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;             
            g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
            g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x0500 & 0xff00) >> 8;
	        g_pattern_param.scn_param.LE_Scan_Window[0] =	 0x0500 & 0x00ff;
	        g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x0500 & 0xff00) >> 8;
			verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);            
			VERDICT_RESULT_WITH_LINE();
            
            // ***********************************************************************************            
            // IUT(ADV) config
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            if(37 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            }
            else if(38 == adv_Channel) {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
            }
            else {
                g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
            }
			g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
		break;


	}

	//uptest_part++;
	event_query_timer_config(2 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );


	while(adv_cnt <= 12)//waiting adv report event , timer or counter
	{
		if ( 1== read_le_event_get() )
		{
			//reset event flag
			read_le_event_disable();

			//##################################################


            
			if ( 1 == (adv_cnt % 3) ){
                //because the TI SCN can't set public type and change the addr at the same time,
                //so we don't verify the behavior at case 1 & 7 
                    while (check_cnt < 30) {
    				    if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                            //query scan_rsp
                            line = __LINE__;
    					    goto FUN_FAIL;
    				    }				    
    				    else if(EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                            //there is no scan_rsp here ,so should not be equal
                            line = __LINE__;
    					    goto FUN_FAIL;
    				    }
                        else {
    					    check_cnt ++ ;
                            printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
    					    printf("** Low Test expects no response from the IUT : %d / 30 times **\n" , check_cnt);
    				    }
                        MSLEEP(200);
                    }
			}
			else if ( 2 == (adv_cnt % 3)) {
                    while (check_cnt < 30) {
                
				    //query scan_rsp
				    if (SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
					    line = __LINE__;
					    goto FUN_FAIL;
				    }				
				    else if(EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                        //there is no scan_rsp here ,so should not be equal
                        line = __LINE__;
					    goto FUN_FAIL;
				    }
                    else {
					    check_cnt ++ ;
                        printf("###run case : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
					    printf("** Low Test expects no response from the IUT : %d / 30 times **\n" , check_cnt);
				    }
                    MSLEEP(200);
                    }
			}
			else {                
		        //query scan_rsp
                while (check_cnt == 0) {
                    if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                        //query ADV report
                        printf("****SUCCESS != QUERY_LE_Event****\n");
            	        continue;
            	    }				    
                    else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                         
                         printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                         err_cnt++;
                         if (err_cnt > 50) {
                             line=__LINE__;
            	             goto FUN_FAIL;
                         }             
                    }                        
                    else {
                         check_cnt ++ ;
                         err_cnt = 0;
                         printf("###ADV_Channel = %d ###\n", adv_Channel);
                         printf("** Upper Tester expects an RSP event from the IUT **\n" );
                    }
                    MSLEEP(300);  
                }                
				                
			}

			// # ignored case 1 and case 7
            if ((1 != adv_cnt) && (7 != adv_cnt)) {
                //stop adv
    			COMM_ADV_Disable_Config(dut2, &g_pattern_param);
    			verdict = COMM_ADV_Disable(dut2_fd, g_pattern_param);
    			//VERDICT_RESULT_WITH_LINE();

    			//stop scn
    			COMM_SCN_Disable_Config(dut1, &g_pattern_param);
    			verdict = COMM_SCN_Disable(dut1_fd, g_pattern_param);
    			VERDICT_RESULT_WITH_LINE();
            }


			//event add
			if (37 == adv_Channel) {
                adv_Channel++;
                check_cnt = 0;
            }
            else if(38 == adv_Channel) {
                adv_Channel++;
                check_cnt = 0;
            }
            else {
                adv_Channel = 37;
                check_cnt = 0;
                adv_cnt++;
            }

            COMM_Dut_clean_buffer(dut1_fd);
            COMM_Dut_clean_buffer(dut2_fd);

			goto REPEAT;
		}
	}

    FUNC_END();

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
	return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;
}

// 5.2.2.1
verdict DDI_SCN_Passive_Scanning_Non_Connectable(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
    int err_cnt = 0;	
    int check_cnt = 0;
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
    int adv_Channel = 37;	
	struct itimerval timer;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
	//p2
	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  0xa0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0xa0 & 0xff00) >> 8;   
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

REPEAT:	
    
	//p1
	COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	COMM_ADV_NonConnectable_Advertising_Reconfig(&g_pattern_param);
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 10;

    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;         
    }
    else if(38 == adv_Channel) {
        COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_idf);
		COMM_Device_Address_Set(dut2_fd, g_pattern_param);
		memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_idf, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
        g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;        
    }
    else {
        COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_ass);
		COMM_Device_Address_Set(dut2_fd, g_pattern_param);
		memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_ass, ADDR_LENGTH);
		g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
        g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
        
    }
	verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
	
    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param)) {
             
             printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
             err_cnt++;
             if (err_cnt > 50) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###ADV_Channel = %d ###\n", adv_Channel);
             printf("** Upper Tester expects an HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
        }
        MSLEEP(300);
    }

	//stop adv
	COMM_ADV_Disable_Config(dut2, &g_pattern_param);
	verdict = COMM_ADV_Disable(dut2_fd, g_pattern_param);
	//VERDICT_RESULT_WITH_LINE();

    MSLEEP(100);
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt = 0;
		err_cnt = 0;
        goto REPEAT;
    }    

    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS;

FUN_FAIL:	

    FUNC_END(); 
	LOG_INFO("[Pattern][%s]:%d FAIL, ADV_Channel = %d\n" ,__FUNCTION__, line, adv_Channel);
    return FAIL;

}

// 5.2.2.2
verdict DDI_SCN_Passive_Scanning_Device_Filtering(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    u8 adv_cnt = 1;
    int err_cnt = 0;    
    int check_cnt = 0;
    int verdict = FAIL;
    int dut1 = 0;
	int dut2 = 0;
    u16 line = 0;    
    int adv_Channel = 37;    
	struct itimerval timer;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
LOOP1: 
    /****************************************************************************  
        case 1,
        SCN(IUT):            
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
            scn_policy = 0x01(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY),
        ADV(Low_T):
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
            Address : adv_addr
        Result : Upper Tester expects an HCI_LE_Advertising_Report event from the IUT.
    *****************************************************************************/    
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************    
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =   0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8; 
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************    
    COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);    
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }    
    g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    
    MSLEEP(500);


    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run Loop : %d ; ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Upper Tester expects an HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
        }
        MSLEEP(500);
    }

    COMM_SCN_Disable_Config(dut1,&g_pattern_param);
    verdict = COMM_SCN_Disable(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    COMM_ADV_Disable_Config(dut2,&g_pattern_param);
    verdict = COMM_ADV_Disable(dut2_fd,g_pattern_param);
    //VERDICT_RESULT_WITH_LINE();

    MSLEEP(100);
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
	//printf("** CH : %d, Upper Tester expects an HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt = 0;
		err_cnt = 0;
        goto LOOP1;
    }
    else {
        adv_cnt++;
        check_cnt = 0;
		err_cnt = 0;
		adv_Channel = 37; // default
    }

LOOP2: 
    /****************************************************************************  
        case 2,
        SCN(IUT):            
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
            scn_policy = 0x01(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY),
        ADV(Low_T):
            Type    : HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
            Address : adv_addr
        Result : Upper Tester expects an HCI_LE_Advertising_Report event from the IUT.
    *****************************************************************************/    
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************    
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =   0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8; 
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************    
    COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    COMM_Static_Random_Device_Address_Set_Config(adv_addr);
	COMM_Device_Address_Set(dut2_fd, g_pattern_param);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }    
    g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    
    MSLEEP(500);

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run Loop : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
        }
        MSLEEP(500);
    }

    COMM_SCN_Disable_Config(dut1,&g_pattern_param);
    verdict = COMM_SCN_Disable(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    COMM_ADV_Disable_Config(dut2,&g_pattern_param);
    verdict = COMM_ADV_Disable(dut2_fd,g_pattern_param);
    //VERDICT_RESULT_WITH_LINE();

    MSLEEP(100);
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
	printf("** CH : %d, Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt = 0;
		err_cnt = 0;
        goto LOOP2;
    }
    else {
        adv_cnt++;
        check_cnt = 0;
		err_cnt = 0;
		adv_Channel = 37; // default
    }


LOOP3: 
    /****************************************************************************  
        case 3,
        SCN(IUT):            
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
            scn_policy = 0x01(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY),
        ADV(Low_T):
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
            Address : dut2_error_com_idf
        Result : Upper Tester expects an HCI_LE_Advertising_Report event from the IUT.
    *****************************************************************************/    
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************    
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =   0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8; 
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************    
    COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	COMM_ADV_NonConnectable_Advertising_Reconfig(&g_pattern_param);
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;	
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }    
    COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_idf);
	COMM_Device_Address_Set(dut2_fd, g_pattern_param);
	memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_idf, ADDR_LENGTH);   	
    g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;        
    verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    
    MSLEEP(500);


    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run Loop : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
         }
        MSLEEP(500);
    }

    COMM_SCN_Disable_Config(dut1,&g_pattern_param);
    verdict = COMM_SCN_Disable(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    COMM_ADV_Disable_Config(dut2,&g_pattern_param);
    verdict = COMM_ADV_Disable(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    MSLEEP(100);
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
	
	printf("** CH : %d, Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt = 0;
		err_cnt = 0;
        goto LOOP3;
    }
    else {
        adv_cnt++;
        check_cnt = 0;
		err_cnt = 0;
		adv_Channel = 37; // default
    }


LOOP4: 
    /****************************************************************************  
        case 4,
        SCN(IUT):            
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
            scn_policy = 0x01(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY),
        ADV(Low_T):
            Type    : HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
            Address : dut2_error_both
        Result : Upper Tester expects an HCI_LE_Advertising_Report event from the IUT.
    *****************************************************************************/    
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    // ***********************************************************************************    
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =   0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8; 
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
     
    // ***********************************************************************************    
    COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	COMM_ADV_NonConnectable_Advertising_Reconfig(&g_pattern_param);
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;	
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }    
    COMM_Static_Random_Device_Address_Set_Config(dut2_error_both);
	COMM_Device_Address_Set(dut2_fd, g_pattern_param);
	memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_both, ADDR_LENGTH);   	
    g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;        
    verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    
    MSLEEP(500);

    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param)) {
             // Expect the IUT stop advertising                        
             printf("****EQUAL != HCI : %d****\n", err_cnt);             
             err_cnt++;
             if (50 <= err_cnt) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }             
        }                        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###run Loop : %d   ADV_Channel = %d ###\n", adv_cnt, adv_Channel);
             printf("** Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
        }
        MSLEEP(500);
    }

    COMM_SCN_Disable_Config(dut1,&g_pattern_param);
    verdict = COMM_SCN_Disable(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    COMM_ADV_Disable_Config(dut2,&g_pattern_param);
    verdict = COMM_ADV_Disable(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    MSLEEP(100);
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
	printf("** CH : %d, Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , adv_Channel, check_cnt);
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt = 0;
		err_cnt = 0;
        goto LOOP4;
    }
    else {
        adv_cnt++;
        check_cnt = 0;
		err_cnt = 0;
		adv_Channel = 37; // default
    }
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS; 

FUN_FAIL:   
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL, ADV_Channel = %d\n" ,__FUNCTION__, line, adv_Channel);
    return FAIL;

}

// 5.2.2.3
verdict DDI_SCN_Active_Scanning(u8 dut1_fd ,u8 dut2_fd)
{

	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut1=0,dut2=0;
	u16 line =0 ;
	u32 adv_cnt=0;
	int adv_Channel = 37;
	int com_ID_cnt = 0;
    int adv_fail_cnt = 0 ;
    int scan_rsp_fail_cnt = 0 ;
	int i;
	struct itimerval timer;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0xa0 & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;
    
	verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

REPEAT:	
    printf("\n### ch %d |  com_ID %d | adv_cnt %d ###\n", adv_Channel , com_ID_cnt , adv_cnt);    

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
	}
	else if(38 == adv_Channel) {
	    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
	}
	else {
	    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
	}
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;

    // Lwtest(SCN) config
    // use the correct company identifier and company assigned identifier default.
    
     if(com_ID_cnt == 1){
         //with an identical company assigned identifier
         //but a different company identifier
         COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_idf);
         COMM_Device_Address_Set(dut2_fd, g_pattern_param);
         for(i=0; i<6; i++){
             g_pattern_param.adv_param.Direct_Address[i] = dut2_error_com_idf[i];
         }
         g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
         
     }
     else if(com_ID_cnt == 2){
         //with an identical company identifier
         //but a different company assigned identifier
         COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_ass);
         COMM_Device_Address_Set(dut2_fd, g_pattern_param);
         for(i=0; i<6; i++){
             g_pattern_param.adv_param.Direct_Address[i] = dut2_error_com_ass[i];
         }
         g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
         
     }
     else if(com_ID_cnt == 3){
         //with different company identifier 
         //and company assigned identifier
         COMM_Static_Random_Device_Address_Set_Config(dut2_error_both);
         COMM_Device_Address_Set(dut2_fd, g_pattern_param);
         for(i=0; i<6; i++){
             g_pattern_param.adv_param.Direct_Address[i] = dut2_error_both[i];
         }
         g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
     }

	verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	while(1)//waiting adv report event , timer or counter
	{
        printf("\n### ch %d |  com_ID %d | adv_cnt %d | adv_fail_cnt %d | scan_rsp_fail_cnt %d ###\n", 
            adv_Channel , com_ID_cnt , adv_cnt , adv_fail_cnt ,scan_rsp_fail_cnt);    
    
		//query adv_ind
		if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
									_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_,
									HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND))
		{
			line=__LINE__;
			goto FUN_FAIL;
		}
		else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND,
														buf,g_pattern_param))
		{
    		adv_fail_cnt ++ ;
            
            if (adv_fail_cnt < 300){
                MSLEEP(300);
    			continue;
            }else{            
                line = __LINE__;
                goto FUN_FAIL;
            }
            
		}
		else{
            adv_fail_cnt = 0;
            
			if(adv_cnt < 20){
				//stop adv
				COMM_ADV_Disable_Config(dut2,&g_pattern_param);
				verdict=COMM_ADV_Disable(dut2_fd,g_pattern_param);
				VERDICT_RESULT_WITH_LINE();

                MSLEEP(100);
                COMM_Dut_clean_buffer(dut1_fd);
                COMM_Dut_clean_buffer(dut2_fd);
				//reconfig adv param and start adv again
				g_pattern_param.adv_data_param.Advertising_Data[0]= adv_cnt;
				g_pattern_param.adv_data_param.Advertising_Data[1]= \
							g_pattern_param.adv_param.Advertising_Channel_Map[0];
				g_pattern_param.Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;
                
				verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
				VERDICT_RESULT_WITH_LINE();
                
				adv_cnt ++;
				continue;
			}
			else{
				adv_cnt = 0;
                //go next
			}
		}


REPEAT2: 

        printf("\n### ch %d |  com_ID %d | adv_cnt %d | adv_fail_cnt %d | scan_rsp_fail_cnt %d ###\n", 
            adv_Channel , com_ID_cnt , adv_cnt , adv_fail_cnt ,scan_rsp_fail_cnt);    

		//query scan_rsp
		if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
									_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_,
									HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP))
		{
			line=__LINE__;
			goto FUN_FAIL;
		}else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP,
														buf,g_pattern_param))
		{
    		scan_rsp_fail_cnt ++ ;
            if (scan_rsp_fail_cnt < 100){
                MSLEEP(300);
                goto REPEAT2;
    			//continue;
            }else{
                line = __LINE__;
                goto FUN_FAIL;
            }

		}
		else{
            
    		scan_rsp_fail_cnt = 0 ;
		}

        //verify different company ID per channel
        if(com_ID_cnt !=3){
            com_ID_cnt ++;
            adv_cnt = 0;
        
            //COMM_Reset(dut1_fd);
            COMM_ADV_Disable_Config(dut2,&g_pattern_param);
            verdict=COMM_ADV_Disable(dut2_fd,g_pattern_param);

            MSLEEP(100);
            COMM_Dut_clean_buffer(dut1_fd);
            COMM_Dut_clean_buffer(dut2_fd);
            
            VERDICT_RESULT_WITH_LINE();
            goto REPEAT;
        }
        else{
            if(adv_Channel != 39){
                com_ID_cnt=0;
                adv_Channel ++;
                adv_cnt = 0;
        
                //COMM_Reset(dut1_fd);
                COMM_ADV_Disable_Config(dut2,&g_pattern_param);
                verdict=COMM_ADV_Disable(dut2_fd,g_pattern_param);

                MSLEEP(100);
                COMM_Dut_clean_buffer(dut1_fd);
                COMM_Dut_clean_buffer(dut2_fd);
                
                VERDICT_RESULT_WITH_LINE();
                goto REPEAT;
            }
            else{                    
                FUNC_END();

                LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
                return PASS;
            }
        }


	}

FUN_FAIL:    
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL : ch %d \n" ,__FUNCTION__,line ,adv_Channel);
    return FAIL;

}

// 5.2.2.4
verdict DDI_SCN_Active_Scanning_Device_Filtering(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
    int err_cnt = 0;	
    int check_cnt = 0;
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
    int adv_Channel = 37;	
	struct itimerval timer;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    // Uptest(white list) config
    Calculate_Execution_Time_Start();
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	//p2
	COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  (0xa0)& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] =  (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    (0xa0)& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =    (0xa0 & 0xff00) >> 8; 
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

REPEAT:	
    // Uptest(white list) config
	//p1
	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);	
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;	
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;		
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;        
    }
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
	
    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                  , HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {                 
             printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
             err_cnt++;
             if (err_cnt > 50) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }                 
        }        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###ADV_Channel = %d ###\n", adv_Channel);
             printf("** 1.Upper Tester expects an HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
        }
        MSLEEP(300);
    }

    err_cnt = 0;
    check_cnt = 0;
    
    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                  , HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
        }            
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
            printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
             err_cnt++;
             if (err_cnt > 100) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }
        }        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###ADV_Channel = %d ###\n", adv_Channel);
             printf("** 1.Upper Tester expects an RSP event from the IUT : %d / 20 times **\n" , check_cnt);
        }
        MSLEEP(300);
    }

    // using a non white listed device address and a public address type. 
    // The device address has a different company assigned identifier and the same company identifier as IUT. 
    // Scan response is also configured in the Lower Tester

    /*COMM_Reset(dut1_fd);
    COMM_Reset(dut2_fd);

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	//p2
	COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	0xa0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8;	
	verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	//p1
	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_idf);
	COMM_Device_Address_Set(dut2_fd, g_pattern_param);
	memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_idf, ADDR_LENGTH);
    g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;	
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;		
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;        
    }
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
	
    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {                 
             printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
             err_cnt++;
             if (err_cnt > 50) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }                 
        }        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###ADV_Channel = %d ###\n", adv_Channel);
             printf("** 2.Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
         }
         usleep(200000);
    }

    err_cnt = 0;
    check_cnt = 0;
    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
        }            
        else if(EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
            printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
             err_cnt++;
             if (err_cnt > 50) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }
        }        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###ADV_Channel = %d ###\n", adv_Channel);
             printf("** 2.Upper Tester expects no RSP event from the IUT : %d / 20 times **\n" , check_cnt);
         }
         usleep(200000);
    }

    COMM_Reset(dut1_fd);
    COMM_Reset(dut2_fd);

    // using a non white listed device address and a public address type.
    // The device address has a different company assigned identifier and company identifier as IUT. 
    // Scan response is also configured in the Lower Tester
    
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	//p2
	COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	0xa0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8;	
	verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	//p1
	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    COMM_Static_Random_Device_Address_Set_Config(dut2_error_both);
	COMM_Device_Address_Set(dut2_fd, g_pattern_param);
	memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_both, ADDR_LENGTH);
    g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;	
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;		
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;        
    }
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
	
    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
            //query ADV report
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
	    }				    
        else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {                 
             printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
             err_cnt++;
             if (err_cnt > 50) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }                 
        }        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###ADV_Channel = %d ###\n", adv_Channel);
             printf("** 3.Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
         }
         usleep(200000);
    }

    err_cnt = 0;
    check_cnt = 0;
    while (check_cnt < 20) {
        if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
            printf("****SUCCESS != QUERY_LE_Event****\n");
	        continue;
        }            
        else if(EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
            printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
             err_cnt++;
             if (err_cnt > 50) {
                 line=__LINE__;
	            goto FUN_FAIL;
             }
        }        
        else {
             check_cnt ++ ;
             err_cnt = 0;
             printf("###ADV_Channel = %d ###\n", adv_Channel);
             printf("** 3.Upper Tester expects no RSP event from the IUT : %d / 20 times **\n" , check_cnt);
         }
         usleep(200000);
    }*/

	//COMM_Reset(dut1_fd);
    COMM_ADV_Disable_Config(dut2,&g_pattern_param);
    verdict = COMM_ADV_Disable(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt = 0;
		err_cnt = 0;
        goto REPEAT;
    }    
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS;

FUN_FAIL:	
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL, ADV_Channel = %d\n" ,__FUNCTION__, line, adv_Channel);
    return FAIL;
}

// 5.2.2.5
verdict DDI_SCN_Scanning_For_Advertiser_Types(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
    int err_cnt = 0;	
    int check_cnt = 0;
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
    int adv_Channel = 37;	
	struct itimerval timer;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
    Calculate_Execution_Time_Start();

    COMM_Static_Random_Device_Address_Set_Config(scan_addr);
    COMM_Device_Address_Set(dut1_fd, g_pattern_param);
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);   
    g_pattern_param.scn_param.Own_Address_Type[0]   =   HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =   0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8; 
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
REPEAT:
	    
	//p1
    if(37 == adv_Channel) {
        COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_ass);
		COMM_Device_Address_Set(dut2_fd, g_pattern_param);		
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
		memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_ass, ADDR_LENGTH);
    	g_pattern_param.adv_param.Own_Address_Type[0]	= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;    	
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;         
        verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(38 == adv_Channel) {
        COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_idf);
		COMM_Device_Address_Set(dut2_fd, g_pattern_param);		
        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
		memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_idf, ADDR_LENGTH);
    	g_pattern_param.adv_param.Own_Address_Type[0]	= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;    	
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;         
        verdict = COMM_ADV_Discoverable_Advertising(dut2_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
		COMM_Static_Random_Device_Address_Set_Config(dut2_error_both);
		COMM_Device_Address_Set(dut2_fd, g_pattern_param);		
        COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);	
		memcpy(g_pattern_param.adv_param.Direct_Address, scan_addr, ADDR_LENGTH);
		g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
		g_pattern_param.adv_param.Direct_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    	g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    	g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;	
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;		
		g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0;		        
        verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	    VERDICT_RESULT_WITH_LINE();        
    }		
	
    while (check_cnt < 20) {
        if (37 == adv_Channel) {
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_CMD_PARAM_ADV_NONCONN_IND)) {
                //query ADV report
                printf("****SUCCESS != QUERY_LE_Event****\n");
    	        continue;
    	    }				    
            else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param)) {             
                 printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                 err_cnt++;
                 if (err_cnt > 50) {
                     line=__LINE__;
    	            goto FUN_FAIL;
                 }             
            }                        
            else {
                 check_cnt ++ ;
                 err_cnt = 0;
                 printf("###ADV_Channel = %d ###\n", adv_Channel);
                 printf("** IUT expects an ADV_NONCONN_IND event from the Lower Tester : %d / 20 times **\n" , check_cnt);
            }
            MSLEEP(300);
        }
        else if (38 == adv_Channel) {
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_CMD_PARAM_ADV_SCAN_IND)) {
                //query ADV report
                printf("****SUCCESS != QUERY_LE_Event****\n");
    	        continue;
    	    }				    
            else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf, g_pattern_param)) {             
                printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                err_cnt++;
                if (err_cnt > 50) {
                    line=__LINE__;
    	           goto FUN_FAIL;
                }             
            }            
            else {
                 check_cnt ++ ;
                 err_cnt = 0;
                 printf("###ADV_Channel = %d ###\n", adv_Channel);
                 printf("** IUT expects an ADV_SCAN_IND event from the Lower Tester : %d / 20 times **\n" , check_cnt);
            }
            MSLEEP(300);
        }
        else {
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {
                //query ADV report
                printf("****SUCCESS != QUERY_LE_Event****\n");
    	        continue;
    	    }				    
            else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf, g_pattern_param)) {
                 
                 printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                 err_cnt++;

                 if (err_cnt == 100) {
                    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();  
                 }
                 
                 if (err_cnt > 200) {
                     line=__LINE__;
    	            goto FUN_FAIL;
                 }                 
            }                        
            else {
                 check_cnt ++ ;
                 err_cnt = 0;
                 printf("###ADV_Channel = %d ###\n", adv_Channel);
                 printf("** Upper Tester expects an HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
            }
            
            MSLEEP(10);
        }
    }
	//dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);
    MSLEEP(500);

	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt = 0;
		err_cnt = 0;
        goto REPEAT;
    }    
    
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS;

FUN_FAIL:	
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL, ADV_Channel = %d\n" ,__FUNCTION__, line, adv_Channel);
    return FAIL;

}

// 5.2.2.6
verdict DDI_SCN_Passive_Scanning_Undirected_Events(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict=FAIL;
    int dut1=0,dut2=0;
    u16 line =0 ;
    u32 adv_cnt=0;
    int adv_Channel = 37;
    int com_ID_cnt = 0;
    int i;
    u16 adv_chk_err = 0;
	struct itimerval timer;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    COMM_SCN_Passive_Scanning_Config(dut1,&g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] =   HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;
    
    verdict=COMM_SCN_Passive_Scanning(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

REPEAT: 
    printf("\n### ch %d |  com_ID %d | adv_cnt %d ###\n", adv_Channel , com_ID_cnt , adv_cnt);    

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;

    // Lwtest(SCN) config
    // use the correct company identifier and company assigned identifier default.
    
     if(com_ID_cnt == 1){
         //with an identical company assigned identifier
         //but a different company identifier
         COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_idf);
         COMM_Device_Address_Set(dut2_fd, g_pattern_param);
         for(i=0; i<6; i++){
             g_pattern_param.adv_param.Direct_Address[i] = dut2_error_com_idf[i];
         }
         g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
         
     }
     else if(com_ID_cnt == 2){
         //with an identical company identifier
         //but a different company assigned identifier
         COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_ass);
         COMM_Device_Address_Set(dut2_fd, g_pattern_param);
         for(i=0; i<6; i++){
             g_pattern_param.adv_param.Direct_Address[i] = dut2_error_com_ass[i];
         }
         g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
         
     }
     else if(com_ID_cnt == 3){
         //with different company identifier 
         //and company assigned identifier
         COMM_Static_Random_Device_Address_Set_Config(dut2_error_both);
         COMM_Device_Address_Set(dut2_fd, g_pattern_param);
         for(i=0; i<6; i++){
             g_pattern_param.adv_param.Direct_Address[i] = dut2_error_both[i];
         }
         g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;             
     }


    verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    while(1)//waiting adv report event , timer or counter
    {

        MSLEEP(100);

        //query adv_ind
        if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
                                    _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_,
                                    HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND))
        {
            continue;
        }
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND,
                                                        buf,g_pattern_param))
        {
            printf("no adv coming, chk %d\n" , adv_chk_err);
            
            adv_chk_err ++ ;
            if(adv_chk_err >= 100){
                line = __LINE__;
                goto FUN_FAIL;
            }
        
            continue;
        }
        else{
            adv_chk_err = 0;
            
            if(adv_cnt < 20){
                //stop adv
                
                COMM_ADV_Disable_Config(dut2,&g_pattern_param);
                verdict=COMM_ADV_Disable(dut2_fd,g_pattern_param);
                VERDICT_RESULT_WITH_LINE();

                //reconfig adv param and start adv again
                g_pattern_param.adv_data_param.Advertising_Data[0]= adv_cnt;
                g_pattern_param.adv_data_param.Advertising_Data[1]= \
                            g_pattern_param.adv_param.Advertising_Channel_Map[0];
                g_pattern_param.Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;
                verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
                VERDICT_RESULT_WITH_LINE();

                adv_cnt ++;

                continue;
            }
            else{
                adv_cnt = 0;
            }
        }

        if(com_ID_cnt !=3){
            com_ID_cnt ++;
        
            COMM_ADV_Disable_Config(dut2,&g_pattern_param);
            verdict=COMM_ADV_Disable(dut2_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        
            adv_cnt = 0;
            goto REPEAT;
        }
        else{
            if(adv_Channel != 39){
        
                COMM_ADV_Disable_Config(dut2,&g_pattern_param);
                verdict=COMM_ADV_Disable(dut2_fd,g_pattern_param);
                VERDICT_RESULT_WITH_LINE();
        
                adv_Channel ++;
                adv_cnt = 0;
                com_ID_cnt=0;
                goto REPEAT;
            }
            else{
                FUNC_END();               
                LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
                return PASS;
            }
        }

    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL : ch %d \n" ,__FUNCTION__,line ,adv_Channel);
    return FAIL;
}



// 5.2.2.7
verdict DDI_SCN_Passive_Scanning_Directed_Events(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
    int err_cnt = 0;	
    int check_cnt = 0;
	int adv_TimeCnt = 0;
	int verdict = FAIL;
	int dut1 = 0;	
	u16 line = 0;
    int adv_Channel = 37;	
	struct itimerval timer;	

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //p2
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =   0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8; 
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
REPEAT:	

	//p1
	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);	
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;	

    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
		//memcpy(g_pattern_param.adv_param.Direct_Address, error_scan_com_idf, ADDR_LENGTH);
    }
    else if(38 == adv_Channel) {
        COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_idf);
		COMM_Device_Address_Set(dut2_fd, g_pattern_param);
		memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_idf, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
        g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;        
    }
    else {
        COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_ass);
		COMM_Device_Address_Set(dut2_fd, g_pattern_param);
		memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_ass, ADDR_LENGTH);
		g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
        g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
        
    }

    sleep(1);

	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    while (check_cnt < 20) {
		if(adv_TimeCnt > 50) {
			adv_TimeCnt = 0;
			//verdict = 
            COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
		    //VERDICT_RESULT_WITH_LINE();
		}        

        
        if(37 == adv_Channel){
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {
                //query ADV report
                printf("****SUCCESS != QUERY_LE_Event****\n");
    	        continue;
    	    }				    
            else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf, g_pattern_param)) {
                 
                 printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                 err_cnt++;
                 if (err_cnt > 100) {
                     line=__LINE__;
    	            goto FUN_FAIL;
                 }                 
            }                        
            else {
                 check_cnt ++ ;
                 err_cnt = 0;
                 printf("###ADV_Channel = %d ###\n", adv_Channel);                 
                 printf("** Upper Tester expects an HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
             }
			adv_TimeCnt++;
            MSLEEP(60);
        }
        else { // for channel 38 & 39
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {
                //query ADV report
                printf("****SUCCESS != QUERY_LE_Event****\n");
    	        continue;
    	    }				    
            else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf, g_pattern_param)) {
                 
                 printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                 err_cnt++;
                 if (err_cnt > 50) {
                     line=__LINE__;
    	            goto FUN_FAIL;
                 }                 
            }                        
            else {
                 check_cnt ++ ;
                 err_cnt = 0;
                 printf("###ADV_Channel = %d ###\n", adv_Channel);
                 printf("** Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
            }
            MSLEEP(60);
			adv_TimeCnt++;
        }
    }

    //dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);      
    MSLEEP(500);

	if(adv_Channel != 39){        
        adv_Channel ++;
		check_cnt = 0;
		err_cnt = 0;
        goto REPEAT;
    }  
    
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS;

FUN_FAIL:	
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL, ADV_Channel = %d\n" ,__FUNCTION__, line, adv_Channel);
    return FAIL;

}


// 5.2.2.8
verdict DDI_SCN_Passive_Scanning_Discoverable_Events(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int err_cnt = 0;    
    int check_cnt = 0;
    int verdict = FAIL;
    int dut1 = 0;
	int dut2 = 0;
    u16 line = 0;
    int adv_Channel = 37;   
	struct itimerval timer;	
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT: 
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    //p2
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    g_pattern_param.scn_param.LE_Scan_Interval[0] = 0xa0& 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (0xa0 & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =   0xa0 & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] = (0xa0 & 0xff00) >> 8; 
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //p1
    COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param); 
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8; 
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
        //memcpy(g_pattern_param.adv_param.Direct_Address, error_scan_com_idf, ADDR_LENGTH);
    }
    else if(38 == adv_Channel) {
        COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_idf);
        COMM_Device_Address_Set(dut2_fd, g_pattern_param);
        memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_idf, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
        g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;        
    }
    else {
        COMM_Static_Random_Device_Address_Set_Config(dut2_error_com_ass);
        COMM_Device_Address_Set(dut2_fd, g_pattern_param);
        memcpy(g_pattern_param.adv_param.Direct_Address, dut2_error_com_ass, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
        g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
        
    }
    verdict = COMM_ADV_Discoverable_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    while (check_cnt < 20) {
        if(37 == adv_Channel){
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND)) {
                //query ADV report
                printf("****SUCCESS != QUERY_LE_Event****\n");
                continue;
            }                   
            else if (EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf, g_pattern_param)) {
                 
                 printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                 err_cnt++;
                 if (err_cnt > 50) {
                     line=__LINE__;
                    goto FUN_FAIL;
                 }                 
            }                        
            else {
                 check_cnt ++ ;
                 err_cnt = 0;
                 printf("###ADV_Channel = %d ###\n", adv_Channel);
                 printf("** Upper Tester expects an HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
            }
            MSLEEP(500);
        }
        else { // for channel 38 & 39
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND)) {
                //query ADV report
                printf("****SUCCESS != QUERY_LE_Event****\n");
                continue;
            }                   
            else if (EQUAL == hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf, g_pattern_param)) {
                 
                 printf("****EQUAL != HCI_err : %d, right_Cnt = %d ****\n", err_cnt, check_cnt);             
                 err_cnt++;
                 if (err_cnt > 50) {
                     line=__LINE__;
                    goto FUN_FAIL;
                 }                 
            }                        
            else {
                 check_cnt ++ ;
                 err_cnt = 0;
                 printf("###ADV_Channel = %d ###\n", adv_Channel);
                 printf("** Upper Tester expects no HCI_LE_Advertising_Report event from the IUT : %d / 20 times **\n" , check_cnt);
            }
            MSLEEP(500);
        }
    }

    COMM_SCN_Disable_Config(dut1,&g_pattern_param);
    verdict = COMM_SCN_Disable(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    COMM_ADV_Disable_Config(dut2,&g_pattern_param);
    verdict = COMM_ADV_Disable(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();    

    if(adv_Channel != 39){        
        adv_Channel ++;
        check_cnt = 0;
        err_cnt = 0;
        goto REPEAT;
    }    
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS;

FUN_FAIL:   
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL, ADV_Channel = %d\n" ,__FUNCTION__, line, adv_Channel);
    return FAIL;

}


// 5.3.1.1
verdict CON_ADV_Accepting_Connections(u8 dut1_fd ,u8 dut2_fd)
{
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;	
	struct itimerval timer;

	u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    // #p1 :low tester init connection
    //start creat connection to send conn_req
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] =HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;    
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // #p2 :use first channel = 37  
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);    
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8; 
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =   HCI_CMD_PARAM_ENABLE_CHANNEL_37;

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {
			//reset event flag
			read_le_event_disable();

            //# p4: check respond with CONN REQ
			if(SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

            //# p7: check respond with CONN REQ
			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
			verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            sleep(10);

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            MSLEEP(500);

            goto CASE_CH_38;
		}
	}

CASE_CH_38:
    // #p9/10/11

    // #p1 :low tester init connection
    //start creat connection to send conn_req
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // #p2 :use second channel = 38  
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);    
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8; 
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer ,read_le_event_enable );

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            //reset event flag
            read_le_event_disable();
            //# p4: check respond with CONN REQ
            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            

            //# p7: check respond with CONN REQ
			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}


			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];


			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1, &g_pattern_param, buf);
			verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            sleep(10);

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            MSLEEP(500);
            goto CASE_CH_39;            
        }
    }

CASE_CH_39:

    // #p12/13/14
    // #p1 :low tester init connection
    //start creat connection to send conn_req
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // #p2 :use third channel = 39  
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8; 
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            //reset event flag
            read_le_event_disable();

            //# p4: check respond with CONN REQ
            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            //# p7: check respond with CONN REQ
			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}


			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1, &g_pattern_param, buf);
			verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            goto FUN_SUCCESS;
            
        }
    }

FUN_SUCCESS:
    FUNC_END();

	LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
	return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;


}

// 5.3.1.2
verdict CON_ADV_Accepting_Connections_Timeout(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8; 
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] =HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;        
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	dut_reset_with_mask_en(dut1_fd);
    MSLEEP(500);
	event_query_timer_config(10, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {
            read_le_event_disable();

			if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			sleep(10);
            
			if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			hci_event_disconnection_complete_parsing(0, buf, g_pattern_param);
			/*if(_BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_FAILED_TO_BE_ESTABLISHED != buf[_BT_HCI_EVT_DISCONN_COMP_REASON])	{
				line = __LINE__;
				goto FUN_FAIL;
			}*/
                FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
	return FAIL;
}

// 5.3.1.4
verdict CON_ADV_Directed_Advertising_Connection(u8 dut1_fd ,u8 dut2_fd)
{    
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    int adv_Channel = 37;    
    struct itimerval timer;
    u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT:
    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //# case 1
	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    // #config mismatch init address
	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, error_addr, ADDR_LENGTH);
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            break;
        }
    }
    dut_reset_with_mask_en(dut1_fd);
    sleep(1);


    //# case 2
    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];
            
            break;
        }
    }

    sleep(30);    

    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }       
    if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    } 
    if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


    // # Slave Connection Terminated
    // use connect handle to disconnect
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
    
    COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    sleep(5);
    
    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);

    MSLEEP(500);

    if(adv_Channel != 39){        
        adv_Channel ++;		
        goto REPEAT;
    }
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return 0;
    
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL : ch %d \n" ,__FUNCTION__,line ,adv_Channel);
    return 0;
}

// 5.3.2.1
verdict CON_INI_Connection_Initiation(u8 dut1_fd ,u8 dut2_fd)
{
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;

	u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    // #p1 :low tester init connection
    //start creat connection to send conn_req
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] =HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	// Upper Tester sends an HCI_LE_Set_Random_Address command to set the IUT random address and
	// expects an HCI_Command_Complete event from the IUT with a Status of 0x0C.
	COMM_Random_Device_Address_Set_Config(dut1,&g_pattern_param);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // #p2 :use first channel = 37
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =   HCI_CMD_PARAM_ENABLE_CHANNEL_37;

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {
			//reset event flag
			read_le_event_disable();

            //# p4: check respond with CONN REQ
			if(SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

            //# p7: check respond with CONN REQ
			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

			COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
			verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            sleep(10);

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            MSLEEP(500);

            goto CASE_CH_38;
		}
	}

CASE_CH_38:
    // #p9/10/11

    // #p1 :low tester init connection
    //start creat connection to send conn_req
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	// Upper Tester sends an HCI_LE_Set_Random_Address command to set the IUT random address and
	// expects an HCI_Command_Complete event from the IUT with a Status of 0x0C.
	COMM_Random_Device_Address_Set_Config(dut1,&g_pattern_param);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // #p2 :use second channel = 38
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer ,read_le_event_enable );

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            //reset event flag
            read_le_event_disable();
            //# p4: check respond with CONN REQ
            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            //# p7: check respond with CONN REQ
			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}


			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];


			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

			COMM_Disconnect_Config(dut1, &g_pattern_param, buf);
			verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            sleep(10);

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);
            MSLEEP(500);
            goto CASE_CH_39;
        }
    }

CASE_CH_39:

    // #p12/13/14
    // #p1 :low tester init connection
    //start creat connection to send conn_req
    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	// Upper Tester sends an HCI_LE_Set_Random_Address command to set the IUT random address and
	// expects an HCI_Command_Complete event from the IUT with a Status of 0x0C.
	COMM_Random_Device_Address_Set_Config(dut1,&g_pattern_param);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // #p2 :use third channel = 39
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            //reset event flag
            read_le_event_disable();

            //# p4: check respond with CONN REQ
            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            //# p7: check respond with CONN REQ
			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}


			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

			COMM_Disconnect_Config(dut1, &g_pattern_param, buf);
			verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            goto FUN_SUCCESS;

        }
    }

FUN_SUCCESS:
    FUNC_END();

	LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
	return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;


}


// 5.3.2.2 (refer to 5.3.1.4)
verdict CON_INI_Connecting_to_Directed_Advertising(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    int adv_Channel = 37;
    struct itimerval timer;
    u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT:
    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //# case 1
	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    // #config mismatch init address
	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, error_addr, ADDR_LENGTH);
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            break;
        }
    }
    dut_reset_with_mask_en(dut1_fd);
    sleep(1);


    //# case 2
    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            break;
        }
    }

    sleep(600);

    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


    // # Slave Connection Terminated
    // use connect handle to disconnect
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

    COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(5);

    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);

    MSLEEP(500);

#if 0
    if(adv_Channel != 39){
        adv_Channel ++;
        goto REPEAT;
    }
#endif
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return 0;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL : ch %d \n" ,__FUNCTION__,line ,adv_Channel);
    return 0;
}

// 5.3.2.5 (refer to 5.3.2.2)
verdict CON_INI_Initiation_Device_Filtering_Undirected(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    int adv_Channel = 37;
    struct itimerval timer;
    u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT:
    //# case 1
    //incorrect address type, correct address

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, init_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_Static_Random_Device_Address_Set_Config(adv_addr);
	COMM_Device_Address_Set(dut2_fd,g_pattern_param);
	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Own_Address_Type[0]	    =	HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
	//g_pattern_param.adv_param.Direct_Address_Type[0]	=	HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	bt_hci_cmd_le_create_connection.parameter_tbl[2].value  =  g_pattern_param.create_conn_param.Initiator_Filter_Policy;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, zero_addr, ADDR_LENGTH);
    bt_hci_cmd_le_create_connection.parameter_tbl[4].value  = g_pattern_param.create_conn_param.Peer_Address;
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS == hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            break;
        }
    }
    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);
    sleep(6);


    //# case 2
    //Correct address type
    //Incorrect address

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, error_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, init_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	bt_hci_cmd_le_create_connection.parameter_tbl[2].value  =  g_pattern_param.create_conn_param.Initiator_Filter_Policy;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, zero_addr, ADDR_LENGTH);
    bt_hci_cmd_le_create_connection.parameter_tbl[4].value  = g_pattern_param.create_conn_param.Peer_Address;
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS == hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            break;
        }
    }
    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);
    sleep(6);


    //# case 3
    //Correct address type
    //Correct address

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, init_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	bt_hci_cmd_le_create_connection.parameter_tbl[2].value  =  g_pattern_param.create_conn_param.Initiator_Filter_Policy;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, zero_addr, ADDR_LENGTH);
    bt_hci_cmd_le_create_connection.parameter_tbl[4].value  = g_pattern_param.create_conn_param.Peer_Address;
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);
    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            break;
        }
    }

    sleep(6);

    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


    // # Slave Connection Terminated
    // use connect handle to disconnect
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

    COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(5);

    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);

    MSLEEP(500);

#if 0
    if(adv_Channel != 39){
        adv_Channel ++;
        goto REPEAT;
    }
#endif
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return 0;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL : ch %d \n" ,__FUNCTION__,line ,adv_Channel);
    return 0;
}

// 5.3.2.6 (refer to 5.3.2.2)
verdict CON_INI_Initiation_Device_Filtering_Directed(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    int adv_Channel = 37;
    struct itimerval timer;
    u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
REPEAT:
    //# case 1
    //incorrect address type, correct address

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, init_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_Static_Random_Device_Address_Set_Config(adv_addr);
	COMM_Device_Address_Set(dut2_fd,g_pattern_param);
	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Own_Address_Type[0]	    =	HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
	//g_pattern_param.adv_param.Direct_Address_Type[0]	=	HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	bt_hci_cmd_le_create_connection.parameter_tbl[2].value  =  g_pattern_param.create_conn_param.Initiator_Filter_Policy;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, zero_addr, ADDR_LENGTH);
    bt_hci_cmd_le_create_connection.parameter_tbl[4].value  = g_pattern_param.create_conn_param.Peer_Address;
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            break;
        }
    }
    dut_reset_with_mask_en(dut1_fd);
    sleep(6);


    //# case 2
    //Correct address type
    //Incorrect address

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, error_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, init_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	bt_hci_cmd_le_create_connection.parameter_tbl[2].value  =  g_pattern_param.create_conn_param.Initiator_Filter_Policy;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, zero_addr, ADDR_LENGTH);
    bt_hci_cmd_le_create_connection.parameter_tbl[4].value  = g_pattern_param.create_conn_param.Peer_Address;
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            break;
        }
    }
    dut_reset_with_mask_en(dut1_fd);
    sleep(6);


    //# case 3
    //Correct address type
    //Correct address

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, init_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config_type_addr(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param, HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, init_addr);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	bt_hci_cmd_le_create_connection.parameter_tbl[2].value  =  g_pattern_param.create_conn_param.Initiator_Filter_Policy;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, zero_addr, ADDR_LENGTH);
    bt_hci_cmd_le_create_connection.parameter_tbl[4].value  = g_pattern_param.create_conn_param.Peer_Address;
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);
    //waiting adv report event , timer or counter
    while(1) {
        if( 1 == read_le_event_get() ) {
            read_le_event_disable();
            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            break;
        }
    }

    sleep(6);

    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


    // # Slave Connection Terminated
    // use connect handle to disconnect
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

    COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(5);

    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);

    MSLEEP(500);

#if 0
    if(adv_Channel != 39){
        adv_Channel ++;
        goto REPEAT;
    }
#endif
    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return 0;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL : ch %d \n" ,__FUNCTION__,line ,adv_Channel);
    return 0;



}
// 5.3.3.1
verdict CON_SLA_Slave_Asymmetric_Connections (u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_mas[2];
    u8 acl_data[1] = {0xFF};
    u8 test_cnt1 = 0;

    int sla_pkt_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8; 
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    } 

    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	g_pattern_param.create_conn_param.Conn_Latency[0]		= 5 ;
	g_pattern_param.create_conn_param.Conn_Latency[1]		= 0 ;
	//The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
	//superviision TO > (1+connSlaveLatency)*Conninterval
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=0x14 ; // 20 * 10ms
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=0x00 ; //

    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(3, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            //######################################
            //Master to Slave
            while (test_cnt1 < 30) {

                printf("channel : %d, ACL_Data = 0xFF, Test_Cnt = %d\n", adv_Channel, test_cnt1);

                COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 1, acl_data);                
PKT_CHK:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
                
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                    
                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK;

                }                 

                sla_pkt_chk = 0;
                
                MSLEEP(300);
            
                if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {

                    line = __LINE__;
                    goto FUN_FAIL;
                }

                if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                // # need add api to check acl_data
                if (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }


                test_cnt1 ++ ;
             }

			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            FUNC_END();


            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:

    FUNC_END();

    
    LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n" , __FUNCTION__, line, adv_Channel);
    return FAIL;
}


// 5.3.3.2
verdict CON_SLA_Slave_Sending_Data (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
	int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[10] = {0};
	u8 acl_data2[32] = {0};
	u8 test_Times = 100;
	u8 test_cnt1 = 0;
	u8 test_cnt2 = 0;
	u8 test_cnt3 = 0;
    int adv_Channel = 37;
    int acl_init_cnt = 0 ;

    int sla_pkt_chk = 0 ;


    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // # init acl data with 1
    for ( ; acl_init_cnt < 32 ; acl_init_cnt ++){
        acl_data2[acl_init_cnt] = 1;
    }
        
	test_cnt1 = test_Times;
	test_cnt2 = test_Times;
	test_cnt3 = test_Times;
	
    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

	while(1)//waiting adv report event , timer or counter
	{
		if(1 == read_le_event_get())
		{
            read_le_event_disable();


			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];	

			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];	
			
			//######################################
			// # case 1 : LLID 2 , data 0
			for ( ;test_cnt1 > 0; test_cnt1--) {
				COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, 10, acl_data);
PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK1;
                
                }                 
                
                sla_pkt_chk = 0;

				printf("\ncase 1, ACL_Data = 0b00, Test_Cnt = %d\n", test_cnt1);

                usleep(SLEEP_MS);
                //step2 ~ 4
    			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

    			if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }

			}
            

			//######################################
			// # case 2 : LLID 1 , data 0
			
			for ( ;test_cnt2 > 0; test_cnt2--) {
				COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b01, 0, 10, acl_data);
PKT_CHK2:
                // # check disconnection                             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK2;
                
                }                 
                
                sla_pkt_chk = 0;


				printf("\ncase 2, ACL_Data = 0b01, Test_Cnt = %d\n", test_cnt2);

                usleep(SLEEP_MS);

    			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))	{
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

    			if (0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }

                
            }
			//######################################

			// # case 3 : LLID 2 , data 1
            
			for ( ;test_cnt3 > 0; test_cnt3--)	{
				COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b01, 0, 10, acl_data2);
PKT_CHK3:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK3;
                
                }                 
                
                sla_pkt_chk = 0;

				printf("\ncase 3 , ACL_Data = 0b01, Test_Cnt = %d\n", test_cnt3);

                usleep(SLEEP_MS);

    			if (SUCCESS != QUERY_Acl_Data(dut1_fd, buf)) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

    			if (0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data2 ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }
                
            }
                

			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();


            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;
}


// 5.3.3.3
verdict CON_SLA_Slave_Receiving_Data(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;

	u8 conn_handles_mas[2];
	u8 acl_data[10] = {0};
	u8 test_Times = 100;
	u8 test_cnt1 = 0;
	u8 test_cnt2 = 0;
	u8 test_cnt3 = 0;	
    int adv_Channel = 37;

    int sla_pkt_chk = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    test_cnt1 = test_Times;
	test_cnt2 = test_Times;
	test_cnt3 = test_Times;
    
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
  
	verdict = COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);    
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{
            read_le_event_disable();

            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
			    line = __LINE__;
			    goto FUN_FAIL;
			}
			else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
			    line = __LINE__;
			    goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
			    line = __LINE__;
			    goto FUN_FAIL;
			}
			else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
			    line = __LINE__;
			    goto FUN_FAIL;
			}
			
            
            //######################################
            // # case 1 : LLID =2 ; data = 0
			for ( ;test_cnt1 > 0; test_cnt1--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 10, acl_data);
PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK1;
                
                }                 
                
                sla_pkt_chk = 0;

                
                printf("\ncase 1 , ACL_Data = 0b00, Test_Cnt = %d\n", test_cnt1);

                usleep(SLEEP_MS);
            
                //step2 ~ 4
    			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))	{
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

    			if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }

            }
            
            //######################################
            //step5
            // # case 2 : LLID =1 ; data = 0

			for ( ;test_cnt2 > 0; test_cnt2--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 10, acl_data);
PKT_CHK2:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK2;
                
                }                 
                
                sla_pkt_chk = 0;

                
                printf("\ncase 2, ACL_Data = 0b01, Test_Cnt = %d\n", test_cnt2);

                usleep(SLEEP_MS);

                //step7
    			if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

    			if (0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }
                
            }

            //######################################
            //step8
            // # case 3 : first  LLID =2 ; data = 0 x 1
            //            second LLID =1 ; data = 0 x 999

            COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 10, acl_data);
PKT_CHK3:
            // # check disconnection             
            CHECK_NON_DISCONNECT();

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);
                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                goto PKT_CHK3;
            
            }                 
            
            sla_pkt_chk = 0;

            
            printf("\ncase 3, ACL_Data = 0b01, Test_Cnt = %d\n", test_cnt3);
            
            usleep(SLEEP_MS);
            
            //step7
            if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if (0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }


			for ( ;test_cnt3 > 0; test_cnt3--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 10, acl_data);
PKT_CHK4:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK4;
                
                }                 
                
                sla_pkt_chk = 0;

                
                printf("\ncase 4, ACL_Data = 0b01, Test_Cnt = %d\n", test_cnt3);

                usleep(SLEEP_MS);

                //step7
    			if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

    			if (0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }
                
            }

			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();


            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d  FAIL!!\n", __FUNCTION__, line);
	return FAIL;

}

// 5.3.3.4
verdict CON_SLA_Slave_Sending_and_Receiving_Data(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;
	u8 conn_handles_sla[2];
	u8 conn_handles_mas[2];
	u8 acl_data[10] = {0};
    u8 test_Times = 100;
	u8 test_cnt1 = 0;
    int adv_Channel = 37;

    int sla_pkt_chk = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    test_cnt1 = test_Times;

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
  
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {
            read_le_event_disable();

    		if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    		conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    		if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    		conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            //######################################
    	    for( ;test_cnt1 > 0; test_cnt1--) {
    			COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, 10, acl_data);
PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK1;
                
                }                 
                
                sla_pkt_chk = 0;



                usleep(SLEEP_MS);
    		
        		if(SUCCESS != QUERY_Acl_Data(dut1_fd, buf))	{
        			line = __LINE__;
        			goto FUN_FAIL;
        		}

        		if(0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
        			line = __LINE__;
        			goto FUN_FAIL;
        		}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }

    			COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 10, acl_data);
PKT_CHK2:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
                
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK2;
                
                }                 
                
                sla_pkt_chk = 0;



                usleep(SLEEP_MS);

        		if(SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
        			line = __LINE__;
        			goto FUN_FAIL;
        		}

        		if(0x02 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)	{
        			line = __LINE__;
        			goto FUN_FAIL;
        		}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }
            }

			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            FUNC_END();
            
    		LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    		return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
	return FAIL;

}

// 5.3.3.5
verdict CON_SLA_Accepting_Parameter_Update(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;
    u8 conn_handles_mas[2];
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
#if 1
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);

    g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


#else
	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
  
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
#endif
	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(10, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {
            read_le_event_disable();

    		if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    		conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            printf("\n");

    		if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

            //######################################

            //# case 1 min conn interval ; max event count
            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;           
            verdict = COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            printf("case 1 finished\n");
            printf("wait 10 sec\n");
            fflush(stdout);
            sleep(10);

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            // # wait and check
            // # conn int range 7.5ms to 4 s

            //# case 2 max conn interval ; min event count
            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
 
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = HCI_CMD_PARAM_CONN_INT_MAX & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(HCI_CMD_PARAM_CONN_INT_MAX & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = HCI_CMD_PARAM_CONN_INT_MAX & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(HCI_CMD_PARAM_CONN_INT_MAX & 0xff00)  >> 8;           

            g_pattern_param.conn_update_param.Supervision_Timeout[0]       = HCI_CMD_PARAM_CONN_LATENCY_MAX & 0x00ff;
            g_pattern_param.conn_update_param.Supervision_Timeout[1]       =(HCI_CMD_PARAM_CONN_LATENCY_MAX & 0xff00)  >> 8;

            g_pattern_param.conn_update_param.Conn_Latency[0]       = 0 & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Latency[1]       =(0 & 0xff00)  >> 8;       

            verdict = COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            printf("case 2 finished\n");            
            printf("wait 30 sec\n");
            fflush(stdout);
            
            sleep(30);

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            //# case 3 min conn interval ; max event count
            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;           
            verdict=COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            printf("case 3 finished\n");
            printf("wait 50 sec\n");
            fflush(stdout);
            
            sleep(50);


            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

                       
            FUNC_END();

    		LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    		return PASS;

		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n", __FUNCTION__, line, adv_Channel);
	return FAIL;

}


// 5.3.3.6
verdict CON_SLA_Slave_Sending_Termination(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_sla[2];
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
   
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);    
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=0x0a ; //=0xD0;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=0x00 ; //=0x07;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,  _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_sla[0];
			buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_sla[1];
			
			COMM_Disconnect_Config(dut2,&g_pattern_param,buf);
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_REMOTE_USER_TERMINATED_CONNECTION;
			verdict=COMM_Disconnect(dut2_fd,g_pattern_param);

            //# query dut2

            sleep(10);

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }
#if 0
            //# query dut1
            sleep(5);

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_CONNECTION_TIMEOUT != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }
#endif
            printf("sleep!Please check IUT stop sending packets\n");
            sleep(5);
                        
            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n", __FUNCTION__, line, adv_Channel);
    return FAIL;

}

// 5.3.3.7
verdict CON_SLA_Slave_Accepting_Termination(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_mas[2];
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;

    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
  
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);    
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=0x0a ; //=0xD0;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=0x00 ; //=0x07;
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,  _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];


            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

			// # Slave Connection Terminated
			// use connect handle to disconnect

            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_REMOTE_USER_TERMINATED_CONNECTION;
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);

            sleep(5);
            //# query dut2

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_REMOTE_USER_TERMINATED_CONNECTION != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            printf("sleep!Please check IUT stop sending packets\n");
            sleep(5);
                        
            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();


    LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n", __FUNCTION__, line, adv_Channel);
    return FAIL;
}


// 5.3.3.8
verdict CON_SLA_Slave_Supervision_Timer(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =   HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	//use max supervision here
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] =     HCI_CMD_PARAM_SUPERVISION_TO_MAX & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] =    (HCI_CMD_PARAM_SUPERVISION_TO_MAX & 0xff00) >> 8;
	//memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {
            
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
            
			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}            

			//Connection Terminated
			//use connect handle to disconnect
			COMM_Reset(dut1_fd);

            // # max timeout
			sleep(40);

			if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_CONNECTION_TIMEOUT != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

			break;
		}
	}

	//do another testing
	dut_reset_with_mask_en(dut2_fd);
    dut_reset_with_mask_en(dut1_fd);
    sleep(1);

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	//use max supervision here
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] =  HCI_CMD_PARAM_SUPERVISION_TO_MIN& 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] = (HCI_CMD_PARAM_SUPERVISION_TO_MIN & 0xff00) >> 8;
	//memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {

            read_le_event_disable();
            
			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
            
			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}            

			//Connection Terminated
			//use connect handle to disconnect
			COMM_Reset(dut1_fd);

			sleep(1);
            
			if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_CONNECTION_TIMEOUT != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
	return FAIL;
}


// 5.3.3.9
verdict CON_SLA_Feature_Setup_Response(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
    u8 conn_handles_mas[2];
    
	struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	//use max supervision here
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
    g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] = HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;	
	//memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {

            read_le_event_disable();
            
            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

            conn_handles_mas[0]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];
            
			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			verdict = COMM_Read_Local_Supported_Features(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			COMM_Read_Remote_Supported_Features_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
			verdict = COMM_Read_Remote_Supported_Features(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(5);

			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_READ_REMOTE_USED_FEATURES_COMPLETE_,	0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_read_remote_supported_features_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_READ_REMOTE_USED_FEATURES_COMPLETE_,	0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(ERROR != hci_event_read_remote_supported_features_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}



			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
            
            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
	return FAIL;
}


// 5.3.3.14
verdict CON_SLA_Slave_Request_Version(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
	// Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
	g_pattern_param.adv_param.Advertising_Channel_Map[0]  = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {

            read_le_event_disable();
            
			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

            conn_handles_mas[0]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];
            
			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

            conn_handles_sla[0]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];            

			COMM_Read_Remote_Version_Information_Config(dut2_fd, &g_pattern_param, conn_handles_sla);
			verdict = COMM_Read_Remote_Version_Information(dut2_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1);

			if(SUCCESS != QUERY_Event(dut2_fd, buf,	_BT_HCI_EVENT_OP_READ_REMOTE_VERSION_INFORMATION_COMPLETE_)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_read_remote_version_information_complete_parsing(buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
                        
            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;
}


// 5.3.3.15
verdict CON_SLA_Slave_Respond_Version(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;
	u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	Calculate_Execution_Time_Start();
	// Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
	g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    verdict = COMM_Read_Local_Version_Information(dut2_fd, &g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    if((g_pattern_param.local_version_information_param.Manufacturer_Name[0] != s_manufacturer[1]) || 
       (g_pattern_param.local_version_information_param.Manufacturer_Name[1] != s_manufacturer[0])){
    
        LOG_INFO("local manufacturer mismatch\n");
        LOG_INFO("pattern :0x%02x 0x%02x\n" , s_manufacturer[1] , s_manufacturer[0]);
        LOG_INFO("dut     :0x%02x 0x%02x\n" , g_pattern_param.local_version_information_param.Manufacturer_Name[0] , g_pattern_param.local_version_information_param.Manufacturer_Name[1]);
    
        line = __LINE__;
        goto FUN_FAIL;
    }

    if((g_pattern_param.local_version_information_param.LMP_PAL_Subversion[0] != s_subversion[1]) || 
       (g_pattern_param.local_version_information_param.LMP_PAL_Subversion[1] != s_subversion[0])){
    
        LOG_INFO("local subversion mismatch\n");
        LOG_INFO("pattern :0x%02x 0x%02x\n" , s_subversion[1] , s_subversion[0]);
        LOG_INFO("dut     :0x%02x 0x%02x\n" , g_pattern_param.local_version_information_param.LMP_PAL_Subversion[0] , g_pattern_param.local_version_information_param.LMP_PAL_Subversion[1]);
    
        line = __LINE__;
        goto FUN_FAIL;
    }


    
    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {

            read_le_event_disable();
            
			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			COMM_Read_Remote_Version_Information_Config(dut1_fd, &g_pattern_param, conn_handles_mas);
			verdict = COMM_Read_Remote_Version_Information(dut1_fd, g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1);

			if (SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_READ_REMOTE_VERSION_INFORMATION_COMPLETE_)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_read_remote_version_information_complete_parsing(buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

        	if((buf[_BT_HCI_EVT_REMOTE_VER_INFO_MANU_NAME  ] != s_manufacturer[1]) || 
               (buf[_BT_HCI_EVT_REMOTE_VER_INFO_MANU_NAME+1] != s_manufacturer[0])){

                LOG_INFO("remote manufacturer mismatch\n");

                line = __LINE__;
                goto FUN_FAIL;
        	}

        	if((buf[_BT_HCI_EVT_REMOTE_VER_INFO_SUBVER  ] != s_subversion[1]) || 
               (buf[_BT_HCI_EVT_REMOTE_VER_INFO_SUBVER+1] != s_subversion[0])){

                LOG_INFO("remote sub version mismatch\n");

                line = __LINE__;
                goto FUN_FAIL;
        	}

			if (SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_READ_REMOTE_VERSION_INFORMATION_COMPLETE_)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(ERROR != hci_event_read_remote_version_information_complete_parsing(buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}


			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();                        
            
            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;
}

// 5.3.3.16
verdict CON_SLA_Slave_Acknowledgement_Scheme (u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_mas[2];

    u8 acl_data[1] = {0xFF};
    u8 test_cnt1 = 0;

    int adv_Channel = 37;

    int sla_pkt_chk = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8; 

    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {        
            read_le_event_disable();
            
            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];      

            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            //######################################
            //Master to Slave
            while (test_cnt1 < 15) {

                printf("channel : %d, ACL_Data = 0xFF, Test_Cnt = %d\n", adv_Channel, test_cnt1);
                
                COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 1, acl_data);
PKT_CHK:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }

                    goto PKT_CHK;
                } 

                sla_pkt_chk = 0 ;

                usleep(300000);
            
                if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                // # need add api to check acl_data
                if (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }


                test_cnt1 ++ ;
             }

            buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
            verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:

    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n" , __FUNCTION__, line, adv_Channel);
    return FAIL;
}

// 5.4.1.2
verdict CON_MAS_Master_Sending_Data (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 acl_data[10] = {0};
	u8 acl_data2[32] = {0};
    u8 test_Times = 100;
    u8 test_cnt1 = 0;
    u8 test_cnt2 = 0;
    u8 test_cnt3 = 0;
    u8 test_cnt4 = 0;
    int adv_Channel = 37;

    int mas_pkt_chk = 0 ;

	Calculate_Execution_Time_Start();
REPEAT:
    test_cnt1 = test_Times;
    test_cnt2 = test_Times;
    test_cnt3 = test_Times;
    test_cnt4 = test_Times;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);


    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

	while(1)//waiting adv report event , timer or counter
	{
		if (1 == read_le_event_get()) {
            read_le_event_disable();
            
			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			//######################################
			for( ;test_cnt1 > 0; test_cnt1--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 10, acl_data);
PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }

                    goto PKT_CHK1;
                } 

                mas_pkt_chk = 0 ;
                
                printf("case 1, channel : %d, ACL_Data = 0b00, Test_Cnt = %d\n", adv_Channel, test_cnt1);
			}

            //step2 ~ 4
			if(SUCCESS != QUERY_Acl_Data(dut2_fd,buf))	{
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0b10 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//######################################
			for( ;test_cnt2 > 0; test_cnt2--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 10, acl_data);
PKT_CHK2:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
    
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");

                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    
                    goto PKT_CHK2;
                } 

                mas_pkt_chk = 0 ;
                
                printf("case 2, channel : %d, ACL_Data = 0b01, Test_Cnt = %d\n", adv_Channel, test_cnt2);
			}

			if(SUCCESS != QUERY_Acl_Data(dut2_fd, buf))	{
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//######################################
			COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 10, acl_data);
PKT_CHK3:
            // # check disconnection             
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);

                mas_pkt_chk ++ ;
                if (mas_pkt_chk == 100){
                    printf("mas no number of completed pkts\n");

                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                
                goto PKT_CHK3;
            } 

            mas_pkt_chk = 0 ;

            printf("case 3, channel : %d, ACL_Data = 0b01, Test_Cnt = %d\n", adv_Channel, test_cnt2);


			if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if (0b10 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//######################################
			for ( ;test_cnt3 > 0; test_cnt3--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 10, acl_data);
PKT_CHK4:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    
                    goto PKT_CHK4;
                } 
                
                mas_pkt_chk = 0 ;
                
                printf("case 4, channel : %d, ACL_Data = 0b00, Test_Cnt = %d\n", adv_Channel, test_cnt3);
			}
			if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if (0b01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//######################################

			for ( ;test_cnt4 > 0; test_cnt4--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 23, acl_data2);
PKT_CHK5:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    
                    goto PKT_CHK5;
                } 
                
                mas_pkt_chk = 0 ;
                
                printf("case 5, channel : %d, ACL_Data = 0b01, Test_Cnt = %d\n", adv_Channel, test_cnt4);
			}

			if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if (0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
            if(adv_Channel != 39){        
                adv_Channel ++;				
				//COMM_Reset(dut1_fd);
				//COMM_Reset(dut2_fd);
				dut_reset_with_mask_en(dut1_fd);
				dut_reset_with_mask_en(dut2_fd);
                goto REPEAT;
            }
			//COMM_Reset(dut1_fd);
			//COMM_Reset(dut2_fd);
			dut_reset_with_mask_en(dut1_fd);
			dut_reset_with_mask_en(dut2_fd);

            FUNC_END();
			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n" , __FUNCTION__, line, adv_Channel);
    return FAIL;
}


// 5.4.1.3
verdict CON_MAS_Master_Receiving_Data(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
	struct itimerval timer;
	u8 conn_handles_sla[2];
	u8 acl_data[10] = {0};
	u8 test_Times = 100;
    u8 test_cnt1 = 0;
    u8 test_cnt2 = 0;
    u8 test_cnt3 = 0;    
    int adv_Channel = 37;   
    int mas_pkt_chk = 0 ;
    
	Calculate_Execution_Time_Start();
REPEAT:
    test_cnt1 = test_Times;
    test_cnt2 = test_Times;
    test_cnt3 = test_Times;   

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {
			read_le_event_disable();

			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}


			if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			conn_handles_sla[0]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            //######################################
            //step1
			for( ;test_cnt1 > 0; test_cnt1--) {
				COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, 10, acl_data);
PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    
                    goto PKT_CHK1;
                } 
                
                mas_pkt_chk = 0 ;

                printf("case 1, channel : %d, ACL_Data = 0b00, Test_Cnt = %d\n", adv_Channel, test_cnt1);
			}
            //step2 ~ 4
			if(SUCCESS != QUERY_Acl_Data(dut1_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0b10 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
            //######################################
			for( ;test_cnt2 > 0; test_cnt2--)//step5
			{
				COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b01, 0, 10, acl_data);
PKT_CHK2:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    
                    goto PKT_CHK2;
                } 
                
                mas_pkt_chk = 0 ;

                printf("case 2, channel : %d, ACL_Data = 0b01, Test_Cnt = %d\n", adv_Channel, test_cnt2);
            }
            //step7
			if(SUCCESS != QUERY_Acl_Data(dut1_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0b01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4)	{
				line = __LINE__;
				goto FUN_FAIL;
			}
            //######################################
			COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b01, 0, 10, acl_data);
PKT_CHK3:
            // # check disconnection             
            CHECK_NON_DISCONNECT();

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);
            
                mas_pkt_chk ++ ;
                if (mas_pkt_chk == 100){
                    printf("mas no number of completed pkts\n");
            
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                
                goto PKT_CHK3;
            } 
            
            mas_pkt_chk = 0 ;


            printf("case 3, channel : %d, ACL_Data = 0b01\n", adv_Channel);
            //step7
			if(SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0b01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
            //######################################
			for( ;test_cnt3 > 0; test_cnt3--) {
				COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b01, 0, 10, acl_data);
PKT_CHK4:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    
                    goto PKT_CHK4;
                } 
                
                mas_pkt_chk = 0 ;

                printf("case 4, channel : %d, ACL_Data = 0b01, Test_Cnt = %d\n", adv_Channel, test_cnt3);
			}

			if(SUCCESS != QUERY_Acl_Data(dut1_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0b01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}

            if(adv_Channel != 39){        
                adv_Channel ++;				
				//COMM_Reset(dut1_fd);
				//COMM_Reset(dut2_fd);
				dut_reset_with_mask_en(dut1_fd);
				dut_reset_with_mask_en(dut2_fd);
                goto REPEAT;
            }
			//COMM_Reset(dut1_fd);
			//COMM_Reset(dut2_fd);
			dut_reset_with_mask_en(dut1_fd);
			dut_reset_with_mask_en(dut2_fd);
            FUNC_END();
			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.4.1.4
verdict CON_MAS_Master_Sending_and_Receiving_Data(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict =FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[10] = {0};
	u8 acl_data2[10] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	u8 test_Times = 100;
    u8 test_cnt1 = 0;
    u8 test_cnt2 = 0;    
    int adv_Channel = 37;
    int mas_pkt_chk = 0;
    
REPEAT:
    test_cnt1 = test_Times;
    test_cnt2 = test_Times;    

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_COMP_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_COMP_HANDLE+1];

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_COMP_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_COMP_HANDLE+1];

            //######################################
            for(;test_cnt1 > 0; test_cnt1--) {
                COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 10, acl_data);
PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");

                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }

                    goto PKT_CHK1;
                } 

                mas_pkt_chk = 0 ;


                usleep(SLEEP_MS);

                if(SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                if(0b10 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, 10, acl_data2);
PKT_CHK2:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");

                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }

                    goto PKT_CHK2;
                } 

                mas_pkt_chk = 0 ;


                usleep(SLEEP_MS);

                if(SUCCESS != QUERY_Acl_Data(dut1_fd, buf)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                if(0b10 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
            }
#if 0
            if(adv_Channel != 39){        
                adv_Channel ++;				
                //COMM_Reset(dut1_fd);
                //COMM_Reset(dut2_fd);
                dut_reset_with_mask_en(dut1_fd);
                dut_reset_with_mask_en(dut2_fd);
                goto REPEAT;
            }
#endif
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

            COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
            verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();
    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.4.1.5
verdict CON_MAS_Events_With_Slave_Latency(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[4] = {0xFF, 0xFF, 0xFF, 0xFF};
	u8 acl_data2[32] = {0};
    u8 test_Times = 60;
    u8 test_cnt1 = 0;
    u8 test_cnt2 = 0;
    u8 test_cnt3 = 0;
    u8 test_cnt4 = 0;
    int adv_Channel = 37;

    int mas_pkt_chk = 0 ;

	Calculate_Execution_Time_Start();
REPEAT:
    test_cnt1 = test_Times;
    test_cnt2 = test_Times;
    test_cnt3 = test_Times;
    test_cnt4 = test_Times;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);


    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]       =   26; //HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]       =   0;//(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)   >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]       =   26;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]       =   0;
    g_pattern_param.create_conn_param.Conn_Latency[0]            =   5;//HCI_CMD_PARAM_CONN_LATENCY_MIN;//HCI_CMD_PARAM_CONN_LATENCY_MAX & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]            =   0;//HCI_CMD_PARAM_CONN_LATENCY_MIN;//(HCI_CMD_PARAM_CONN_LATENCY_MAX & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]     =   0x80 ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]     =   0x0c ; //=0x07;



	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

	while(1)//waiting adv report event , timer or counter
	{
		if (1 == read_le_event_get()) {
            read_le_event_disable();

			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			//######################################
			for( ;test_cnt1 > 0; test_cnt1--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, sizeof(acl_data), acl_data);
                if (0 == (test_cnt1%3)) {
    				COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, sizeof(acl_data), acl_data);
                }
#if 1
PKT_CHK1:
                // # check disconnection
                //CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;
                    }

                    goto PKT_CHK1;
                }

                mas_pkt_chk = 0 ;

                //printf("case 1, channel : %d, ACL_Data = 0b00, Test_Cnt = %d\n", adv_Channel, test_cnt1);
#endif
			}

            //step2 ~ 4
			if(SUCCESS != QUERY_Acl_Data(dut2_fd,buf))	{
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0b10 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//COMM_Reset(dut1_fd);
			//COMM_Reset(dut2_fd);
			dut_reset_with_mask_en(dut1_fd);
			dut_reset_with_mask_en(dut2_fd);

            FUNC_END();
			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n" , __FUNCTION__, line, adv_Channel);
    return FAIL;
}

// 5.4.1.6 Master Acknowledgement Scheme
verdict CON_MAS_Master_Acknowledgement_Scheme (u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[4] = {0xFF, 0xFF, 0xFF, 0xFF};
    u8 test_cnt1 = 0;

    int adv_Channel = 37;

    int sla_pkt_chk = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;

    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            //######################################
            //Master to Slave
            while (test_cnt1 < 15) {

                printf("channel : %d, ACL_Data = 0xFF, Test_Cnt = %d\n", adv_Channel, test_cnt1);

                COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, sizeof(acl_data), acl_data);
                COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, sizeof(acl_data), acl_data);
PKT_CHK:
                // # check disconnection
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;
                    }

                    goto PKT_CHK;
                }

                sla_pkt_chk = 0 ;

                usleep(300000);

                if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                // # need add api to check acl_data
                if (    (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_])) ||
                        (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_+1])) ||
                        (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_+2])) ||
                        (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_+3]))
                    )
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }

                if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                // # need add api to check acl_data
                if (    (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_])) ||
                        (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_+1])) ||
                        (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_+2])) ||
                        (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_+3]))
                    )
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }


                test_cnt1 ++ ;
             }

            buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_mas[1];

            COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
            verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:

    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n" , __FUNCTION__, line, adv_Channel);
    return FAIL;
}
// 5.4.1.8
verdict CON_MAS_Master_Supervision_Timer(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict=FAIL;
    int dut1 =0;
    int dut2 =0;
    u16 line =0 ;
    struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    memcpy (g_pattern_param.adv_param.Direct_Address , init_addr , ADDR_LENGTH);//should be peer addr!!!
    //here use lowest ch to testing
    g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
    verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1,&g_pattern_param);
    //use max supervision here
    g_pattern_param.create_conn_param.Supervision_Timeout[0]		=HCI_CMD_PARAM_SUPERVISION_TO_MAX& 0x00ff;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]		=(HCI_CMD_PARAM_SUPERVISION_TO_MAX & 0xff00)  >> 8;

    memcpy(g_pattern_param.create_conn_param.Peer_Address ,adv_addr,ADDR_LENGTH );
    verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5 , 0 , 0 , 0, &timer);
    event_query_timer_start(timer ,read_le_event_enable );


    while(1)//waiting adv report event , timer or counter
    {
        if ( 1 == read_le_event_get() )
        {    
            read_le_event_disable();

            if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
                        _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
                        0))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0,
                        buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            //Reset Slave
            COMM_Reset(dut2_fd);

            sleep(40);
            if (SUCCESS != QUERY_Event(dut1_fd,buf ,
										_BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			hci_event_disconnection_complete_parsing(0,buf,g_pattern_param);
			if(_BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT
				!= buf[_BT_HCI_EVT_DISCONN_COMP_REASON])
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//printf("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			//return ;
			break;
		}
	}

	//do another testing
	//COMM_Reset(dut1_fd);
	dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , init_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	//use min supervision here
	g_pattern_param.create_conn_param.Supervision_Timeout[0]		=HCI_CMD_PARAM_SUPERVISION_TO_MIN& 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1]		=(HCI_CMD_PARAM_SUPERVISION_TO_MIN & 0xff00)  >> 8;

	memcpy(g_pattern_param.create_conn_param.Peer_Address ,adv_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );


	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//Connection Terminated
			//use connect handle to disconnect
			COMM_Reset(dut2_fd);

            MSLEEP(150);
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,
										_BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			hci_event_disconnection_complete_parsing(0,buf,g_pattern_param);
			if(_BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT
				!= buf[_BT_HCI_EVT_DISCONN_COMP_REASON])
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			FUNC_END();
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;    
}


// 5.4.1.9
verdict CON_MAS_Feature_Setup_Request(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut1 =0;
	int dut2 =0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , init_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,adv_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );



	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			verdict=COMM_Read_Local_Supported_Features(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			COMM_Read_Remote_Supported_Features_Config(dut1_fd,&g_pattern_param,conn_handles_mas);
			verdict=COMM_Read_Remote_Supported_Features(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(5);

			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_READ_REMOTE_USED_FEATURES_COMPLETE_
										,0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_read_remote_supported_features_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
            FUNC_END();
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.4.1.10
verdict CON_MAS_Transmit_Fragmented_L2CAP_Header (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 acl_data[10] = {0};
	u8 acl_data2[32] = {0};
    u8 test_Times = 100;
    u8 test_cnt1 = 0;
    u8 test_cnt2 = 0;
    u8 test_cnt3 = 0;
    u8 test_cnt4 = 0;
    int adv_Channel = 37;

    int mas_pkt_chk = 0 ;

REPEAT:
    test_cnt1 = test_Times;
    test_cnt2 = test_Times;
    test_cnt3 = test_Times;
    test_cnt4 = test_Times;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);


    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    else if(38 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    }
    else {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

	while(1)//waiting adv report event , timer or counter
	{
		if (1 == read_le_event_get()) {
            read_le_event_disable();

			if (SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			//######################################
			for( ;test_cnt1 > 0; test_cnt1--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 10, acl_data);
PKT_CHK1:
                // # check disconnection
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;
                    }

                    goto PKT_CHK1;
                }

                mas_pkt_chk = 0 ;

                printf("case 1, channel : %d, ACL_Data = 0b00, Test_Cnt = %d\n", adv_Channel, test_cnt1);
			}

            //step2 ~ 4
			if(SUCCESS != QUERY_Acl_Data(dut2_fd,buf))	{
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0b10 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//######################################
			for( ;test_cnt2 > 0; test_cnt2--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 10, acl_data);
PKT_CHK2:
                // # check disconnection
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");

                        line = __LINE__;
                        goto FUN_FAIL;
                    }

                    goto PKT_CHK2;
                }

                mas_pkt_chk = 0 ;

                printf("case 2, channel : %d, ACL_Data = 0b01, Test_Cnt = %d\n", adv_Channel, test_cnt2);
			}

			if(SUCCESS != QUERY_Acl_Data(dut2_fd, buf))	{
				line = __LINE__;
				goto FUN_FAIL;
			}

			if(0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//######################################
			COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, 10, acl_data);
PKT_CHK3:
            // # check disconnection
            CHECK_NON_DISCONNECT();

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);

                mas_pkt_chk ++ ;
                if (mas_pkt_chk == 100){
                    printf("mas no number of completed pkts\n");

                    line = __LINE__;
                    goto FUN_FAIL;
                }

                goto PKT_CHK3;
            }

            mas_pkt_chk = 0 ;

            printf("case 3, channel : %d, ACL_Data = 0b01, Test_Cnt = %d\n", adv_Channel, test_cnt2);


			if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if (0b10 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//######################################
			for ( ;test_cnt3 > 0; test_cnt3--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 10, acl_data);
PKT_CHK4:
                // # check disconnection
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");

                        line = __LINE__;
                        goto FUN_FAIL;
                    }

                    goto PKT_CHK4;
                }

                mas_pkt_chk = 0 ;

                printf("case 4, channel : %d, ACL_Data = 0b00, Test_Cnt = %d\n", adv_Channel, test_cnt3);
			}
			if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if (0b01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			//######################################

			for ( ;test_cnt4 > 0; test_cnt4--) {
				COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b01, 0, 23, acl_data2);
PKT_CHK5:
                // # check disconnection
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");

                        line = __LINE__;
                        goto FUN_FAIL;
                    }

                    goto PKT_CHK5;
                }

                mas_pkt_chk = 0 ;

                printf("case 5, channel : %d, ACL_Data = 0b01, Test_Cnt = %d\n", adv_Channel, test_cnt4);
			}

			if (SUCCESS != QUERY_Acl_Data(dut2_fd, buf)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			if (0x01 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0 ) >> 4) {
				line = __LINE__;
				goto FUN_FAIL;
			}
            if(adv_Channel != 39){
                adv_Channel ++;
				//COMM_Reset(dut1_fd);
				//COMM_Reset(dut2_fd);
				dut_reset_with_mask_en(dut1_fd);
				dut_reset_with_mask_en(dut2_fd);
                goto REPEAT;
            }
			//COMM_Reset(dut1_fd);
			//COMM_Reset(dut2_fd);
			dut_reset_with_mask_en(dut1_fd);
			dut_reset_with_mask_en(dut2_fd);

			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n" , __FUNCTION__, line, adv_Channel);
    return FAIL;
}
// 5.4.1.16
verdict CON_MAS_Master_Request_Version(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut1=0;
	int dut2=0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , init_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,adv_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			verdict=COMM_Read_Local_Version_Information(dut1_fd,&g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			COMM_Read_Remote_Version_Information_Config(dut1_fd,&g_pattern_param,conn_handles_mas);
			verdict=COMM_Read_Remote_Version_Information(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1);

			if (SUCCESS != QUERY_Event(dut1_fd,buf ,
										_BT_HCI_EVENT_OP_READ_REMOTE_VERSION_INFORMATION_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_read_remote_version_information_complete_parsing(buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
		  
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.4.1.17
verdict CON_MAS_Master_Respond_Version(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut1 =0;
	int dut2 =0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_sla[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , init_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,adv_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			verdict=COMM_Read_Local_Version_Information(dut2_fd,&g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			COMM_Read_Remote_Version_Information_Config(dut2_fd,&g_pattern_param,conn_handles_sla);
			verdict=COMM_Read_Remote_Version_Information(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1);

			if (SUCCESS != QUERY_Event(dut2_fd,buf ,
										_BT_HCI_EVENT_OP_READ_REMOTE_VERSION_INFORMATION_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_read_remote_version_information_complete_parsing(buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
            
            FUNC_END();
            
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    
    FUNC_END();
    
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.5.1.1
// TIM_ADV_Earliest_transmission_to_Advertiser
verdict TIM_ADV_Earliest_transmission_to_Advertiser(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    u16 line;
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;

    struct itimerval timer;
    
    u16 adv_cnt_37 = 0;
    u16 adv_cnt_38 = 0;
    u16 adv_cnt_39 = 0;
    u16 scn_rsp_37 = 0;
    u16 scn_rsp_38 = 0;
    u16 scn_rsp_39 = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    //#p1: lower tester with active scanning

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  HCI_CMD_PARAM_SCAN_INT_MAX & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (HCI_CMD_PARAM_SCAN_INT_MAX & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    HCI_CMD_PARAM_SCAN_WIN_MAX & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (HCI_CMD_PARAM_SCAN_WIN_MAX & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
    //interval : 32(0x0020) * 0.625ms = 20ms
    //if (1 == repeat) {
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x01;
    g_pattern_param.adv_data_param.Advertising_Data[0] = 0x01;

    //#p2: undir with ch 37
	g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //waiting adv report event , timer or counter
    while(1) {
        read_le_event_enable();
        event_query_timer_config(60, 0, 0, 0, &timer);
        event_query_timer_start(timer, read_le_event_disable);
        printf("****timer for 60 sec****\n" );        

        while (read_le_event_get()){

            MSLEEP(20);

            //#p3 expect ADV_IND
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                continue;
                
                
            }            
            else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf, g_pattern_param)) {
                continue;
            }
            else {
                adv_cnt_37++ ;
                printf("** check adv ind : %d time **\n" , adv_cnt_37);                    
            }

            //#p4 expect SCAN_RSP
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                continue;
                
                
            }            
            else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                continue;
            }
            else {
                scn_rsp_37++ ;
                printf("** check scan rsp : %d time **\n" , scn_rsp_37);                    
            }

             
        }
        
        COMM_SCN_Disable_Config(dut1,&g_pattern_param);
        verdict = COMM_SCN_Disable(dut1_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        COMM_ADV_Disable_Config(dut2, &g_pattern_param);
        verdict = COMM_ADV_Disable(dut2_fd, g_pattern_param);
        //VERDICT_RESULT_WITH_LINE();

        break;
    }

    //#p1: lower tester with active scanning
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  HCI_CMD_PARAM_SCAN_INT_MAX & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (HCI_CMD_PARAM_SCAN_INT_MAX & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    HCI_CMD_PARAM_SCAN_WIN_MAX & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (HCI_CMD_PARAM_SCAN_WIN_MAX & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
    //interval : 32(0x0020) * 0.625ms = 20ms
    //if (1 == repeat) {
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x01;
    g_pattern_param.adv_data_param.Advertising_Data[0] = 0x01;

    //#p2: undir with ch 38
    g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_38;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //waiting adv report event , timer or counter
    while(1) {
        read_le_event_enable();
        event_query_timer_config(60, 0, 0, 0, &timer);
        event_query_timer_start(timer, read_le_event_disable);
        printf("****timer for 60 sec****\n" );        

        while(read_le_event_get()){            

            MSLEEP(20);

            //#p3 expect ADV_IND
            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                continue;
                
                
            }            
            else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf, g_pattern_param)) {
                continue;
            }
            else {
                adv_cnt_38++ ;
                printf("** check adv ind : %d time **\n", adv_cnt_38);                    
            }

            //#p4 expect SCAN_RSP
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                continue;
                
                
            }            
            else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                continue;
            }
            else {
                scn_rsp_38++ ;
                printf("** check scan rsp : %d time **\n" , scn_rsp_38);                    
            }

             
        }
        
        COMM_SCN_Disable_Config(dut1, &g_pattern_param);
        verdict = COMM_SCN_Disable(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        COMM_ADV_Disable_Config(dut2, &g_pattern_param);
        verdict = COMM_ADV_Disable(dut2_fd, g_pattern_param);
        //VERDICT_RESULT_WITH_LINE();

        break;
    }

    //#p1: lower tester with active scanning
    COMM_SCN_Active_Scanning_Config(dut1, &g_pattern_param);
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  HCI_CMD_PARAM_SCAN_INT_MAX & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (HCI_CMD_PARAM_SCAN_INT_MAX & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    HCI_CMD_PARAM_SCAN_WIN_MAX & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (HCI_CMD_PARAM_SCAN_WIN_MAX & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] =HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
    //interval : 32(0x0020) * 0.625ms = 20ms
    //if (1 == repeat) {
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x01;
    g_pattern_param.adv_data_param.Advertising_Data[0] = 0x01;

    //#p2: undir with ch 39
    g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //waiting adv report event , timer or counter
    while(1) {
        read_le_event_enable();
        event_query_timer_config(60, 0, 0, 0, &timer);
        event_query_timer_start(timer, read_le_event_disable);
        printf("****timer for 60 sec****\n" );        

        while (read_le_event_get()){

            MSLEEP(20);

            //#p3 expect ADV_IND
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {
                continue;
                
                
            }            
            else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND, buf, g_pattern_param)) {
                continue;
            }
            else {
                adv_cnt_39++ ;
                printf("** check adv ind : %d time **\n" , adv_cnt_39);                    
            }

            //#p4 expect SCAN_RSP
            if (SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {
                continue;
                
                
            }            
            else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
                continue;
            }
            else {
                scn_rsp_39++ ;
                printf("** check scan rsp : %d time **\n" , scn_rsp_39);                    
            }

             
        }
        
        COMM_SCN_Disable_Config(dut1,&g_pattern_param);
        verdict = COMM_SCN_Disable(dut1_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        COMM_ADV_Disable_Config(dut2, &g_pattern_param);
        verdict = COMM_ADV_Disable(dut2_fd, g_pattern_param);
        //VERDICT_RESULT_WITH_LINE();

        break;
    }

    FUNC_END(); 
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);    
    LOG_INFO("adv cnt 37 =%d \n" , adv_cnt_37);
    LOG_INFO("adv cnt 38 =%d \n" , adv_cnt_38);
    LOG_INFO("adv cnt 39 =%d \n" , adv_cnt_39);
    LOG_INFO("scn rsp 37 =%d \n" , scn_rsp_37);
    LOG_INFO("scn rsp 38 =%d \n" , scn_rsp_38);
    LOG_INFO("scn rsp 39 =%d \n" , scn_rsp_39);
    return PASS;
    
FUN_FAIL:
    FUNC_END();   
    
    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.5.2.1
verdict TIM_SLA_Adjusting_Anchor_Point(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
	while(1) {
		if(1 == read_le_event_get()) {
            read_le_event_disable();

    		if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    		conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];


    		if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
    			line = __LINE__;
    			goto FUN_FAIL;
    		}

    		conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    		conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            //######################################

            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;           
            verdict=COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            sleep(6);

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;           
            verdict=COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            sleep(6);

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS == hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
    		buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0] ;
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1] ;

			COMM_Disconnect_Config(dut2,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
               
            FUNC_END();


    		LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    		return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;
}

// 5.5.2.2
verdict TIM_SLA_Earliest_Transmission_Start_to_Slave(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_mas[2];
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=  0x03E8 & 0x00ff;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    = (0x03E8 & 0xff00)  >> 8;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];


            //######################################

            sleep(1);

			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
                         
            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();
    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;
}

// 5.5.2.3
verdict TIM_SLA_Latest_Transmission_Start_to_Slave(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_mas[2];
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=  69 & 0x00ff;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    = (69 & 0xff00)  >> 8;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];


            //######################################

            sleep(1);

			// # Slave Connection Terminated
			// use connect handle to disconnect
			buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
                         
            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;
}

// 5.5.2.4
verdict TIM_SLA_Shortest_Connection_Interval(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] = 0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] 	    =  8 & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      = (8 & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0] 	    =  8 & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      = (8 & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=  3200 & 0x00ff;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    = (3200 & 0xff00)  >> 8;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            //# add for conn success then reset . reconn will fail
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();


            //######################################
                        
            FUNC_END();


            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;
}

// 5.7.1.1
verdict FRH_ADV_Accepting_Connections_with_Hop_Lengths (u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict=FAIL;
    int dut1 =0;
    u16 line =0 ;
    struct itimerval timer;
    u8 conn_handles_mas[2];
    u32 sleep_s = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    //# p2 : enables advertising in the IUT using one advertising channel 
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    //here use lowest ch to testing
    g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
    verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict=COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    //# p1 : Configure Lower Tester to initiate a connection.
    COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	g_pattern_param.create_conn_param.Initiator_Filter_Policy[0] =HCI_CMD_PARAM_FILTER_POLICY_WHITE_LIST_USED;
    
    verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5 , 0 , 0 , 0, &timer);
    event_query_timer_start(timer ,read_le_event_enable );

    while(1)//waiting adv report event , timer or counter
    {
        if ( 1 == read_le_event_get() )
        {            
            read_le_event_disable();
        
            if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
                                        _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
                                        0))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            // #p4 : Upper Tester expects an HCI_LE_Connection_Complete event from the IUT
            if(SUCCESS != hci_le_event_connection_complete_parsing(0,
                                        buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

            if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
                                        _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
                                        0))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }


			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

            // #p7 check per channel use;

            sleep(sleep_s);

			// #p8 Slave Connection Terminated
			// use connect handle to disconnect

            buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_mas[1];

			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            FUNC_END();


            LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:

    FUNC_END();

    
    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);   
    return FAIL;

}

 
// 5.7.2.1
verdict FRH_SLA_Accepting_Channel_Map_Update (u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict=FAIL;
    int dut1 =0;
    u16 line =0 ;
    struct itimerval timer;
    u8 conn_handles_mas[2];
    //u32 sleep_s = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    //# p2 : enables advertising in the IUT using one advertising channel 
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    //here use lowest ch to testing
    g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
    verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //# p1 : Configure Lower Tester to initiate a connection.
    COMM_INI_Initiating_Config(dut1,&g_pattern_param);
    verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5 , 0 , 0 , 0, &timer);
    event_query_timer_start(timer ,read_le_event_enable );

    while(1)//waiting adv report event , timer or counter
    {
        if ( 1 == read_le_event_get() )
        {            
            read_le_event_disable();
        
            if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
                                        _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
                                        0))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            // #p4 : Upper Tester expects an HCI_LE_Connection_Complete event from the IUT
            if(SUCCESS != hci_le_event_connection_complete_parsing(0,
                                        buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_mas[1];

            // #p7 check per channel use;

            COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , CH_MAP_EVEN);
            verdict=COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            sleep(3);
            
            COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , CH_MAP_FULL);
            verdict=COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            sleep(3);

			// #p8 Slave Connection Terminated
			// use connect handle to disconnect

			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();  
    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.9.1.1
verdict SEC_ADV_Advertising_With_Random_Address (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut1 =0;
	u16 line =0 ;
	struct itimerval timer;
    u16 adv_chk_error = 0;
    u16 scn_chk_error = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    // #p1 Upper Tester sends an HCI_LE_Set_Random_Address command to set the IUT random address. 
	// just add all random address for all dut
	//COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
	//COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
	COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
	COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

	COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
	COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
	//COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
	//COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);

	COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

	COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
	COMM_Device_Address_Set(dut2_fd,g_pattern_param);

	COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
	g_pattern_param.scn_param.Own_Address_Type[0]	=	HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
	g_pattern_param.scn_param.LE_Scan_Interval[0]	=	    HCI_CMD_PARAM_SCAN_INT_MAX/3  & 0x00ff ;
	g_pattern_param.scn_param.LE_Scan_Interval[1]	=	   ((HCI_CMD_PARAM_SCAN_INT_MAX/3)  & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0]	=	        HCI_CMD_PARAM_SCAN_INT_MAX/3  & 0x00ff ;
	g_pattern_param.scn_param.LE_Scan_Window[1]	=	       ((HCI_CMD_PARAM_SCAN_INT_MAX/3)  & 0xff00) >> 8;
    
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
    
    // #p2 : Upper Tester enables undirected advertising and sets scan response data in the IUT. 
	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    // #p3 : Configure the Lower Tester active scanning with random device address. 
	g_pattern_param.adv_param.Own_Address_Type[0]	    =	HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
	g_pattern_param.adv_param.Direct_Address_Type[0]	=	HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;

	g_pattern_param.adv_param.Advertising_Interval_Min[0]=0xa0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1]=(0xa0 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Max[0]=0xa0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1]=(0xa0 & 0xff00)	>> 8;
    
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =  HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] =
		HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    memcpy (g_pattern_param.adv_param.Direct_Address , adv_random_addr , ADDR_LENGTH);    
	verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(1 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1== read_le_event_get() )
		{
			//reset event flag
			//read_le_event_disable();
			//event add
            MSLEEP(10);

			//query adv_ind
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_,
										HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

            // # p4 : Lower Tester expects an ADV_IND packet from the IUT using the advertising 
            // random address  

			if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND,
															buf,g_pattern_param))
			{
			    if(adv_chk_error < 300){
                    printf("adv check err with %d \n" , adv_chk_error);
                    adv_chk_error ++ ;
                    continue;
			    }
                else{
    				line=__LINE__;
    				goto FUN_FAIL;
                }
			}

            adv_chk_error = 0;
            
			//query scan_rsp
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_,
										HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

            // # p6 :Lower Tester expects an SCAN_RSP packet from the IUT addressed to the 
            // tester after T_IFS from the end of the request packet. 

			if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP,
															buf,g_pattern_param))
			{
			    if(scn_chk_error < 300){
                    printf("scn check err with %d \n" , scn_chk_error);
                    scn_chk_error ++;
                    continue;
			    }
                else{
    				line=__LINE__;
    				goto FUN_FAIL;
                }

			}

            // #p7 : Upper Tester sends an HCI_LE_Set_Advertise_Enable command to disable 
            // advertising in the IUT and expects an HCI_Command_Complete event from 
            // the IUT. 
            
			//COMM_ADV_Disable_Config(dut2_fd,&g_pattern_param);
			//verdict=COMM_ADV_Disable(dut2_fd,g_pattern_param);
			//VERDICT_RESULT_WITH_LINE();

            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.9.2.1
verdict SEC_SCN_Random_Address_Scanning (u8 dut1_fd ,u8 dut2_fd)
{

	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut2 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u32 adv_cnt=0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    Calculate_Execution_Time_Start();

	//#2 = scanner ; #1 =advertiser
	//just add all random address for all dut
	COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
	COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
	COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
	COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

	COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
	COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
	COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
	COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);

	COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
	COMM_Device_Address_Set(dut2_fd,g_pattern_param);

	COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);

	COMM_SCN_Active_Scanning_Config(dut2,&g_pattern_param);
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] =	HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	g_pattern_param.scn_param.Own_Address_Type[0]	=	    HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
	g_pattern_param.scn_param.LE_Scan_Interval[0]	=	    HCI_CMD_PARAM_SCAN_INT_MAX & 0x00ff ;
	g_pattern_param.scn_param.LE_Scan_Interval[1]	=	   (HCI_CMD_PARAM_SCAN_INT_MAX  & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0]	=	        HCI_CMD_PARAM_SCAN_INT_MAX  & 0x00ff ;
	g_pattern_param.scn_param.LE_Scan_Window[1]	=	       (HCI_CMD_PARAM_SCAN_INT_MAX  & 0xff00) >> 8;

	verdict = COMM_SCN_Active_Scanning(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	g_pattern_param.adv_param.Own_Address_Type[0]	=	HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
    g_pattern_param.adv_param.Advertising_Interval_Min[0]=0xa0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1]=(0xa0 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Max[0]=0xa0 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1]=(0xa0 & 0xff00)	>> 8;

	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] =
		HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    memcpy(g_pattern_param.adv_param.Direct_Address , adv_random_addr, ADDR_LENGTH);

	verdict=COMM_ADV_Undirected_Advertising(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(1 , 0, 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1== read_le_event_get() )
		{
			//reset event flag
			//read_le_event_disable();
            MSLEEP(10);
			//event add
			adv_cnt++;
			//query adv_ind
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_,
										HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND,
															buf,g_pattern_param))
			{
                if (adv_cnt < 50){
                    adv_cnt ++;
                    continue;
                }
                else{
    				line=__LINE__;
    				goto FUN_FAIL;
                }
			}

			//query scan_rsp
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_,
										HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP,
															buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
//add address	check here ; adv_addr is right ?
			if( 0 != memcmp ( buf + _BT_HCI_EVT_ADV_RPT_ADDR0 , adv_random_addr , ADDR_LENGTH))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			//COMM_ADV_Disable_Config(dut1_fd,&g_pattern_param);
			//verdict=COMM_ADV_Disable(dut1_fd,g_pattern_param);
			//VERDICT_RESULT_WITH_LINE();

//sholud add item10 here

            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();
    
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.9.4.1
verdict SEC_SLA_Slave_Encryption_Mode_Setup (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut1 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[10]={0};
	u16 test_cnt1=1000;
	u16 test_cnt2=1000;
    u8 addr_type = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ; 
    //u8 addr_type = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS ; 

    int sla_pkt_chk ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

REPEAT:    

    if(addr_type == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

    	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    	//here use lowest ch to testing
    	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
    	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
    	VERDICT_RESULT_WITH_LINE();

    	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
    	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
    	VERDICT_RESULT_WITH_LINE();
    }else{

        // ###########################################################
        COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
        COMM_Device_Address_Set(dut1_fd,g_pattern_param);
        
        COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
        COMM_Device_Address_Set(dut2_fd,g_pattern_param);

        COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);

        memcpy(g_pattern_param.adv_param.Direct_Address, adv_random_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Own_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
        g_pattern_param.adv_param.Direct_Address[0]   = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;

        g_pattern_param.adv_param.Advertising_Interval_Min[0]=0xa0 & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1]=(0xa0 & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Max[0]=0xa0 & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1]=(0xa0 & 0xff00)   >> 8;


        //here use lowest ch to testing
        g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
        verdict=COMM_ADV_Undirected_Advertising(dut2_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        COMM_INI_Initiating_Config(dut1,&g_pattern_param);
        g_pattern_param.create_conn_param.Peer_Address_Type[0] = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
        memcpy(g_pattern_param.create_conn_param.Peer_Address ,adv_random_addr,ADDR_LENGTH );
        g_pattern_param.create_conn_param.Own_Address_Type[0]  =HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;

        verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{

            read_le_event_disable();
            
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
                printf("send cnt %d\n" , test_cnt1);
            
				COMM_Send_ACL_Data_Without_event(dut2_fd,conn_handles_sla,0b00,0,10,acl_data);
PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(10);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK1;
                
                }                 
                
                sla_pkt_chk = 0;
			
                usleep(SLEEP_MS);

    			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))
    			{
    				line=__LINE__;
    				goto FUN_FAIL;
    			}

    			if (0b10 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
    			{
    				line=__LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }


            }

			//######################################

            sleep(1);

			COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut2_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

				//######################################
			for ( ;test_cnt2 > 0 ; test_cnt2 --)
			{

                printf("send cnt %d\n" , test_cnt2);
            
				COMM_Send_ACL_Data_Without_event(dut2_fd,conn_handles_sla,0b00,0,10,acl_data);
PKT_CHK2:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
    
                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK2;
                
                }                 
                
                sla_pkt_chk = 0;


                usleep(SLEEP_MS);
    			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))
    			{
    				line=__LINE__;
    				goto FUN_FAIL;
    			}

    			if (0b10 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
    			{
    				line=__LINE__;
    				goto FUN_FAIL;
    			}
                
            }
			//######################################


            if (addr_type == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ){
                addr_type = HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS ; 

                buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
                buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
                
                COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
                verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();


                sleep(10);
                goto REPEAT ;
            }

            COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);

            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:

    FUNC_END();
    
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.9.4.2
verdict SEC_SLA_Slave_Pause_Encryption (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut1 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut2_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//##########################################

			COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut2_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

            COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);

            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();
    
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.9.4.3
verdict SEC_SLA_Slave_Pause_Encryption_Sending_Data (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut1 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[10]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

    int sla_pkt_chk = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut2_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//##########################################

			COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
			//should check timing

    		//sending data after start encryption
			//and in that state , the write cmd will not rsp the number of packets completed
			COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b00,0,10,acl_data);

			//should be nothing here !
			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))//step2 ~ 4
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (0x00 != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_]))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

            do{ 
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut2_fd);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change

			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))//step2 ~ 4
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			//should be something here!!
			if (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_]))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#if 1
PKT_CHK:
            // # check disconnection             
            CHECK_NON_DISCONNECT();

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);
                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                goto PKT_CHK;
            
            }                 
            
            sla_pkt_chk = 0;

#else
			//finally: the number of packets completed.
            do{
                ret=socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SOCKET_SUCCESS != ret)
				goto FUN_FAIL;
#endif

            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

            COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);

            FUNC_END();
            
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();
    
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.9.4.4
verdict SEC_SLA_Slave_Sending_Reject_Ind (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut1 =0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut2_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Negative_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Negative_Rep(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(_BT_HCI_EVT_CMD_COMP_STATUS_PIN_OR_KEY_MISSING != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

            COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);

            FUNC_END();


			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

    
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.9.4.5
verdict SEC_SLA_Slave_Receiving_Encrypted_Data (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut1 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[10]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	u8 test_cnt1=100;//100;

    int sla_pkt_chk = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut2_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b00,0,10,acl_data);

PKT_CHK:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
    
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK;
                
                }                 
                
                sla_pkt_chk = 0;



                usleep(100000);

    			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))
    			{
    				line=__LINE__;
    				goto FUN_FAIL;
    			}

    			if (0b10 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
    			{
    				line=__LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }


            }

            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

            COMM_Disconnect_Config(dut1, &g_pattern_param,buf);
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);

            FUNC_END();


			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.10.1.1
verdict SEC_MAS_Master_Encryption_Mode_Setup (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut2 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[10]={0};
	u8 test_cnt1=100;//100;
	u8 test_cnt2=100;//100;

    int mas_pkt_chk = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , adv_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut2,&g_pattern_param);	//dut 2 is master
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();

			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			//######################################

			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				COMM_Send_ACL_Data_Without_event(dut2_fd,conn_handles_sla,0b01,0,10,acl_data);

PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
    
                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK1;
                
                }                 
                
                mas_pkt_chk = 0;


			}

			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (0x01 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
#if 1
            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#else

			usleep(200000);

			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_LONG_TERM_KEY_REQUEST_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_ltk_request_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			for ( ;test_cnt2 > 0 ; test_cnt2 --)
			{

                COMM_Send_ACL_Data_Without_event(dut2_fd,conn_handles_sla,0b01,0,10,acl_data);

PKT_CHK2:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
    
                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK2;
                
                }                 
                
                mas_pkt_chk = 0;


			}

			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (0x01 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			//######################################


			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.10.1.2
verdict SEC_MAS_Master_Pause_Encryption (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut2 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , adv_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut2,&g_pattern_param);	//dut 2 is master
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
#if 1
            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#else
			usleep(200000);

			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_LONG_TERM_KEY_REQUEST_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_ltk_request_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//##########################################

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
#if 1
            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#else
			usleep(200000);

			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_LONG_TERM_KEY_REQUEST_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_ltk_request_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			sleep(1); //!!!! must waiting for dut timeout and send second LTK req
#endif
			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.10.1.3
verdict SEC_MAS_Master_Receiving_Reject_Ind (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut2 =0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , adv_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut2,&g_pattern_param);	//dut 2 is master
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Negative_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Negative_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(_BT_HCI_EVT_CMD_COMP_STATUS_UNSUPPROTED_REMOTE_FEATURE_LMP != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.10.1.4
verdict SEC_MAS_Master_Encryption_Sending_Data_Before_LL_ENC_RSP (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut2 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[10]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	u8 test_cnt1=1;//100;

    int mas_pkt_chk = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , adv_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut2,&g_pattern_param);	//dut 2 is master
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
            printf("Get Event(%d):\n",dut1_fd);
            print_charray(len,buf);
            if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

#if 1
			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b00,0,10,acl_data);
                
PKT_CHK1:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
    
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK1;
                
                }                 
                
                mas_pkt_chk = 0;


			}

			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (0b10 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#if 1
			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//##########################################

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
			//should check timing

            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b01,0,10,acl_data);

PKT_CHK2:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
    
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK2;
                
                }                 
                
                mas_pkt_chk = 0;


			}

			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (0b01 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change

			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))//step2 ~ 4
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			//should be something here!!
			if (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_]))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

// 5.10.1.6
verdict SEC_MAS_Master_Encryption_Setup_Missing_Response (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut2 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , adv_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut2,&g_pattern_param);	//dut 2 is master
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			//conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Reset(dut1_fd);

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
#if 0
            do{
                ret=socket_msg_get(dut_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			sleep(40) ; //more time to wait supervistion TO

			if (SUCCESS != QUERY_Event(dut2_fd,buf ,
										_BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			hci_event_disconnection_complete_parsing(0,buf,g_pattern_param);
			if(_BT_HCI_EVT_CMD_COMP_STATUS_RESPONSE_TIMEOUT
				!= buf[_BT_HCI_EVT_DISCONN_COMP_REASON])
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#if 0
			if( !=
				hci_event_disconnection_complete_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
#if 0
			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//##########################################

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
			//should check timing

            do{
                ret=socket_msg_get(dut_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				verdict=COMM_Send_ACL_Data(dut1_fd,conn_handles_sla,0b01,0,10,acl_data);
				VERDICT_RESULT_WITH_LINE();
			}

			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (0b01 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change

			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))//step2 ~ 4
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			//should be something here!!
			if (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_]))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.10.1.7
verdict SEC_MAS_Master_Encryption_Setup_Missing_Request (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict=FAIL;
	int dut2 = 0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , adv_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut2,&g_pattern_param);	//dut 2 is master
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			//conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
#if 0
            do{
                ret=socket_msg_get(dut_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			sleep(40) ; //more time to wait supervistion TO

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

#if 0
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,
										_BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			hci_event_disconnection_complete_parsing(0,buf,g_pattern_param);
			if(_BT_HCI_EVT_CMD_COMP_STATUS_RESPONSE_TIMEOUT
				!= buf[_BT_HCI_EVT_DISCONN_COMP_REASON])
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
#if 0
			if( !=
				hci_event_disconnection_complete_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
#if 0
			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//##########################################

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
			//should check timing

            do{
                ret=socket_msg_get(dut_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				verdict=COMM_Send_ACL_Data(dut1_fd,conn_handles_sla,0b01,0,10,acl_data);
				VERDICT_RESULT_WITH_LINE();
			}

			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (0b01 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change

			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))//step2 ~ 4
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			//should be something here!!
			if (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_]))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


// 5.10.1.11
verdict SEC_MAS_Master_Pause_Encryption_Sending_Data (u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int dut2 =0;
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 acl_data[10]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

    int mas_pkt_chk = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
	memcpy (g_pattern_param.adv_param.Direct_Address , adv_addr , ADDR_LENGTH);//should be peer addr!!!
	//here use lowest ch to testing
	g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
	verdict=COMM_ADV_Directed_Advertising(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut2,&g_pattern_param);	//dut 2 is master
	memcpy(g_pattern_param.create_conn_param.Peer_Address ,scan_addr,ADDR_LENGTH );
	verdict=COMM_INI_Initiating(dut2_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut2_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
#if 1
            do{
                socket_msg_get(dut1_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			print_charray(len,buf);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b01,0,10,acl_data);
PKT_CHK:
            // # check disconnection             
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);
                mas_pkt_chk ++ ;
                if (mas_pkt_chk == 100){
                    printf("mas no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                goto PKT_CHK;
            
            }                 
            
            mas_pkt_chk = 0;


			sleep(40) ; //more time to wait supervistion TO

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

#if 0
			if (SUCCESS != QUERY_Event(dut2_fd,buf ,
										_BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			hci_event_disconnection_complete_parsing(0,buf,g_pattern_param);
			if(_BT_HCI_EVT_CMD_COMP_STATUS_RESPONSE_TIMEOUT
				!= buf[_BT_HCI_EVT_DISCONN_COMP_REASON])
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
#if 0
			if( !=
				hci_event_disconnection_complete_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
#if 0
			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change
			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			//##########################################

			COMM_Start_Encryption_Config(dut2_fd,&g_pattern_param, conn_handles_mas);
			verdict=COMM_Start_Encryption(dut2_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();
			//should check timing

            do{
                ret=socket_msg_get(dut_fd,&len,buf);
            }while(len <=0);
			printf("Get Event(%d):\n",dut1_fd);
			if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				verdict=COMM_Send_ACL_Data(dut1_fd,conn_handles_sla,0b01,0,10,acl_data);
				VERDICT_RESULT_WITH_LINE();
			}

			if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (0b01 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			COMM_Ltk_Req_Rep_Config(dut1_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
			verdict=COMM_Ltk_Req_Rep(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

			sleep(1); //waiting encryption change

			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))//step2 ~ 4
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			//should be something here!!
			if (0xFF != (buf [_BT_HCI_IDX_ACL_DATA_PAYLOAD_]))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}


			if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0,buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
#endif
			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

verdict PROF_Heart_Rate_1(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //first 30 sec , adv 20ms , scan 30ms
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (48/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (48/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	//The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
	//interval : 32(0x0020) * 0.625ms = 20ms
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****wait for 30 sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(30/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            // the ideal value : 30(s) / 30(ms) = 1000
            if (((float)((adv_cnt * 100) / (1000/time_reduce))) <= 50) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1000/time_reduce);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / 1000/time_reduce));
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]FAIL, Counter : %d\n", __FUNCTION__, adv_cnt);
    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1000/time_reduce);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / 1000/time_reduce));
    
    return FAIL;

}

verdict PROF_Heart_Rate_2(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //sec 30 sec , adv 20ms , scan win 11.25ms , scan int 2.56s
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  4096/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (4096/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 18/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (18/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	//The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
	//interval : 32(0x0020) * 0.625ms = 20ms
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 30sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(30/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            // the ideal value : 30(s) / 30(ms) = 1000
            if (adv_cnt <= 4) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 4);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 4);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}

verdict PROF_Heart_Rate_3(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //3nd , adv 1s , scan 30ms
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (48/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (48/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	//The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
	//interval : 32(0x0020) * 0.625ms = 20ms
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (1600 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (1600 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****wait for 30 sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(30/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            // the ideal value : 30(s)/1(s)30
            if (adv_cnt <= 24) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 24);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 24);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}


verdict PROF_Heart_Rate_4(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //4th , adv 1s , scan win 11.25ms , scan int 2.56s
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  4096/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (4096/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 18/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (18/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	//The timing range detected for advertising events(ADV_IND) is from 20.0 ms to 30.0 ms
	//interval : 32(0x0020) * 0.625ms = 20ms
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (1600 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (1600 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****wait for 30 sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(600/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            // the ideal value : 
            if (adv_cnt <= 1) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}

verdict PROF_HID_1(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //1st fast-180, adv 30ms , scan win 11.25ms , scan int 22.5ms
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  36/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (36/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 18/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (18/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;

	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  48 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (48 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  48 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (48 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 180sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(180/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}
            
            // # per 22.5ms * 3 can get 1 adv , run 180s
            if (adv_cnt <= (180000/67.5)*(2)*(11.25/22.5)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (180000/67.5)*(2)*(11.25/22.5)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (180000/67.5)*(2)*(11.25/22.5)*0.8);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}

verdict PROF_HID_2(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //2nd adv int 30ms ; scan int 1.28 s ,win 11.25ms"
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  2048/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (2048/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 18/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (18/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;

	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  48 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (48 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  48 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (48 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 30sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(30/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            if (adv_cnt <= 5) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 5);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 5);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}

verdict PROF_HID_3(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //3rd adv int 30ms ; scan int 30ms ,win 30mms"
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (48/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (48/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;

	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  48 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (48 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  48 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (48 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 30sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(30/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            if (adv_cnt <= (30*30)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30*30)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30*30)*0.8);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}

verdict PROF_HID_4(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 dir_adv_cnt = 0;
    u32 adv_cnt     = 0;
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //4nd dir-adv+undir-adv int 20ms ; scan int 22.5ms ,win 11.25ms"

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  36/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (36/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 18/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (18/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  6 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (6 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  6 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (6 & 0xff00) >> 8;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();     

	read_le_event_enable();
	printf("****timer for 1.3sec****\n" );
    
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :1.3 sec
		    event_query_timer_config(1, 300000, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);

		    while(read_le_event_get()) {
                //usleep(1*1000);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {								    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf,g_pattern_param)) {    				
    				continue;
    			}
    			else {
    				dir_adv_cnt++; 
                    printf("adv coming, chk %d\n" , dir_adv_cnt);
    			}    					
    		}

            // the ideal value :
            // # per 3.75ms get (1*11.25/22.5) adv ,run 1.28s 
            if (dir_adv_cnt <= (11.25/3.75)*(1280/22.5)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                //FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, dir_adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (11.25/3.75)*(1280/22.5)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, dir_adv_cnt);
            }    		
            break;
    		//return PASS;
		}
    }	


	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;

	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  32& 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (32 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  32 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (32 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 30sec****\n" );
    
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {

		    event_query_timer_config(30, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);

		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {								    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            // # per 22.5ms can get (1*11.25/22.5) adv , run 30s
            if (adv_cnt <= (30000/22.5)*(11.25/22.5)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30000/22.5)*(11.25/22.5)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	



FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30000/22.5)*(11.25/22.5)*0.8);
    LOG_INFO("[Pattern][%s] Exp. value : %d %d\n", __FUNCTION__, adv_cnt , dir_adv_cnt);
    
    return FAIL;

}

verdict PROF_HID_5(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 dir_adv_cnt = 0;
    u32 adv_cnt     = 0;
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //5nd dir-adv+undir-adv int 20ms ; scan int 1.28s ,win 11.25ms"

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  2048/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (2048/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 18/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (18/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  6 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (6 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  6 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (6 & 0xff00) >> 8;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();     

	read_le_event_enable();
	printf("****timer for 1.3sec****\n" );
    
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :1.3 sec
		    event_query_timer_config(1, 300000, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);

		    while(read_le_event_get()) {
                //usleep(1*1000);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {								    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf,g_pattern_param)) {    				
    				continue;
    			}
    			else {
    				dir_adv_cnt++; 
                    printf("adv coming, chk %d\n" , dir_adv_cnt);
    			}    					
    		}

            // the ideal value :
            // # only 
            if (dir_adv_cnt <= (11.25/3.75)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                //FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, dir_adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (11.25/3.75)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, dir_adv_cnt);

            }    		
            break;
    		//return PASS;
		}
    }	


	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;

	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  32& 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (32 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  32 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (32 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 30sec****\n" );
    
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {

		    event_query_timer_config(30, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);

		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {								    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            // # per 22.5ms can get (1*11.25/22.5) adv , run 30s
            if (adv_cnt <= 7) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 7);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	



FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 7);
    LOG_INFO("[Pattern][%s] Exp. value : %d %d\n", __FUNCTION__, adv_cnt , dir_adv_cnt);
    
    return FAIL;

}


verdict PROF_HID_6(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 dir_adv_cnt = 0;
    u32 adv_cnt     = 0;
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //6nd dir-adv+undir-adv int 20ms ; scan int 30ms ,win 30ms"

	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (48/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (48/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  6 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (6 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  6 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (6 & 0xff00) >> 8;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();     

	read_le_event_enable();
	printf("****timer for 1.3sec****\n" );
    
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :1.3 sec
		    event_query_timer_config(1, 300000, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);

		    while(read_le_event_get()) {
                //usleep(1*1000);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {								    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf,g_pattern_param)) {    				
    				continue;
    			}
    			else {
    				dir_adv_cnt++; 
                    printf("adv coming, chk %d\n" , dir_adv_cnt);
    			}    					
    		}
            // # per 30ms get 1 adv ,run 1.28s 

            if (dir_adv_cnt <= (1280/30)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                //FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, dir_adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (1280/30)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, dir_adv_cnt);
                sleep(1);
            }    		
            break;
    		//return PASS;
		}
    }	


	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  32& 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (32 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  32 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (32 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 30sec****\n" );
    
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :1.3 sec
		    event_query_timer_config(30, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);

		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {								    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            // the ideal value :
            // # per 30ms get 1 adv
            if (adv_cnt <= (30000/30)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30000/30)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	



FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30000/30)*0.8);
    LOG_INFO("[Pattern][%s] Exp. value : %d %d\n", __FUNCTION__, adv_cnt , dir_adv_cnt);
    
    return FAIL;

}


verdict PROF_HID_7(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //7nd adv int 1s ; scan int 22.5ms ,win 11.25ms"
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  36/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (36/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 18/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (18/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;

	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (1600 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (1600 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 30sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(30/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            //# per 1s get 1 adv * 11.25/22.5
            if (adv_cnt <= (30)*(11.25/22.5)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30)*(11.25/22.5)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30)*(11.25/22.5)*0.8);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}

verdict PROF_HID_8(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //8nd adv int 1s ; scan int 1.28s ,win 11.25 ms"
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  2048/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (2048/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 18/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (18/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (1600 & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (1600 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 300sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(300/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            if (adv_cnt < 1) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}


verdict PROF_HID_9(u8 dut1_fd, u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];	
	int verdict = FAIL;
	int dut1 = 0;
	u16 line = 0;
	struct itimerval timer;	
	u32 adv_cnt = 0;	  
    u16 time_reduce = 1;
    
    Calculate_Execution_Time_Start();

    //9nd adv int 1s ; scan int 30ms ,win 30mms"
    
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (48/time_reduce & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =	 48/time_reduce & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (48/time_reduce & 0xff00) >> 8;

	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_data_param.Advertising_Data_Length[0] = 0x00;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Max[1] = (1600& 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Interval_Min[0] =  1600 & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1] = (1600 & 0xff00) >> 8;
	verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	read_le_event_enable();
	printf("****timer for 30sec****\n" );
	while(1) {//waiting adv report event , timer or counter  
		if(1 == read_le_event_get()) {
		    // start the scanning time :30 sec
		    event_query_timer_config(30/time_reduce, 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);
		    while(read_le_event_get()) {
                MSLEEP(10);
			    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {				
				    
				    
				    continue;
			    }
    			else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf,g_pattern_param)) {
    				
    				continue;
    			}
    			else {
    				adv_cnt++; 
                    printf("adv coming, chk %d\n" , adv_cnt);
    			}    					
    		}

            if (adv_cnt <= (30)*0.8) {
                line=__LINE__;
    			goto FUN_FAIL;
            }
            else {

                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS, Counter : %d\n", __FUNCTION__, adv_cnt);
    		    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30)*0.8);
    		    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
            }    		

    		return PASS;
		}
    }	
FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    LOG_INFO("[Pattern][%s]Ideal value : %f\n", __FUNCTION__, (30)*0.8);
    LOG_INFO("[Pattern][%s] Exp. value : %d\n", __FUNCTION__, adv_cnt);
    
    return FAIL;

}

verdict Adv_time_indep_all_param_check_with_adv_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_TIME_IND_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int adv_intval_cnt    = 0 ;
    int adv_intval_step   = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 0.625ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = g_adv_param_adv_type_step;      // #param
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = ADV_CH_MAP_TBL_ROW ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = g_adv_param_adv_data_len_step ; // # param

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    int addr_filter_policy_step = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set =     &(g_pattern_param.adv_param);
    Scn_param * scn_param_set =     &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int adv_collect_cnt = g_adv_param_adv_collect_cnt ;    // #param
    int adv_error_cnt   = 0 ;

    Calculate_Execution_Time_Start();
 
    // # conbine adv params
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ; 
          adv_type_cnt < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt += adv_type_step){          

    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX;
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){

    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

    for ( ; addr_filter_policy_cnt < HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY
          ; addr_filter_policy_cnt += addr_filter_policy_step){
          
        int direct_adv_check = 0 ;

        do{
            // # config whether use random address  
            COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);

            COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
            COMM_Device_Address_Set(dut2_fd, g_pattern_param);    
            
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS) ;

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n",adv_ch_map_tbl[adv_ch_map_cnt][0] ,adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }else{

                    LOG_INFO("dir random type \n");
                    memcpy (adv_param_set->Direct_Address , scan_random_addr , ADDR_LENGTH);

                }
                
                dir_addr_type_cnt ++ ;                        
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
    	        adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            // # config scan verify param

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

            // # scan_intval large than 2 * adv_intval
            u64 scan_intval = 0;
            scan_intval =   ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);
            scn_param_set->LE_Scan_Type[0]        =   HCI_CMD_PARAM_PASSIVE_SCAN;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;

            //# should depend on the direct_ind : initA type
            u8 own_addr_cond = 0;
            own_addr_cond = (adv_param_set->Advertising_Type[0] == HCI_CMD_PARAM_ADV_DIRECT_IND ) &&
                            (adv_param_set->Direct_Address_Type[0] == HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS);
            
            if (own_addr_cond){
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            }
            else{
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            }

            LOG_INFO(" scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);
            scn_param_set->Scanning_Filter_Policy[0] =    HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

            *scn_enable = HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int adv_cnt   = 0 ;

            while(read_le_event_get()) {

                MSLEEP(1);

                if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                    // # force continue start direct_ind adv without check return value
                    COMM_ADV_Advertising(dut2_fd);                    
                    MSLEEP(10);
                }

                // # query adv_rpt       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , adv_param_set->Advertising_Type[0])) {               
                                    
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                adv_param_set->Advertising_Type[0] , 
                                buf , 
                                g_pattern_param)) {
                                
                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){
                        if((++cnt % 1000) == 0)
                            printf("No adv rpt data [%d]\n" , cnt);
                        //continue;
                    }else{
                        printf("some bytes error\n");                        
                        adv_error_cnt ++ ;
                    }
                    
                }
                else {
                    adv_cnt ++; 
                    printf("adv coming, cnt %d\n" , adv_cnt);
                }


                if (adv_cnt == adv_collect_cnt){
                    LOG_INFO("adv_collect_cnt = %d| adv_err_cnt = %d\n" , adv_collect_cnt , adv_error_cnt);
                    LOG_INFO("\n")
                    break ;
                }
                
            }

            cnt = 0;
            adv_error_cnt = 0;

            // # to check the result
            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

        printf("\n");
    }
        addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;

}

verdict Adv_time_indep_all_param_check_with_scn_rsp(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;
    u16 cnt  = 0;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
    ADV_TIME_IND_PATTERN_CONFIG_READ();
    
    struct itimerval timer;

    int adv_intval_cnt    = 0 ;
    int adv_intval_step   = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 0.625ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = g_adv_param_adv_type_step;          // #param

    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = ADV_CH_MAP_TBL_ROW ;
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = HCI_CMD_PARAM_ADV_DATA_LEN_MAX ;

    int scn_rsp_check     = 0 ;
    int scn_data_len_cnt  = 0 ;
    int scn_data_len_step = g_adv_param_scn_rsp_data_len_step ; // # param

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    int addr_filter_policy_step = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set     = &(g_pattern_param.adv_param);
    Scn_param * scn_param_set     = &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int scn_rsp_collect_cnt = g_adv_param_scn_rsp_collect_cnt ;    // #param
    int scn_rsp_error_cnt   = 0;

    Calculate_Execution_Time_Start();

    // # conbine adv params
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ; 
          adv_type_cnt < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt += adv_type_step){          

        scn_rsp_check = 
           (adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_IND) || 
           (adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_SCAN_IND) ;

        if( 0 == scn_rsp_check){
               continue;
        }


    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX; 
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){

    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; scn_data_len_cnt <= HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX
          ; scn_data_len_cnt += scn_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

    for ( ; addr_filter_policy_cnt < HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY
          ; addr_filter_policy_cnt += addr_filter_policy_step){
          
        int direct_adv_check = 0 ;

        do{
            COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);

            COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
            COMM_Device_Address_Set(dut2_fd, g_pattern_param);    

            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS) ;

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n",adv_ch_map_tbl[adv_ch_map_cnt][0] ,adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("scn_data_len_cnt %d \n", scn_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0] =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }else{

                    LOG_INFO("dir random type \n");
                    memcpy (adv_param_set->Direct_Address , scan_random_addr , ADDR_LENGTH);

                }
                
                dir_addr_type_cnt ++ ;                        
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            // # config scn rsp data
            scn_data_set->Scan_Response_Data_Length[0]  =  scn_data_len_cnt;

            data_len_idx = 0;
            
            for ( ; data_len_idx < scn_data_len_cnt  ; data_len_idx ++){
                scn_data_set->Scan_Response_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            // # config scan verify param

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

            // # scan_intval large than 2 * adv_intval
            u64 scan_intval = 0;
            scan_intval =   ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);
            scn_param_set->LE_Scan_Type[0]        =   HCI_CMD_PARAM_ACTIVE_SCAN;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;

            //# should depend on the direct_ind : initA type
            u8 own_addr_cond = 0;
            own_addr_cond = (adv_param_set->Advertising_Type[0] == HCI_CMD_PARAM_ADV_DIRECT_IND ) &&
                            (adv_param_set->Direct_Address_Type[0] == HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS);
            
            if (own_addr_cond){
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            }
            else{
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            }

            LOG_INFO(" scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);
            scn_param_set->Scanning_Filter_Policy[0] =    HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

            *scn_enable = HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int scn_rsp_cnt = 0;

            while(read_le_event_get()) {

                MSLEEP(1);

                // # query scn_rsp       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {               
                                    
                    continue;
                }
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP , 
                                buf , 
                                g_pattern_param)) {
                                
                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){           
                        if((++cnt % 1000) == 0)
                            printf("No scn rsp data [%d]\n" , cnt);
                        //continue;
                    }else{
                        printf("some bytes error\n");
                        scn_rsp_error_cnt ++ ;
                    }
                    
                }
                else {
                    scn_rsp_cnt ++; 
                    printf("scn rsp coming, cnt %d\n" , scn_rsp_cnt);               
                }

                if (scn_rsp_cnt == scn_rsp_collect_cnt){
                    LOG_INFO("scn_rsp_collect_cnt = %d | scn_rsp_error_cnt = %d\n" , scn_rsp_collect_cnt , scn_rsp_error_cnt);                        
                    LOG_INFO("\n")

                    break;
                }
                
            }

            cnt = 0;
            scn_rsp_error_cnt = 0;

            // # to check the result
            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

        printf("\n");
    }
        addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# scn_data_len_cnt
        scn_data_len_cnt = 0;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Adv_time_indep_filter_check_with_scn_req(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_TIME_IND_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int adv_intval_cnt    = 0 ;
    int adv_intval_step   = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 0.625ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = g_adv_param_adv_type_step ;             // # param
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = ADV_CH_MAP_TBL_ROW ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = HCI_CMD_PARAM_ADV_DATA_LEN_MAX ;

    int scn_data_len_cnt  = 0 ;
    int scn_data_len_step = HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX ;

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    int addr_filter_policy_step = g_adv_param_adv_filter_policy_step; // #param

    int conf_white_list_cnt = CONFIG_DISABLE ;

    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set     = &(g_pattern_param.adv_param);
    Scn_param * scn_param_set     = &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int time_out            = g_adv_param_time_out;              // #param
    int scn_rsp_collect_cnt = g_adv_param_scn_rsp_collect_cnt;   // #param
    int scn_rsp_error_cnt   = 0;

    Calculate_Execution_Time_Start();

    // # config whitelist or not
    for (  ; 
           conf_white_list_cnt < CONFIG_FORBID;
           conf_white_list_cnt ++ ){

    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ; 
          adv_type_cnt < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt += adv_type_step){          

    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX; 
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){

    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; scn_data_len_cnt <= HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX
          ; scn_data_len_cnt += scn_data_len_step){

    for ( ; own_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

    for ( ; addr_filter_policy_cnt <= HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY
          ; addr_filter_policy_cnt += addr_filter_policy_step){
          
        int direct_adv_check = 0 ;

        do{
            // # config whether use random address  
            COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);

            COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
            COMM_Device_Address_Set(dut2_fd, g_pattern_param);    

            if( conf_white_list_cnt == CONFIG_ENABLE){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
            }  
            
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS) ;

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("\nconf_white_list_cnt %d \n" , conf_white_list_cnt);
            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n",adv_ch_map_tbl[adv_ch_map_cnt][0] ,adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("scn_data_len_cnt %d \n", scn_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }else{

                    LOG_INFO("dir random type \n");
                    memcpy (adv_param_set->Direct_Address , scan_random_addr , ADDR_LENGTH);

                }
                
                dir_addr_type_cnt ++ ;                        
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            // # config scn rsp data
            scn_data_set->Scan_Response_Data_Length[0]  =  scn_data_len_cnt;

            data_len_idx = 0;
            
            for ( ; data_len_idx < scn_data_len_cnt  ; data_len_idx ++){
                scn_data_set->Scan_Response_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            // # config scan verify param
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

            // # scan_intval large than 2 * adv_intval
            u64 scan_intval = 0;
            scan_intval =   ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);
            scn_param_set->LE_Scan_Type[0]        =   HCI_CMD_PARAM_ACTIVE_SCAN;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;

            //# should depend on the direct_ind : initA type
            u8 own_addr_cond = 0;
            own_addr_cond = (adv_param_set->Advertising_Type[0] == HCI_CMD_PARAM_ADV_DIRECT_IND ) &&
                            (adv_param_set->Direct_Address_Type[0] == HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS);
            
            if (own_addr_cond){
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            }
            else{
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            }

            LOG_INFO(" scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);

            scn_param_set->Scanning_Filter_Policy[0] =    HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

            *scn_enable = HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int scn_rsp_cnt = 0;

            struct timeval start_time;                      
            struct timeval current_time;                      

            gettimeofday(&start_time,NULL);
            printf("+++ %ld %ld +++\n",start_time.tv_sec ,start_time.tv_usec);

            while(read_le_event_get()) {

                MSLEEP(1);

                if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                    // # force continue start direct_ind adv without check return value
                    COMM_ADV_Advertising(dut2_fd);                    
                    MSLEEP(10);
                }
                
                // # query scn_rsp       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {               
                                    
                    continue;
                }
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP , 
                                buf , 
                                g_pattern_param)) {
                                
                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){           
                        if((++cnt % 1000) == 0)
                            printf("No scn rsp data [%d]\n" , cnt);
                        //continue;
                    }else{
                        printf("some bytes error\n");
                        scn_rsp_error_cnt ++ ;
                    }
                    
                }
                else {
                    scn_rsp_cnt ++; 
                    printf("scn rsp coming, cnt %d\n" , scn_rsp_cnt);                
                }                              

                gettimeofday(&current_time,NULL);
                
                if ((scn_rsp_cnt == scn_rsp_collect_cnt ) || 
                   ((current_time.tv_sec - start_time.tv_sec) >= time_out)){

                    LOG_INFO("scn_rsp_cnt = %d | scn_rsp_error_cnt = %d\n" , 
                              scn_rsp_cnt , scn_rsp_error_cnt);                        
                    LOG_INFO("\n")
                
                    break;
                }
            }
            
            // # check the result according the policy.
            switch(addr_filter_policy_cnt){
                case HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY :
                case HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_ANY_AND_CONN_REQ_FROM_WHITELIST_ONLY:

                        if(scn_rsp_cnt != 0){
                            // # those two adv type not allow scan_req pdu
                            if ((adv_test_params[adv_type_cnt].adv_type  == HCI_CMD_PARAM_ADV_DIRECT_IND) || 
                                (adv_test_params[adv_type_cnt].adv_type  == HCI_CMD_PARAM_ADV_NONCONN_IND)){
                                
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                        }                    
                        break;
                        
                case HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY:
                case HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY:

                        if(scn_rsp_cnt != 0){                            
                            // # scan rsp will coming with config white list
                            if(conf_white_list_cnt != CONFIG_ENABLE){                        
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                        }                    
                        break;
            }

            cnt = 0;
            scn_rsp_error_cnt = 0;
                    
            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

        printf("\n");
    }
        addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# scn_data_len_cnt
        scn_data_len_cnt = 0;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    
        adv_type_cnt = 0;
    }

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Adv_time_indep_filter_check_with_conn_req(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_TIME_IND_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int adv_intval_cnt    = 0 ;
    int adv_intval_step   = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 0.625ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = g_adv_param_adv_type_step ;             // # param
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = ADV_CH_MAP_TBL_ROW ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = HCI_CMD_PARAM_ADV_DATA_LEN_MAX + 1 ;

    int scn_data_len_cnt  = 0 ;
    int scn_data_len_step = HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX + 1;

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    int addr_filter_policy_step = g_adv_param_adv_filter_policy_step; // #param

    int conf_white_list_cnt = CONFIG_DISABLE ;

    u8 * adv_enable               = g_pattern_param.Advertising_Enable ;
    
    Adv_param * adv_param_set     = &(g_pattern_param.adv_param);

    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int time_out              = g_adv_param_time_out;              // #param
    int conn_req_collect_cnt  = g_adv_param_conn_req_collect_cnt ; // #param
    int conn_comp_collect_cnt = 0;

    Calculate_Execution_Time_Start();

    // # config whitelist or not
    for (  ; 
           conf_white_list_cnt < CONFIG_FORBID;
           conf_white_list_cnt ++ ){

    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ; 
          adv_type_cnt < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt += adv_type_step){          

    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX; 
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){

    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; scn_data_len_cnt <= HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX
          ; scn_data_len_cnt += scn_data_len_step){

    for ( ; own_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

    for ( ; addr_filter_policy_cnt <= HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY
          ; addr_filter_policy_cnt += addr_filter_policy_step){

        int loop_cnt = conn_req_collect_cnt ;
        
    for ( ; loop_cnt > 0
          ; loop_cnt -- ){
          
        int direct_adv_check = 0 ;

        do{

            COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);

            COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
            COMM_Device_Address_Set(dut2_fd, g_pattern_param);    

            if( conf_white_list_cnt == CONFIG_ENABLE){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);

                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
            }

            COMM_INI_Initiating_Config(dut1_fd, &g_pattern_param);
            //memcpy(g_pattern_param->create_conn_param.Peer_Address ,adv_addr,ADDR_LENGTH );
            if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                //LOG_INFO("### initiator public addr");
                g_pattern_param.create_conn_param.Own_Address_Type[0]        =HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            }else{
                //LOG_INFO("### initiator random addr");
                g_pattern_param.create_conn_param.Own_Address_Type[0]        =HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            }
            verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();

            
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS) ;

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("\nconf_white_list_cnt %d \n" , conf_white_list_cnt);
            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n",adv_ch_map_tbl[adv_ch_map_cnt][0] ,adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("scn_data_len_cnt %d \n", scn_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }else{

                    LOG_INFO("dir random type \n");
                    memcpy (adv_param_set->Direct_Address , scan_random_addr , ADDR_LENGTH);

                }
                
                dir_addr_type_cnt ++ ;                        
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            // # config scn rsp data
            scn_data_set->Scan_Response_Data_Length[0]  =  scn_data_len_cnt;

            data_len_idx = 0;
            
            for ( ; data_len_idx < scn_data_len_cnt  ; data_len_idx ++){
                scn_data_set->Scan_Response_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();
            printf("run\n");

            LOG_INFO("\n");

             
            // # to collect the result
            read_le_event_enable();

            int conn_comp_cnt = 0;

            struct timeval start_time;                      
            struct timeval current_time;                      

            gettimeofday(&start_time,NULL);
            printf("+++ %ld %ld +++\n",start_time.tv_sec ,start_time.tv_usec);


            while(read_le_event_get()) {

                MSLEEP(10);

                // # query conn complete
                if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                    continue;                
                }
                else if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                    //continue;
                }
                else {
                    conn_comp_cnt ++;
                    conn_comp_collect_cnt ++ ;
                    printf("conn complete coming, cnt %d\n" , conn_comp_cnt);                
                }   

                gettimeofday(&current_time,NULL);
                
                if ((conn_comp_cnt == 1 ) || 
                   ((current_time.tv_sec - start_time.tv_sec) >= time_out)){
                
                    LOG_INFO("conn_comp_collect_cnt = %d \n" , conn_comp_collect_cnt );                        
                    LOG_INFO("\n")
                    sleep(1);
                    break;
                }                
                        
            }

            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

        printf("\n");
    }// # loop_cnt

    // # check the result according the policy.

    // # The Advertising_Filter_Policy parameter shall be ignored when 
    // directed advertising is enabled.
    
    if (adv_type_cnt == HCI_CMD_PARAM_ADV_DIRECT_IND){
        if(conn_comp_collect_cnt != (2*conn_req_collect_cnt)){
            LOG_INFO("fail : conn_comp_cnt %d \n" , conn_comp_collect_cnt);
            line = __LINE__;
            goto FUN_FAIL;
        }
        
    }else{
        switch(addr_filter_policy_cnt){
            case HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY :
            case HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_ANY:

                    if ((adv_test_params[adv_type_cnt].adv_type  == HCI_CMD_PARAM_ADV_NONCONN_IND) || 
                        (adv_test_params[adv_type_cnt].adv_type  == HCI_CMD_PARAM_ADV_SCAN_IND)){

                        if(conn_comp_collect_cnt != 0){
                            // # those two adv type not allow conn_req pdu                                
                            LOG_INFO("fail : conn_comp_cnt %d \n" , conn_comp_collect_cnt);
                            line = __LINE__;
                            goto FUN_FAIL;

                            break ;
                        }    
                    }else if(conn_comp_collect_cnt != conn_req_collect_cnt){
                        LOG_INFO("fail : conn_comp_cnt %d \n" , conn_comp_collect_cnt);
                        line = __LINE__;
                        goto FUN_FAIL;
                    }                    
                    break;
        
            case HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_ANY_AND_CONN_REQ_FROM_WHITELIST_ONLY:                        
            case HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY:

                    if (conf_white_list_cnt == CONFIG_ENABLE){
                        
                        if ((adv_test_params[adv_type_cnt].adv_type  == HCI_CMD_PARAM_ADV_NONCONN_IND) || 
                            (adv_test_params[adv_type_cnt].adv_type  == HCI_CMD_PARAM_ADV_SCAN_IND)){
                        
                            if(conn_comp_collect_cnt != 0){
                                // # those two adv type not allow conn_req pdu                                
                                LOG_INFO("fail : conn_comp_cnt %d \n" , conn_comp_collect_cnt);
                                line = __LINE__;
                                goto FUN_FAIL;
                        
                                break ;
                            }    
                        }else if(conn_comp_collect_cnt != conn_req_collect_cnt){
                            LOG_INFO("fail : conn_comp_cnt %d \n" , conn_comp_collect_cnt);
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                    
                        break;


                    }else{

                        if(conn_comp_collect_cnt > 0){                            
                            LOG_INFO("fail : conn_comp_cnt %d \n" , conn_comp_collect_cnt);
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                    
                        break;
                    }
                
        }
    }
        conn_comp_collect_cnt = 0;
    
    }
        addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# scn_data_len_cnt
        scn_data_len_cnt = 0;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    
        adv_type_cnt = 0;
    }

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Adv_time_dep_advint_chmap_check_ex_dir_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_TIME_DEP_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int query_time      = g_adv_param_query_time ;     //param
    int success_rate    = g_adv_param_success_rate;    //param
    int scan_intval_set = g_adv_param_scn_intval;      //param 10.24s
    
    int adv_intval_cnt  = 0 ;
    int adv_intval_step = g_adv_param_adv_intval_step ; // # 1 = 0.625ms ; 16 = 10ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = 1 ;
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = 1 ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = HCI_CMD_PARAM_ADV_DATA_LEN_MAX + 1 ;

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set     = &(g_pattern_param.adv_param);
    Scn_param * scn_param_set     = &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int adv_ideal_cnt   = 0 ;
    int adv_error_cnt   = 0 ;

    Calculate_Execution_Time_Start();

    // # conbine adv params
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ;
          adv_type_cnt < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt += adv_type_step ){          

        // # exclusive adv_dir_ind
        if(adv_type_cnt == HCI_CMD_PARAM_ADV_DIRECT_IND){
            continue;
        }

    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX; 
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){
           
    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

        int direct_adv_check = 0 ;
        
        do{

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
           
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS) ;
    
            adv_ideal_cnt = CALC_ADV_CNT(query_time , adv_intval_cnt + ADV_AVG_DELAY_MS  ,success_rate);
#if 0
            float x = ((float)(query_time*1000) / (float)((adv_intval_cnt + ADV_AVG_DELAY_MS) * 0.625));
            float y = x* (float)(success_rate/100);
            float z = y* ((float)adv_ch_map_tbl[adv_ch_map_cnt][1] / (float)CH_NUM_MAX);

            LOG_INFO("%f %f %f \n" , x ,y ,z);
            while(1){};
#endif
            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map_cnt %d \n", adv_ch_map_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n", adv_ch_map_tbl[adv_ch_map_cnt][0] 
                                              , adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }
             
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            // # config scan verify param
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

  
            // # scan_intval large than 2 * adv_intval
            int scan_intval = 0;
            scan_intval = scan_intval_set ;  
#if 0
                ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);
#endif
            scn_param_set->LE_Scan_Type[0]        =   HCI_CMD_PARAM_PASSIVE_SCAN;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;

            //# should depend on the direct_ind : initA type
            u8 own_addr_cond = 0;
            own_addr_cond = (adv_param_set->Advertising_Type[0] == HCI_CMD_PARAM_ADV_DIRECT_IND ) &&
                            (adv_param_set->Direct_Address_Type[0] == HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS);
            
            if (own_addr_cond){
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            }
            else{
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            }

            LOG_INFO(" scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);

            scn_param_set->Scanning_Filter_Policy[0] =    HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

            *scn_enable = HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int adv_cnt   = 0 ;

		    event_query_timer_config( query_time , 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);


            while(read_le_event_get()) {

                MSLEEP(1);

                // # query adv_rpt       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , adv_param_set->Advertising_Type[0])) {               
                                    
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                adv_param_set->Advertising_Type[0] , 
                                buf , 
                                g_pattern_param)) {
                               
                   if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){
                       if((++cnt % 1000) == 0)
                           printf("No adv rpt data [%d]\n" , cnt);
                       //continue;
                   }else{
                       printf("some bytes error\n");                        
                       adv_error_cnt ++ ;
                   }
                    
                }
                else {
                  
                    adv_cnt ++; 
                    printf("adv coming, cnt %d\n" , adv_cnt);               
                }                
            }


            LOG_INFO("****adv_cnt = %d | adv_ideal_cnt = %d | adv_error_cnt = %d****\n\n" 
                    , adv_cnt 
                    , adv_ideal_cnt 
                    , adv_error_cnt);

            adv_error_cnt = 0;

            if (adv_cnt < adv_ideal_cnt ){
                line = __LINE__;
                goto FUN_FAIL;
            }

            cnt = 0;
            adv_error_cnt = 0;

            // # to check the result
            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

        printf("\n");
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    

    LOG_INFO("[Pattern][%s]SUCCESS \n" ,__FUNCTION__ );

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Adv_time_dep_advint_chmap_check_with_dir_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_TIME_DEP_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int loop_cnt_set    = g_adv_param_loop_cnt    ;    //param
    int success_rate    = g_adv_param_success_rate;    //param
    int scan_intval_set = g_adv_param_scn_intval  ;    //param
    
    int adv_intval_cnt  = 0 ;
    int adv_intval_step = 1 ; // # 1 = 0.625ms ; 16 = 10ms

    int adv_type_cnt      = HCI_CMD_PARAM_ADV_IND ;
    int adv_type_step     = 1;
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = 1 ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = HCI_CMD_PARAM_ADV_DATA_LEN_MAX + 1 ;

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    u8 * adv_enable = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set = &(g_pattern_param.adv_param);
    Scn_param * scn_param_set = &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int adv_collect_cnt = 0;
    int adv_error_cnt   = 0 ;

    Calculate_Execution_Time_Start();

    // # conbine adv params
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ;
          adv_type_cnt < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt += adv_type_step ){          

        // # only adv_direct_ind
        if(adv_type_cnt != HCI_CMD_PARAM_ADV_DIRECT_IND){
            continue;
        }
            
    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX; 
          adv_intval_cnt += adv_intval_step ){              

        // # adv_dir_ind not used and shall be ignored
        if((adv_type_cnt == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
          (adv_intval_cnt != adv_test_params[adv_type_cnt].adv_intval_min)){
            break;
        }

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){
           
    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

        int loop_cnt = loop_cnt_set ;
    
    for ( ; loop_cnt > 0
          ; loop_cnt -- ){

        int direct_adv_check = 0 ;
        
        do{

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
           
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS) ;
    
            adv_collect_cnt = CALC_ADV_DIRECT_CNT(adv_intval_cnt  ,success_rate);
#if 0
            LOG_INFO("%f \n" , ((float)(1280) / (float)(adv_intval_cnt * 0.625)));
            LOG_INFO("%f \n" , ((float)(1280) / (float)(adv_intval_cnt * 0.625))*success_rate);
            LOG_INFO("%f \n" , ((float)adv_ch_map_tbl[adv_ch_map_cnt][1] / (float)CH_NUM_MAX));
#endif

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map_cnt %d \n", adv_ch_map_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n", adv_ch_map_tbl[adv_ch_map_cnt][0] 
                                              , adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }
             
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            // # config scan verify param

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            
            // # scan_intval large than 2 * adv_intval
            int scan_intval = 0;
            scan_intval = scan_intval_set ;  

            LOG_INFO("scan_intval_set %d \n" , scan_intval);
            scn_param_set->LE_Scan_Type[0]        =   HCI_CMD_PARAM_PASSIVE_SCAN;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;

            //# should depend on the direct_ind : initA type
            u8 own_addr_cond = 0;
            own_addr_cond = (adv_param_set->Advertising_Type[0] == HCI_CMD_PARAM_ADV_DIRECT_IND ) &&
                            (adv_param_set->Direct_Address_Type[0] == HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS);
            
            if (own_addr_cond){
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            }
            else{
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            }

            LOG_INFO("scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);
            scn_param_set->Scanning_Filter_Policy[0] =    HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;

            *scn_enable = HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            int adv_cnt   = 0 ;          

            struct timeval start_time;                      
            struct timeval current_time;                      

            gettimeofday(&start_time,NULL);
            printf("+++ %ld %ld +++\n",start_time.tv_sec ,start_time.tv_usec);

            while(1) {

                MSLEEP(1);
               
                // # query adv_rpt       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , adv_param_set->Advertising_Type[0])) {               
                                    
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                adv_param_set->Advertising_Type[0] , 
                                buf , 
                                g_pattern_param)) {

                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){
                        if((++cnt % 1000) == 0)
                            printf("No adv rpt data [%d]\n" , cnt);
                        //continue;
                    }else{
                        printf("some bytes error\n");                        
                        adv_error_cnt ++ ;
                    }
                    
                }
                else {
                    adv_cnt ++; 
                    printf("adv coming, cnt %d\n" , adv_cnt);               
                } 

                gettimeofday(&current_time,NULL);

                if((current_time.tv_sec - start_time.tv_sec) >= 2){
                    
                    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                        continue;
                    }else if (_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != 
                        hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                        continue;
                    }
                    else {
                        printf("dir timeout coming , loop_cnt %d \n" , loop_cnt);
                        break;
                    }       

                }                  
            }

            LOG_INFO("****adv_cnt = %d | adv_collect_cnt = %d | adv_error_cnt = %d | loop_cnt = %d****\n\n" 
                    , adv_cnt 
                    , adv_collect_cnt 
                    , adv_error_cnt
                    , loop_cnt);

            adv_error_cnt = 0;

            if (adv_cnt < adv_collect_cnt ){
                goto FUN_FAIL;
            }

            // # to check the result
            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

        printf("\n");
    } //# loop_cnt_set    
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    

    LOG_INFO("[Pattern][%s]SUCCESS \n" ,__FUNCTION__ );

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Scn_time_indep_all_param_check_passive_with_adv_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    //SCAN_TIME_IND_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int adv_intval_cnt    = 0 ;
    int adv_intval_step   = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 0.625ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = 1 ; //g_adv_param_adv_type_step;      // #param
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = ADV_CH_MAP_TBL_ROW ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = 32 ; //g_adv_param_adv_data_len_step ; // # param

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    int addr_filter_policy_step = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    int conf_white_list_cnt        = CONFIG_DISABLE ;
    int conf_white_list_error_addr = CONFIG_DISABLE ;

    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set =     &(g_pattern_param.adv_param);
    Scn_param * scn_param_set =     &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int adv_error_cnt   = 0 ;


    // # config scan verify param
    
    int scan_type               = HCI_CMD_PARAM_PASSIVE_SCAN;
    int scan_type_step          = 2;
    
    int scan_own_addr_type      = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    int scan_own_addr_type_step = 1;
    
    int scan_filter_policy      = HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;
    int scan_filter_policy_step = 1;
    
    int scan_filter_duplicate   = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;
    int scan_filter_duplicate_step = 1;
    
    // # scan_intval large than 2 * adv_intval
    int scan_intval             = 0;

    int time_out                = 2 ; //g_adv_param_time_out;              // #param

    Calculate_Execution_Time_Start();
 
    // # config whitelist or not
    for ( ; 
          conf_white_list_cnt < CONFIG_FORBID ;
          conf_white_list_cnt ++ ){

    // # conbine adv params    
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ; 
          adv_type_cnt    < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt   += adv_type_step){          

    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX;
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt  < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){

    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

    for ( ; addr_filter_policy_cnt < HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY
          ; addr_filter_policy_cnt += addr_filter_policy_step){

    for ( ; scan_type <= HCI_CMD_PARAM_ACTIVE_SCAN
          ; scan_type += scan_type_step){
          
    for ( ; scan_own_addr_type <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; scan_own_addr_type += scan_own_addr_type_step){
    
    for ( ; scan_filter_policy <= HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY
          ; scan_filter_policy += scan_filter_policy_step){
    
    for ( ; scan_filter_duplicate <= HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE
          ; scan_filter_duplicate += scan_filter_duplicate_step){

    for ( ; conf_white_list_error_addr < CONFIG_FORBID ;
            conf_white_list_error_addr ++ ){

          
        int direct_adv_check = 0 ;

        do{
            // # config whether use random address  
            COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);

            COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
            COMM_Device_Address_Set(dut2_fd, g_pattern_param);    

            if(( conf_white_list_cnt == CONFIG_ENABLE) && (conf_white_list_error_addr == CONFIG_DISABLE)){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            }

            if(( conf_white_list_cnt == CONFIG_ENABLE) && (conf_white_list_error_addr == CONFIG_ENABLE)){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,error_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            }
            
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS) ;

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("\nconf_white_list_cnt %d \n" , conf_white_list_cnt);
            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n",adv_ch_map_tbl[adv_ch_map_cnt][0] ,adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            LOG_INFO("scan_type %d \n"     , scan_type);
            LOG_INFO("scan_own_addr_type %d \n", scan_own_addr_type );
            LOG_INFO("scan_filter_policy %d \n" , scan_filter_policy );
            LOG_INFO("scan_filter_duplicates %d \n"     , scan_filter_duplicate );
            LOG_INFO("conf_white_list_error_addr %d |\n" , conf_white_list_error_addr);


            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }else{

                    LOG_INFO("dir random type \n");
                    memcpy (adv_param_set->Direct_Address , scan_random_addr , ADDR_LENGTH);

                }
                
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
    	        adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            scan_intval =   ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);

            scn_param_set->LE_Scan_Type[0]        =   scan_type;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;
            scn_param_set->Own_Address_Type[0]        =   scan_own_addr_type ;
 
            LOG_INFO("scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);
            
            scn_param_set->Scanning_Filter_Policy[0]  =   scan_filter_policy;

            *scn_enable                               =   HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates                   =   scan_filter_duplicate;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int adv_cnt   = 0 ;

            struct timeval start_time;                      
            struct timeval current_time;                      

            gettimeofday(&start_time,NULL);


            while(read_le_event_get()) {
                MSLEEP(1);

                if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                    // # force continue start direct_ind adv without check return value
                    COMM_ADV_Advertising(dut2_fd);                    
                    usleep(10 * 1000);
                }

                // # query adv_rpt       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , adv_param_set->Advertising_Type[0])) {               
                                    
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                adv_param_set->Advertising_Type[0] , 
                                buf , 
                                g_pattern_param)) {
                                
                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){
                        if((++cnt % 1000) == 0)
                            printf("No adv rpt data [%d]\n" , cnt);
                        //continue;
                    }else{
                        printf("some bytes error\n");                        
                        adv_error_cnt ++ ;
                    }

                    
                }
                else {
                    adv_cnt ++; 
                    printf("adv coming, cnt %d\n" , adv_cnt);
                }


                gettimeofday(&current_time,NULL);
                
                if ((current_time.tv_sec - start_time.tv_sec) >= time_out){
                    LOG_INFO("%d - %d ; %d\n" , (int)current_time.tv_sec , (int)start_time.tv_sec , time_out);
                    LOG_INFO("break loop , adv_cnt = %d \n" , adv_cnt );                        
                    LOG_INFO("\n")
                    break;
                }       

                
            }

            // # to check the result with true table
            // w = whitelist config
            // p = policy config
            
            // w\p | 0 | 1 |
            //   0 |!=0| =0|
            //   1 |!=0|!=0|
            
            if (adv_cnt == 0){
                switch(scan_filter_policy){
                    case HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS:

                        // # case for adv_dir_ind and diff addr type
                                   
                        if((adv_type_cnt      == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
                           (dir_addr_type_cnt != scan_own_addr_type)){

                        // # case for filter enable
                            
                        }else if(scan_filter_duplicate   == HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE){

                        }else{
                            LOG_INFO("dir_type %d , scan_own %d\n" , dir_addr_type_cnt ,scan_own_addr_type);

                            LOG_INFO("no pkt coming\n");
                            line = __LINE__;
                            goto FUN_FAIL;
                        
                        }
                        
                        break;
                        
                    case HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY:

                        // # case for error addr config

                        if((conf_white_list_cnt == CONFIG_ENABLE) && 
                           (conf_white_list_error_addr == CONFIG_DISABLE)){

                            // # case for adv_dir_ind and diff addr type

                            if((adv_type_cnt      == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
                               (dir_addr_type_cnt != scan_own_addr_type)){

                            // # case for filter enable
                                
                            }else if(scan_filter_duplicate   == HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE){

                            }else{
                                LOG_INFO("no pkt coming\n");
                                line = __LINE__;
                                goto FUN_FAIL;
                            
                            }                         
                        }
                            
                        break;
                }
            }

            if (adv_cnt != 0){
                switch(scan_filter_policy){
                    case HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS:

                        // # case for adv_dir_ind and diff addr type
                                   
                        if((adv_type_cnt      == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
                           (dir_addr_type_cnt != scan_own_addr_type)){
                            
                            LOG_INFO("forbid pkt coming\n");
                            line = __LINE__;
                            goto FUN_FAIL;
                        
                        }
                        
                        break;
                        
                    case HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY:

                        // # case for policy with whitelist but not config 
                        if(conf_white_list_cnt == CONFIG_DISABLE){
                            LOG_INFO("forbid pkt coming\n");
                            line = __LINE__;
                            goto FUN_FAIL;
                        }

                        // # case for whiltelist config
                        if(conf_white_list_cnt == CONFIG_ENABLE){

                            // # case for adv_dir_ind and diff addr type

                            if((adv_type_cnt      == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
                               (dir_addr_type_cnt != scan_own_addr_type)){

                                LOG_INFO("forbid pkt coming\n");
                                line = __LINE__;
                                goto FUN_FAIL;
                            }

                            // # case for error addr config

                            if(conf_white_list_error_addr == CONFIG_ENABLE){
                                LOG_INFO("forbid pkt coming\n");
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            
                        }
                            
                        break;
                }
            }
            
            cnt = 0;
            dir_addr_type_cnt ++ ;            
            adv_error_cnt = 0;
            FUNC_END();
            

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    
    }
        conf_white_list_error_addr = CONFIG_DISABLE ;
    }
        scan_filter_duplicate = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE ;
    }
        scan_filter_policy = HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS ;
    }
        scan_own_addr_type = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    }
        scan_type = HCI_CMD_PARAM_PASSIVE_SCAN ;

        printf("\n");
    }
        addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    
        adv_type_cnt = 0;
    }

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;

}


verdict Scn_time_indep_all_param_check_passive_without_scn_rsp(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    //SCAN_TIME_IND_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int adv_intval_cnt    = 0 ;
    int adv_intval_step   = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 0.625ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = 1 ; //g_adv_param_adv_type_step;      // #param
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = ADV_CH_MAP_TBL_ROW ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = 32 ; //g_adv_param_adv_data_len_step ; // # param

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    int addr_filter_policy_step = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    int conf_white_list_cnt        = CONFIG_DISABLE ;
    int conf_white_list_error_addr = CONFIG_DISABLE ;


    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set =     &(g_pattern_param.adv_param);
    Scn_param * scn_param_set =     &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int scn_rsp_error_cnt   = 0;


    // # config scan verify param
    
    int scan_type               = HCI_CMD_PARAM_PASSIVE_SCAN;
    int scan_type_step          = 2;
    
    int scan_own_addr_type      = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    int scan_own_addr_type_step = 1;
    
    int scan_filter_policy      = HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;
    int scan_filter_policy_step = 1;
    
    int scan_filter_duplicate   = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;
    int scan_filter_duplicate_step = 1;
    
    // # scan_intval large than 2 * adv_intval
    int scan_intval             = 0;

    int time_out                = 2 ; //g_adv_param_time_out;              // #param

    Calculate_Execution_Time_Start();

    // # config whitelist or not
    for (  ; 
           conf_white_list_cnt < CONFIG_FORBID ;
           conf_white_list_cnt ++ ){
 
    // # conbine adv params
    
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ; 
          adv_type_cnt    < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt   += adv_type_step){          

    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX;
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){

    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

    for ( ; addr_filter_policy_cnt < HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY
          ; addr_filter_policy_cnt += addr_filter_policy_step){

    for ( ; scan_type <= HCI_CMD_PARAM_ACTIVE_SCAN
          ; scan_type += scan_type_step){
          
    for ( ; scan_own_addr_type <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; scan_own_addr_type += scan_own_addr_type_step){
    
    for ( ; scan_filter_policy <= HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY
          ; scan_filter_policy += scan_filter_policy_step){
    
    for ( ; scan_filter_duplicate <= HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE
          ; scan_filter_duplicate += scan_filter_duplicate_step){

    for ( ; conf_white_list_error_addr < CONFIG_FORBID ;
            conf_white_list_error_addr ++ ){

          
        int direct_adv_check = 0 ;

        do{
            // # config whether use random address  
            COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);

            COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
            COMM_Device_Address_Set(dut2_fd, g_pattern_param);    

            if(( conf_white_list_cnt == CONFIG_ENABLE) && (conf_white_list_error_addr == CONFIG_DISABLE)){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            }

            if(( conf_white_list_cnt == CONFIG_ENABLE) && (conf_white_list_error_addr == CONFIG_ENABLE)){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,error_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            }

            
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS) ;

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("\nconf_white_list_cnt %d \n" , conf_white_list_cnt);
            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n",adv_ch_map_tbl[adv_ch_map_cnt][0] ,adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            LOG_INFO("scan_type %d \n"     , scan_type);
            LOG_INFO("scan_own_addr_type %d \n", scan_own_addr_type );
            LOG_INFO("scan_filter_policy %d \n" , scan_filter_policy );
            LOG_INFO("scan_filter_duplicates %d \n"     , scan_filter_duplicate );
            LOG_INFO("conf_white_list_error_addr %d \n\n" , conf_white_list_error_addr);

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }else{

                    LOG_INFO("dir random type \n");
                    memcpy (adv_param_set->Direct_Address , scan_random_addr , ADDR_LENGTH);

                }
                
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            scan_intval =   ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);

            scn_param_set->LE_Scan_Type[0]        =   scan_type;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;
            scn_param_set->Own_Address_Type[0]        =   scan_own_addr_type ;
            
            scn_param_set->Scanning_Filter_Policy[0]  =   scan_filter_policy;

            *scn_enable                               =   HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates                   =   scan_filter_duplicate;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int scn_rsp_cnt = 0;

            struct timeval start_time;                      
            struct timeval current_time;                      

            gettimeofday(&start_time,NULL);

            while(read_le_event_get()) {
                MSLEEP(1);

                // # query scn_rsp       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {               
                                    
                    continue;
                }
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP , 
                                buf , 
                                g_pattern_param)) {
                                
                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){           
                        if((++cnt % 1000) == 0)
                            printf("No scn rsp data [%d]\n" , cnt);
                        //continue;
                    }else{
                        printf("some bytes error\n");
                        scn_rsp_error_cnt ++ ;
                    }
                    
                }
                else {
                    scn_rsp_cnt ++; 
                    printf("scn rsp coming, cnt %d\n" , scn_rsp_cnt);               
                }

                gettimeofday(&current_time,NULL);
                
                if ((current_time.tv_sec - start_time.tv_sec) >= time_out){
                    LOG_INFO("%d - %d ; %d\n" , (int)current_time.tv_sec , (int)start_time.tv_sec , time_out);
                    LOG_INFO("break loop , scn_rsp_cnt = %d \n" , scn_rsp_cnt );                        
                    LOG_INFO("\n");
                    break;
                }                   
            }

            // # to check the result
            if (scn_rsp_cnt != 0){
                line = __LINE__;
                goto FUN_FAIL;
            }

            cnt = 0;
            dir_addr_type_cnt ++ ;
            scn_rsp_error_cnt = 0;
            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

    }
        conf_white_list_error_addr = CONFIG_DISABLE ;
    }
        scan_filter_duplicate = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE ;
    }
        scan_filter_policy = HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS ;
    }
        scan_own_addr_type = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    }
        scan_type = HCI_CMD_PARAM_PASSIVE_SCAN ;

        printf("\n");
    }
        addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    
        adv_type_cnt = 0;
    }


    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Scn_time_indep_all_param_check_active_with_adv_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    //SCAN_TIME_IND_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int adv_intval_cnt    = 0 ;
    int adv_intval_step   = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 0.625ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = 1 ; //g_adv_param_adv_type_step;      // #param
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = ADV_CH_MAP_TBL_ROW ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = 32 ; //g_adv_param_adv_data_len_step ; // # param

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    int addr_filter_policy_step = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    int conf_white_list_cnt        = CONFIG_DISABLE ;
    int conf_white_list_error_addr = CONFIG_DISABLE ;


    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set =     &(g_pattern_param.adv_param);
    Scn_param * scn_param_set =     &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int adv_error_cnt   = 0 ;


    // # config scan verify param
    
    int scan_type               = HCI_CMD_PARAM_ACTIVE_SCAN;
    int scan_type_step          = 2;
    
    int scan_own_addr_type      = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    int scan_own_addr_type_step = 1;
    
    int scan_filter_policy      = HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;
    int scan_filter_policy_step = 1;
    
    int scan_filter_duplicate   = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;
    int scan_filter_duplicate_step = 1;
    
    // # scan_intval large than 2 * adv_intval
    int scan_intval             = 0;

    int time_out                = 2 ; //g_adv_param_time_out;              // #param

    Calculate_Execution_Time_Start();

    // # config whitelist or not
    for (  ; 
           conf_white_list_cnt < CONFIG_FORBID ;
           conf_white_list_cnt ++ ){

    // # conbine adv params    
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ; 
          adv_type_cnt    < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt   += adv_type_step){          

    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX;
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){

    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

    for ( ; addr_filter_policy_cnt < HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY
          ; addr_filter_policy_cnt += addr_filter_policy_step){

    for ( ; scan_type <= HCI_CMD_PARAM_ACTIVE_SCAN
          ; scan_type += scan_type_step){
          
    for ( ; scan_own_addr_type <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; scan_own_addr_type += scan_own_addr_type_step){
    
    for ( ; scan_filter_policy <= HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY
          ; scan_filter_policy += scan_filter_policy_step){
    
    for ( ; scan_filter_duplicate <= HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE
          ; scan_filter_duplicate += scan_filter_duplicate_step){

    for ( ; conf_white_list_error_addr < CONFIG_FORBID ;
            conf_white_list_error_addr ++ ){
          
        int direct_adv_check = 0 ;

        do{
            // # config whether use random address  
            COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);

            COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
            COMM_Device_Address_Set(dut2_fd, g_pattern_param);    

            if(( conf_white_list_cnt == CONFIG_ENABLE) && (conf_white_list_error_addr == CONFIG_DISABLE)){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            }

            if(( conf_white_list_cnt == CONFIG_ENABLE) && (conf_white_list_error_addr == CONFIG_ENABLE)){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,error_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            }

            
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS) ;

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("\nconf_white_list_cnt %d \n" , conf_white_list_cnt);
            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n",adv_ch_map_tbl[adv_ch_map_cnt][0] ,adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            LOG_INFO("scan_type %d \n"     , scan_type);
            LOG_INFO("scan_own_addr_type %d \n", scan_own_addr_type );
            LOG_INFO("scan_filter_policy %d \n" , scan_filter_policy );
            LOG_INFO("scan_filter_duplicates %d \n"     , scan_filter_duplicate );
            LOG_INFO("conf_white_list_error_addr %d \n\n" , conf_white_list_error_addr);


            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }else{

                    LOG_INFO("dir random type \n");
                    memcpy (adv_param_set->Direct_Address , scan_random_addr , ADDR_LENGTH);

                }
                
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
    	        adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            scan_intval =   ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);

            scn_param_set->LE_Scan_Type[0]        =   scan_type;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;
            scn_param_set->Own_Address_Type[0]        =   scan_own_addr_type ;
 
            LOG_INFO("scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);
            
            scn_param_set->Scanning_Filter_Policy[0]  =   scan_filter_policy;

            *scn_enable                               =   HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates                   =   scan_filter_duplicate;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int adv_cnt   = 0 ;

            struct timeval start_time;                      
            struct timeval current_time;                      

            gettimeofday(&start_time,NULL);


            while(read_le_event_get()) {
                MSLEEP(1);

                if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                    // # force continue start direct_ind adv without check return value
                    COMM_ADV_Advertising(dut2_fd);                    
                    MSLEEP(10);
                }

                // # query adv_rpt       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , adv_param_set->Advertising_Type[0])) {               
                                    
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                adv_param_set->Advertising_Type[0] , 
                                buf , 
                                g_pattern_param)) {
                                
                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){           
                        if((++cnt % 1000) == 0)
                            printf("No adv rpt data [%d]\n" , cnt);
                        //continue;
                    }else{
                        printf("some bytes error\n");                        
                        adv_error_cnt ++ ;
                    }
                    
                }
                else {
                    adv_cnt ++; 
                    printf("adv coming, cnt %d\n" , adv_cnt);
                }


                gettimeofday(&current_time,NULL);
                
                if ((current_time.tv_sec - start_time.tv_sec) >= time_out){
                    LOG_INFO("%d - %d ; %d\n" , (int)current_time.tv_sec , (int)start_time.tv_sec , time_out);
                    LOG_INFO("break loop , adv_cnt = %d \n" , adv_cnt );                        
                    LOG_INFO("\n")
                    break;
                }       

                
            }

            // # to check the result with true table
            // w = whitelist config
            // p = policy config

                
            // w\p | 0 | 1 |
            //   0 |!=0| =0|
            //   1 |!=0|!=0|
            
            if (adv_cnt == 0){
                switch(scan_filter_policy){
                    case HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS:

                        // # case for adv_dir_ind and diff addr type
                                   
                        if((adv_type_cnt      == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
                           (dir_addr_type_cnt != scan_own_addr_type)){

                        // # case for filter enable
                            
                        }else if(scan_filter_duplicate   == HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE){

                        }else{
                            LOG_INFO("dir_type %d , scan_own %d\n" , dir_addr_type_cnt ,scan_own_addr_type);

                            LOG_INFO("no pkt coming\n");
                            line = __LINE__;
                            goto FUN_FAIL;
                        
                        }
                        
                        break;
                        
                    case HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY:

                        // # case for error addr config

                        if((conf_white_list_cnt == CONFIG_ENABLE) && 
                           (conf_white_list_error_addr == CONFIG_DISABLE)){

                            // # case for adv_dir_ind and diff addr type

                            if((adv_type_cnt      == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
                               (dir_addr_type_cnt != scan_own_addr_type)){

                            // # case for filter enable
                                
                            }else if(scan_filter_duplicate   == HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE){

                            }else{
                                LOG_INFO("no pkt coming\n");
                                line = __LINE__;
                                goto FUN_FAIL;
                            
                            }                         
                        }
                            
                        break;
                }
            }

            if (adv_cnt != 0){
                switch(scan_filter_policy){
                    case HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS:

                        // # case for adv_dir_ind and diff addr type
                                   
                        if((adv_type_cnt      == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
                           (dir_addr_type_cnt != scan_own_addr_type)){
                            
                            LOG_INFO("forbid pkt coming\n");
                            line = __LINE__;
                            goto FUN_FAIL;
                        
                        }
                        
                        break;
                        
                    case HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY:

                        // # case for policy with whitelist but not config 
                        if(conf_white_list_cnt == CONFIG_DISABLE){
                            LOG_INFO("forbid pkt coming\n");
                            line = __LINE__;
                            goto FUN_FAIL;
                        }

                        // # case for whiltelist config
                        if(conf_white_list_cnt == CONFIG_ENABLE){

                            // # case for adv_dir_ind and diff addr type

                            if((adv_type_cnt      == HCI_CMD_PARAM_ADV_DIRECT_IND) && 
                               (dir_addr_type_cnt != scan_own_addr_type)){

                                LOG_INFO("forbid pkt coming\n");
                                line = __LINE__;
                                goto FUN_FAIL;
                            }

                            // # case for error addr config

                            if(conf_white_list_error_addr == CONFIG_ENABLE){
                                LOG_INFO("forbid pkt coming\n");
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            
                        }
                            
                        break;
                }
            }

            cnt = 0;
            dir_addr_type_cnt ++ ;               
            adv_error_cnt = 0;
            
            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    
    }
        conf_white_list_error_addr = CONFIG_DISABLE ;

    }
        scan_filter_duplicate = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE ;
    }
        scan_filter_policy = HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS ;
    }
        scan_own_addr_type = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    }
        scan_type = HCI_CMD_PARAM_PASSIVE_SCAN ;

        printf("\n");
    }
        addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    
        adv_type_cnt = 0;
    }

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;

}

verdict Scn_time_indep_all_param_check_active_with_scn_rsp(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;

    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    //SCAN_TIME_IND_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int adv_intval_cnt    = 0 ;
    int adv_intval_step   = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 0.625ms

    int adv_type_cnt      = 0 ;
    int adv_type_step     = 1 ; //g_adv_param_adv_type_step;      // #param
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = ADV_CH_MAP_TBL_ROW ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = 32 ; //g_adv_param_adv_data_len_step ; // # param

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    int addr_filter_policy_step = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    int conf_white_list_cnt         = CONFIG_DISABLE ;
    int conf_white_list_error_addr  = CONFIG_DISABLE ;

    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set =     &(g_pattern_param.adv_param);
    Scn_param * scn_param_set =     &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int scn_rsp_collect_cnt = 1;//g_adv_param_scn_rsp_collect_cnt ;    // #param    
    int scn_rsp_error_cnt   = 0;


    // # config scan verify param
    
    int scan_type               = HCI_CMD_PARAM_ACTIVE_SCAN;
    int scan_type_step          = 2;
    
    int scan_own_addr_type      = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    int scan_own_addr_type_step = 1;
    
    int scan_filter_policy      = HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;
    int scan_filter_policy_step = 1;
    
    int scan_filter_duplicate   = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;
    int scan_filter_duplicate_step = 1;
    
    // # scan_intval large than 2 * adv_intval
    int scan_intval             = 0;

    int time_out                = 2 ; //g_adv_param_time_out;              // #param

    Calculate_Execution_Time_Start();

    // # config whitelist or not
    for (  ; 
           conf_white_list_cnt < CONFIG_FORBID ;
           conf_white_list_cnt ++ ){
 
    // # conbine adv params
    
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ; 
          adv_type_cnt    < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt   += adv_type_step){          

    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX;
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){

    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

    for ( ; addr_filter_policy_cnt < HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY
          ; addr_filter_policy_cnt += addr_filter_policy_step){

    for ( ; scan_type <= HCI_CMD_PARAM_ACTIVE_SCAN
          ; scan_type += scan_type_step){
          
    for ( ; scan_own_addr_type <= HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS
          ; scan_own_addr_type += scan_own_addr_type_step){
    
    for ( ; scan_filter_policy <= HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY
          ; scan_filter_policy += scan_filter_policy_step){
    
    for ( ; scan_filter_duplicate <= HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE
          ; scan_filter_duplicate += scan_filter_duplicate_step){

    for ( ; conf_white_list_error_addr < CONFIG_FORBID ;
            conf_white_list_error_addr ++ ){
          
        int direct_adv_check = 0 ;

        do{
            // # config whether use random address  
            COMM_Static_Random_Device_Address_Set_Config(scan_random_addr);
            COMM_Device_Address_Set(dut1_fd, g_pattern_param);

            COMM_Static_Random_Device_Address_Set_Config(adv_random_addr);
            COMM_Device_Address_Set(dut2_fd, g_pattern_param);    

            if(( conf_white_list_cnt == CONFIG_ENABLE) && (conf_white_list_error_addr == CONFIG_DISABLE)){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            }

            if(( conf_white_list_cnt == CONFIG_ENABLE) && (conf_white_list_error_addr == CONFIG_ENABLE)){
                COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,error_addr,&g_pattern_param);
                COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            }

            
            
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS) ;

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("\nconf_white_list_cnt %d \n" , conf_white_list_cnt);
            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n",adv_ch_map_tbl[adv_ch_map_cnt][0] ,adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            LOG_INFO("scan_type %d \n"     , scan_type);
            LOG_INFO("scan_own_addr_type %d \n", scan_own_addr_type );
            LOG_INFO("scan_filter_policy %d \n" , scan_filter_policy );
            LOG_INFO("scan_filter_duplicates %d \n"     , scan_filter_duplicate );
            LOG_INFO("conf_white_list_error_addr %d \n\n" , conf_white_list_error_addr);


            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }else{

                    LOG_INFO("dir random type \n");
                    memcpy (adv_param_set->Direct_Address , scan_random_addr , ADDR_LENGTH);

                }
                
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            scan_intval =   ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);

            scn_param_set->LE_Scan_Type[0]        =   scan_type;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_intval & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_intval & 0xff00) >> 8;
            scn_param_set->Own_Address_Type[0]        =   scan_own_addr_type ;


            LOG_INFO("scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);
            
            scn_param_set->Scanning_Filter_Policy[0]  =   scan_filter_policy;

            *scn_enable                               =   HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates                   =   scan_filter_duplicate;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int scn_rsp_cnt = 0;

            struct timeval start_time;                      
            struct timeval current_time;                      

            gettimeofday(&start_time,NULL);

            while(read_le_event_get()) {
                
                MSLEEP(1);
                // # query scn_rsp       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {               
                                    
                    continue;
                }
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP , 
                                buf , 
                                g_pattern_param)) {
                                
                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){           
                        if((++cnt % 1000) == 0)
                            printf("No scn rsp data [%d]\n" , cnt);
                        //continue;
                    }else{
                        printf("some bytes error\n");
                        scn_rsp_error_cnt ++ ;
                    }
                    
                }
                else {
                    scn_rsp_cnt ++; 
                    LOG_INFO("scn rsp coming, cnt %d\n" , scn_rsp_cnt);               
                }

                if (scn_rsp_cnt == scn_rsp_collect_cnt){
                    LOG_INFO("scn_rsp_collect_cnt = %d| scn_rsp_error_cnt = %d\n" , 
                              scn_rsp_collect_cnt , scn_rsp_error_cnt);
                    LOG_INFO("\n")

                    break ;
                }


                gettimeofday(&current_time,NULL);
                
                if ((current_time.tv_sec - start_time.tv_sec) >= time_out){
                
                    LOG_INFO("break loop , scn_rsp_cnt = %d \n" , scn_rsp_cnt );                        
                    LOG_INFO("\n");
                    break;
                }                   
            }

            // # to check the result with true table
            // w = whitelist config
            // p = policy config

            // w\p | 0 | 1 |
            //   0 |!=0| =0|
            //   1 |!=0|!=0|

            // # to check the result
            if (scn_rsp_cnt == 0){

                switch(adv_type_cnt){
                    // # only adv_ind and adv_scan_ind allow resp SCAN_REQ
                    case HCI_CMD_PARAM_ADV_DIRECT_IND:
                    case HCI_CMD_PARAM_ADV_NONCONN_IND:
                        break;

                    case HCI_CMD_PARAM_ADV_IND:
                    case HCI_CMD_PARAM_ADV_SCAN_IND:
                        switch(scan_filter_policy){
                            case HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS:

                                // # case for filter enable                                           
                                if(scan_filter_duplicate   == HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE){

                                }else{
                                    LOG_INFO("dir_type %d , scan_own %d\n" , dir_addr_type_cnt ,scan_own_addr_type);
                                    LOG_INFO("no pkt coming\n");
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                
                                }
                                
                                break;
                                
                            case HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY:

                                if(conf_white_list_cnt == CONFIG_ENABLE){

                                    // # case for filter enable
                                    if(scan_filter_duplicate   == HCI_CMD_PARAM_FILTER_DUPLICATES_ENABLE){

                                    // # case for error white list addr
                                    }else if(conf_white_list_error_addr == CONFIG_ENABLE){

                                    }else{
                                        LOG_INFO("no pkt coming\n");
                                        line = __LINE__;
                                        goto FUN_FAIL;
                                    
                                    }                         
                                }
                                    
                                break;
                        }
                        break;
                }                        
            }

            if (scn_rsp_cnt != 0){

                switch(adv_type_cnt){
                    
                    // # adv_direct_ind and adv_nonconn_ind not allow resp SCAN_REQ
                    case HCI_CMD_PARAM_ADV_DIRECT_IND:
                    case HCI_CMD_PARAM_ADV_NONCONN_IND:

                        LOG_INFO("forbid pkt coming\n");
                        line = __LINE__;
                        goto FUN_FAIL;
                        
                        break;

                    case HCI_CMD_PARAM_ADV_IND:
                    case HCI_CMD_PARAM_ADV_SCAN_IND:
                        switch(scan_filter_policy){
                            case HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS:                                                                           
                                break;
                                
                            case HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY:
                                // # case for non config whitelist
                                if(conf_white_list_cnt == CONFIG_DISABLE){
                                    LOG_INFO("forbid pkt coming\n");
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                }

                                // # case for config whitelist with erro addr
                                if((conf_white_list_cnt == CONFIG_ENABLE) && 
                                   (conf_white_list_error_addr == CONFIG_ENABLE)){
                                    LOG_INFO("forbid pkt coming\n");
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                }
                                    
                                break;
                        }
                        break;
                }                        
            }

            cnt = 0;
            dir_addr_type_cnt ++ ;  

            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    
    }
        conf_white_list_error_addr = CONFIG_DISABLE ;
    }
        scan_filter_duplicate = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE ;
    }
        scan_filter_policy = HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS ;
    }
        scan_own_addr_type = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    }
        scan_type = HCI_CMD_PARAM_ACTIVE_SCAN ;

        printf("\n");
    }
        addr_filter_policy_cnt = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    
        adv_type_cnt = 0;
    }

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Scn_time_dep_scnint_win_check_ex_dir_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SCN_TIME_DEP_PATTERN_CONFIG_READ();

    struct itimerval timer;

    int query_time      = g_scan_param_query_time ;     //param
    int success_rate    = g_scan_param_success_rate;    //param
    int scan_intval_set = g_scan_param_scn_intval;      //param 10.24s
    int scan_win_set    = g_scan_param_scn_window;      //param 10.24s
    
    int adv_intval_cnt  = 0 ;
    int adv_intval_step = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 1 = 0.625ms ; 16 = 10ms

    int adv_type_cnt      = HCI_CMD_PARAM_ADV_IND ;
    int adv_type_step     = 1;
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = 1 ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = HCI_CMD_PARAM_ADV_DATA_LEN_MAX + 1 ;

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set     = &(g_pattern_param.adv_param);
    Scn_param * scn_param_set     = &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int adv_ideal_cnt   = 0 ;
    int adv_error_cnt   = 0 ;

    Calculate_Execution_Time_Start();

    // # conbine adv params
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ;
          adv_type_cnt < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt += adv_type_step ){          

        // # exclusive adv_dir_ind
        if(adv_type_cnt == HCI_CMD_PARAM_ADV_DIRECT_IND){
            continue;
        }
            
    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX; 
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){
           
    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

        int direct_adv_check = 0 ;
        
        do{

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
            
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
           
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS) ;
    
            adv_ideal_cnt = 
            SCAN_CALC_ADV_CNT(  query_time ,
                                scan_win_set ,
                                scan_intval_set ,
                                adv_intval_cnt + ADV_AVG_DELAY_MS  ,
                                success_rate);

#if 0
            float x = ((float)(query_time*1000) / (float)((scan_intval_set) * 0.625));
            float y = x* (float)(scan_win_set/(adv_intval_cnt + ADV_AVG_DELAY_MS ));

            float z = y* (float)(scan_win_set/(scan_intval_set));

            LOG_INFO("%f %f %f %f\n" , x ,y ,z , x*y*z*success_rate/100);
            while(1){};
#endif
            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map_cnt %d \n", adv_ch_map_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n", adv_ch_map_tbl[adv_ch_map_cnt][0] 
                                              , adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }
             
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            COMM_Dut_clean_buffer(dut1_fd);
            COMM_Dut_clean_buffer(dut2_fd);

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            // # config scan verify param 
#if 0
            // # scan_intval large than 2 * adv_intval
            u16 scan_intval = 0;
            scan_intval = scan_intval_set ; 

            ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                        ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                        :(adv_intval_cnt * 3);
#endif
            scn_param_set->LE_Scan_Type[0]        =   HCI_CMD_PARAM_PASSIVE_SCAN;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval_set & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval_set & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_win_set    & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_win_set    & 0xff00) >> 8;

            //# should depend on the direct_ind : initA type
            u8 own_addr_cond = 0;
            own_addr_cond = (adv_param_set->Advertising_Type[0] == HCI_CMD_PARAM_ADV_DIRECT_IND ) &&
                            (adv_param_set->Direct_Address_Type[0] == HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS);
            
            if (own_addr_cond){
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            }
            else{
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            }

            LOG_INFO(" scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);
            
            scn_param_set->Scanning_Filter_Policy[0] =    HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;

            *scn_enable = HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int adv_cnt   = 0 ;

		    event_query_timer_config( query_time , 0, 0, 0, &timer);
		    event_query_timer_start(timer, read_le_event_disable);


            while(read_le_event_get()) {
                
                MSLEEP(1);
                // # query adv_rpt       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , adv_param_set->Advertising_Type[0])) {               
                                    
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                adv_param_set->Advertising_Type[0] , 
                                buf , 
                                g_pattern_param)) {
                               
                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){           
                        if((++cnt % 1000) == 0)
                            printf("No adv rpt data [%d]\n" , cnt);
                    }else{
                        printf("some bytes error\n");                        
                        adv_error_cnt ++ ;
                    }
                    
                }
                else {
                  
                    adv_cnt ++; 
                    printf("adv coming, cnt %d\n" , adv_cnt);               
                }                
            }


            LOG_INFO("****adv_cnt = %d | adv_ideal_cnt = %d | adv_error_cnt = %d****\n\n" 
                    , adv_cnt 
                    , adv_ideal_cnt 
                    , adv_error_cnt);

            adv_error_cnt = 0 ;

            if (adv_cnt < adv_ideal_cnt ){
                line = __LINE__ ;
                goto FUN_FAIL;
            }

            // # to check the result
            FUNC_END();

        }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

        printf("\n");
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    

    LOG_INFO("[Pattern][%s]SUCCESS \n" ,__FUNCTION__ );

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Scn_time_dep_scnint_win_check_with_dir_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    u16 line = 0;
    u16 cnt  = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SCN_TIME_DEP_PATTERN_CONFIG_READ();

    struct itimerval timer;
    
    int loop_cnt_set    = g_scan_param_loop_cnt    ;    //param
    int success_rate    = g_scan_param_success_rate;    //param
    int scan_intval_set = g_scan_param_scn_intval;      //param 10.24s
    int scan_win_set    = g_scan_param_scn_window;      //param 10.24s
    
    int adv_intval_cnt  = 0 ;
    int adv_intval_step = HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX ; // # 1 = 0.625ms ; 16 = 10ms

    int adv_type_cnt      = HCI_CMD_PARAM_ADV_IND ;
    int adv_type_step     = 1;
    
    int adv_ch_map_cnt    = 0 ;
    int adv_ch_map_step   = 1 ;
    
    int adv_data_len_cnt  = 0 ;
    int adv_data_len_step = HCI_CMD_PARAM_ADV_DATA_LEN_MAX + 1 ;

    int own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;
    int dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS ;

    int addr_filter_policy_cnt  = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    u8 * adv_enable             = g_pattern_param.Advertising_Enable ;
    u8 * scn_enable             = g_pattern_param.Scan_Enable;
    u8 * scan_filter_duplicates = g_pattern_param.Filter_Duplicates;
    
    Adv_param * adv_param_set     = &(g_pattern_param.adv_param);
    Scn_param * scn_param_set     = &(g_pattern_param.scn_param);
    Adv_data_param * adv_data_set = &(g_pattern_param.adv_data_param);
    Scn_rsp_param  * scn_data_set = &(g_pattern_param.scn_rsp_param);

    int adv_collect_cnt = 0 ;
    int adv_error_cnt   = 0 ;

    Calculate_Execution_Time_Start();

    // # conbine adv params
    for ( adv_type_cnt    = HCI_CMD_PARAM_ADV_IND ;
          adv_type_cnt < (sizeof(adv_test_params) / sizeof(adv_test_params[0])); 
          adv_type_cnt += adv_type_step ){          

        // # only adv_direct_ind
        if(adv_type_cnt != HCI_CMD_PARAM_ADV_DIRECT_IND){
            continue;
        }

            
    for ( adv_intval_cnt  = adv_test_params[adv_type_cnt].adv_intval_min; 
          adv_intval_cnt  < HCI_CMD_PARAM_ADVERTISING_INTERVAL_MAX; 
          adv_intval_cnt += adv_intval_step ){              

    for ( ; adv_ch_map_cnt < ADV_CH_MAP_TBL_ROW
          ; adv_ch_map_cnt += adv_ch_map_step){
           
    for ( ; adv_data_len_cnt <= HCI_CMD_PARAM_ADV_DATA_LEN_MAX
          ; adv_data_len_cnt += adv_data_len_step){

    for ( ; own_addr_type_cnt <= HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS
          ; own_addr_type_cnt ++){

        int loop_cnt = loop_cnt_set ;
    
    for ( ; loop_cnt > 0
          ; loop_cnt -- ){


        int direct_adv_check = 0 ;
        
        do{

            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);
            
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS,scan_random_addr,&g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
           
            direct_adv_check = (adv_test_params[adv_type_cnt].adv_type  ==  HCI_CMD_PARAM_ADV_DIRECT_IND)
                             &&(dir_addr_type_cnt < HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS) ;
    
            //adv_ideal_cnt = CALC_ADV_CNT(query_time , adv_intval_cnt + ADV_AVG_DELAY_MS  ,success_rate);
            adv_collect_cnt = 
            SCAN_CALC_ADV_DIRECT_CNT(scan_win_set ,scan_intval_set ,adv_intval_cnt  ,success_rate);

          
#if 0
            float x = ((float)(1280));
            float y = ((float)x/(float)(adv_intval_cnt*0.625));
            float z = y* ((float)scan_win_set/(float)scan_intval_set);
            float w = ((float)adv_ch_map_tbl[adv_ch_map_cnt][1] / (float)CH_NUM_MAX);
            LOG_INFO("%f %f %f %f %f\n" , x ,y ,z ,w, z*w*success_rate/100);
#endif

            //LOG_INFO("adv_ideal_cnt = %d\n" , adv_ideal_cnt);
            //while(1){}; 

            // # config adv param
            adv_param_set->Advertising_Interval_Min[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Min[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Interval_Max[0] =  adv_intval_cnt & 0x00ff;
            adv_param_set->Advertising_Interval_Max[1] = (adv_intval_cnt & 0xff00) >> 8;
            adv_param_set->Advertising_Type[0]         =  adv_test_params[adv_type_cnt].adv_type      ;
            adv_param_set->Own_Address_Type[0]         =  own_addr_type_cnt ;
            adv_param_set->Advertising_Channel_Map[0]  =  adv_ch_map_tbl[adv_ch_map_cnt][0]    ;
            adv_param_set->Advertising_Filter_Policy[0] = addr_filter_policy_cnt ;

            LOG_INFO("adv_type_cnt %d \n" , adv_test_params[adv_type_cnt].adv_type);
            LOG_INFO("adv_intval_cnt %d \n", adv_intval_cnt );
            LOG_INFO("adv_ch_map_cnt %d \n", adv_ch_map_cnt );
            LOG_INFO("adv_ch_map %d |cnt %d \n", adv_ch_map_tbl[adv_ch_map_cnt][0] 
                                              , adv_ch_map_tbl[adv_ch_map_cnt][1] );
            LOG_INFO("adv_data_len_cnt %d \n", adv_data_len_cnt );
            LOG_INFO("own_addr_type_cnt %d \n", own_addr_type_cnt );
            LOG_INFO("addr_filter_policy_cnt %d \n", addr_filter_policy_cnt );

            if(adv_test_params[adv_type_cnt].adv_type ==  HCI_CMD_PARAM_ADV_DIRECT_IND){
                LOG_INFO("dir_addr_type_cnt %d \n", dir_addr_type_cnt );
                
                adv_param_set->Direct_Address_Type[0]     =  dir_addr_type_cnt;            

                if (dir_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){

                    LOG_INFO("dir public addr \n");
                    memcpy (adv_param_set->Direct_Address , scan_addr , ADDR_LENGTH);

                }
             
            }
            else{
                LOG_INFO("config non-dir addr type \n");
                
                if (own_addr_type_cnt == HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS){
                    memcpy (adv_param_set->Direct_Address , adv_addr , ADDR_LENGTH);
                }
                else{
                    memcpy (adv_param_set->Direct_Address , adv_random_addr , ADDR_LENGTH);
                }
            }

            // # config adv data
            adv_data_set->Advertising_Data_Length[0]  =  adv_data_len_cnt;

            int data_len_idx = 0;
            
            for ( ; data_len_idx < adv_data_len_cnt  ; data_len_idx ++){
                adv_data_set->Advertising_Data [data_len_idx] = data_len_idx ;            
            }

            adv_enable[0] = HCI_CMD_PARAM_ADV_ENABLE;

            // # prepare to send adv param / data 

            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[0].value = adv_param_set->Advertising_Interval_Min;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[1].value = adv_param_set->Advertising_Interval_Max;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[2].value = adv_param_set->Advertising_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[3].value = adv_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[4].value = adv_param_set->Direct_Address_Type;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[5].value = adv_param_set->Direct_Address;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[6].value = adv_param_set->Advertising_Channel_Map;
            bt_hci_cmd_le_set_advertising_parameters.parameter_tbl[7].value = adv_param_set->Advertising_Filter_Policy;
            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = adv_data_set->Advertising_Data_Length;            
            bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = adv_data_set->Advertising_Data;

            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = scn_data_set->Scan_Response_Data_Length;            
            bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value = scn_data_set->Scan_Response_Data;
                        
            bt_hci_cmd_le_set_advertise_enable.parameter_tbl[0].value = adv_enable ;

            verdict=COMM_ADV_Advertising(dut2_fd);
            VERDICT_RESULT_WITH_LINE();

            printf("run\n");

            // # config scan verify param
#if 0  
            // # scan_intval large than 2 * adv_intval
            u16 scan_intval = 0;
            scan_intval = scan_intval_set ;  

                ((adv_intval_cnt * 3) >= HCI_CMD_PARAM_SCAN_INT_MAX)
                            ?(HCI_CMD_PARAM_SCAN_INT_MAX)
                            :(adv_intval_cnt * 3);
#endif
            scn_param_set->LE_Scan_Type[0]        =   HCI_CMD_PARAM_PASSIVE_SCAN;
            // # if scan_interval = scan_windows , ll should scan continuously P.65
            scn_param_set->LE_Scan_Interval[0]    =   scan_intval_set & 0x00ff ;
            scn_param_set->LE_Scan_Interval[1]    =  (scan_intval_set & 0xff00) >> 8;
            scn_param_set->LE_Scan_Window[0]      =   scan_win_set    & 0x00ff ;
            scn_param_set->LE_Scan_Window[1]      =  (scan_win_set    & 0xff00) >> 8;

            //# should depend on the direct_ind : initA type
            u8 own_addr_cond = 0;
            own_addr_cond = (adv_param_set->Advertising_Type[0] == HCI_CMD_PARAM_ADV_DIRECT_IND ) &&
                            (adv_param_set->Direct_Address_Type[0] == HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS);
            
            if (own_addr_cond){
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_RANDOM_DEVICE_ADDRESS;
            }
            else{
                scn_param_set->Own_Address_Type[0]    =   HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
            }

            LOG_INFO(" scan_own_addr_type %d \n" , scn_param_set->Own_Address_Type[0]);
            
            scn_param_set->Scanning_Filter_Policy[0] =    HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;

            *scn_enable = HCI_CMD_PARAM_SCAN_ENABLE;
            *scan_filter_duplicates = HCI_CMD_PARAM_FILTER_DUPLICATES_DISABLE;

            
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[0].value =scn_param_set->LE_Scan_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[1].value =scn_param_set->LE_Scan_Interval;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[2].value =scn_param_set->LE_Scan_Window;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[3].value =scn_param_set->Own_Address_Type;
            bt_hci_cmd_le_set_scan_parameters.parameter_tbl[4].value =scn_param_set->Scanning_Filter_Policy;                        
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[0].value = scn_enable;
            bt_hci_cmd_le_set_scan_enable.parameter_tbl[1].value = scan_filter_duplicates;

            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            // # to collect the result
            read_le_event_enable();

            int adv_cnt   = 0 ;

            struct timeval start_time;                      
            struct timeval current_time;                      

            gettimeofday(&start_time,NULL);
            printf("+++ %ld %ld +++\n",start_time.tv_sec ,start_time.tv_usec);

            while(1) {
                MSLEEP(1);
                // # query adv_rpt       
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_
                                                        , adv_param_set->Advertising_Type[0])) {               
                                    
                    continue;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(
                                adv_param_set->Advertising_Type[0] , 
                                buf , 
                                g_pattern_param)) {

                    if(buf[_BT_HCI_EVT_ADV_RPT_NUM_RPT] == 0){           
                        if((++cnt % 1000) == 0)
                            printf("No adv rpt data [%d]\n" , cnt);
                    }else{
                        printf("some bytes error\n");                        
                        adv_error_cnt ++ ;
                    }
                    
                }
                else {
                    adv_cnt ++; 
                    printf("adv coming, cnt %d\n" , adv_cnt);               
                } 

                gettimeofday(&current_time,NULL);

                if((current_time.tv_sec - start_time.tv_sec) >= 2){
                    
                    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                        continue;
                    }else if (_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != 
                        hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                        continue;
                    }
                    else {
                        printf("dir timeout coming , loop_cnt %d \n" , loop_cnt);
                        break;
                    }       

                }                  
            }

            LOG_INFO("****adv_cnt = %d | adv_collect_cnt = %d | adv_error_cnt = %d | loop_cnt = %d****\n\n" 
                    , adv_cnt 
                    , adv_collect_cnt 
                    , adv_error_cnt
                    , loop_cnt);

            adv_error_cnt = 0;

            if (adv_cnt < adv_collect_cnt ){
                goto FUN_FAIL;
            }

            // # to check the result
            FUNC_END();

            }while(direct_adv_check);

        dir_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;    

        printf("\n");
    }   //# loop_cnt_set  
    } //# addr_filter_policy_cnt
        own_addr_type_cnt = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    } //# adv_data_len_cnt
        adv_data_len_cnt = 0;
    } //# adv_ch_map_cnt           
        adv_ch_map_cnt = 0;
    } //# adv_intval_cnt
        adv_intval_cnt = 0;
    } //# adv_type_cnt    

    LOG_INFO("[Pattern][%s]SUCCESS \n" ,__FUNCTION__ );

    return SUCCESS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_time_indep_acl_data_len(u8 dut1_fd ,u8 dut2_fd)
{
	int dut1 = 0;
	int dut2 = 0;

	u16 line = 0;
	int verdict = FAIL;
    
	struct itimerval timer;

	u8 buf[SOCKET_BUF_SIZE];    
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];
	u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;
    int mas_pkt_chk = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_TIME_IND_PATTERN_CONFIG_READ();

    int loop_cnt        = 0    ;
	int loop_cnt_set    = g_slave_param_loop_cnt          ; // #param
    int acl_len_cnt     = 0    ; 
    int acl_len_step    = g_slave_param_acl_len_step      ; // #param

    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }

    acl_len_cnt = 1 ;
        
    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(1, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

	while(1)//waiting adv report event , timer or counter
	{
		if(1 == read_le_event_get())
		{
            read_le_event_disable();

			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];			


			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];		

			
			//######################################
            for ( ; loop_cnt < loop_cnt_set ; loop_cnt ++){ 
            
            for ( ; acl_len_cnt <= ACL_DATA_MAX
                  ; acl_len_cnt += acl_len_step){


                COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);                
                
				LOG_INFO("\nacl_len_cnt = %d, loop_cnt = %d\n", acl_len_cnt , loop_cnt);
PKT_CHK:
                // # check disconnection             
                CHECK_NON_DISCONNECT();

    
                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK;
                
                }                 
                
                mas_pkt_chk = 0;

                MSLEEP(10);
                //step2 ~ 4
    			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
    				line = __LINE__;
    				goto FUN_FAIL;

    			}

    			if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }

            }
                acl_len_cnt = 1 ;
            }                            

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;
}


verdict Sla_time_indep_ch_map(u8 dut1_fd ,u8 dut2_fd)
{
	int dut1 = 0;
	int dut2 = 0;

	u16 line = 0;
	int verdict = FAIL;
    
	struct itimerval timer;

	u8 buf[SOCKET_BUF_SIZE];    
	u8 conn_handles_mas[2];
	u8 conn_handles_sla[2];

	u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;
    int sla_pkt_chk = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_TIME_IND_PATTERN_CONFIG_READ();

    int loop_cnt        = 0    ;
	int loop_cnt_set    = g_slave_param_loop_cnt          ; // #param
    int acl_len_cnt     = 0    ; 

    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
	if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	event_query_timer_config(1, 0, 0, 0, &timer);
	event_query_timer_start(timer, read_le_event_enable);

	while(1)//waiting adv report event , timer or counter
	{
		if(1 == read_le_event_get())
		{
            read_le_event_disable();

			if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];			


			if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
				line = __LINE__;
				goto FUN_FAIL;
			}
			if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
				line = __LINE__;
				goto FUN_FAIL;
			}

			conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
			conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];		

            
			//######################################
            for ( ; loop_cnt < loop_cnt_set ; loop_cnt ++){ 

                COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, ACL_DATA_MAX, acl_data);
                
				LOG_INFO("\nacl_len_cnt = %d, loop_cnt = %d\n", ACL_DATA_MAX , loop_cnt);

PKT_CHK:
                // # check disconnection             
                CHECK_NON_DISCONNECT();
    
                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }
                    goto PKT_CHK;
                
                }                 
                
                sla_pkt_chk = 0;


                MSLEEP(10);
                //step2 ~ 4
    			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
    				line = __LINE__;
    				goto FUN_FAIL;

    			}

    			if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
    				line = __LINE__;
    				goto FUN_FAIL;
    			}

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    line=__LINE__;
                    goto FUN_FAIL;
                }

                static u64 ch_map_filp = CH_MAP_ODD;
                ch_map_filp = (~ch_map_filp ) & CH_MAP_FULL ;
                                            
                COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , ch_map_filp );
                verdict = COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
                VERDICT_RESULT_WITH_LINE();

                MSLEEP(500);                
                
/* chmap step
                u64 ch_map = 2 ;
                for ( ; ch_map < CH_MAP_FULL ; ch_map <<= 1){

                    LOG_INFO("chmap MSB %x\n" , (u32)((ch_map+1) >> 32));
                    LOG_INFO("chmap LSB %x\n" , (u32)((ch_map+1) & 0xffffffff));
                    
                    COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , ch_map + 1 );
                    verdict = COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();

                    //# wait for updated ch map used
                    MSLEEP(500);
#if 0 // TI will detect the environment and change ch_map             
                    COMM_Ch_Map_Read_Config(&g_pattern_param , conn_handles_mas);
                    verdict = COMM_Ch_Map_Check(dut1_fd , g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();
#endif                    
                }
*/
            }                            

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            FUNC_END();

			LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
			return PASS;
		}
	}

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;
}

verdict Sla_time_dep_conn_intval(u8 dut1_fd ,u8 dut2_fd)
{
	int dut1 = 0;
	int dut2 = 0;

	u16 line = 0;
	int verdict = FAIL;
    
	struct itimerval timer;

	u8 buf[SOCKET_BUF_SIZE];    
	u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_TIME_DEP_PATTERN_CONFIG_READ();

    int loop_cnt        = 0    ;
	int loop_cnt_set    = g_slave_param_loop_cnt          ; // #param

    int conn_intval_cnt      = HCI_CMD_PARAM_CONN_INT_MIN       ;
    int conn_intval_cnt_step = g_slave_param_conn_intval_step   ; //#param

    u64 conn_alive_time = 0    ;
    u64 conn_wait_time = 0    ;
    struct timeval alive_time   ;
    struct timeval wait_time   ;

    int conn_supervision_timeout   = 1000    ; // # unit = 10ms
        
    Calculate_Execution_Time_Start();

    for ( ; loop_cnt < loop_cnt_set ; loop_cnt ++){

    for ( ; conn_intval_cnt < HCI_CMD_PARAM_CONN_INT_MAX 
          ; conn_intval_cnt += conn_intval_cnt_step){

    // # check with round times
    conn_alive_time = CONN_INTVAL_ROUND_CHECK *CONN_INTVAL_UNIT_US(conn_intval_cnt) ; 

    calc_alive_time(conn_alive_time ,&alive_time);

    LOG_INFO("loop_cnt %d : conn_intval_cnt %d[0x%x]\n" , loop_cnt , conn_intval_cnt , conn_intval_cnt);
    LOG_INFO("%f %f \n" , (float)alive_time.tv_sec , (float)alive_time.tv_usec);
    
    // Uptest(white list) config
RESTART:    
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8; 
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;

    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);    
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);

	g_pattern_param.create_conn_param.Conn_Interval_Min[0]	    =    conn_intval_cnt & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1]	    =   (conn_intval_cnt & 0xff00) >> 8;	
	g_pattern_param.create_conn_param.Conn_Interval_Max[0]	    =    conn_intval_cnt & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1]	    =   (conn_intval_cnt & 0xff00) >> 8;	
	g_pattern_param.create_conn_param.Conn_Latency[0]		    =   HCI_CMD_PARAM_CONN_LATENCY_MIN;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   HCI_CMD_PARAM_CONN_LATENCY_MIN;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=    conn_supervision_timeout & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (conn_supervision_timeout & 0xff00) >> 8;

    
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


    sleep(3);

    LOG_INFO("\ncheck connection complete with dut 1\n");

	if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
		line = __LINE__;
		goto RESTART;
	}
	if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto RESTART;
	}
        
	conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
	conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];			


    LOG_INFO("\ncheck connection complete with dut 2\n");

	if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
		line = __LINE__;
		goto RESTART;
	}
	if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto RESTART;
	}
	
	//######################################

    sleep (alive_time.tv_sec );
    usleep(alive_time.tv_usec);

    // # check disconnection 

    CHECK_NON_DISCONNECT();

    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];

    LOG_INFO("\nsend disconnect with dut 1\n");
    
    COMM_Disconnect_Config(dut1, &g_pattern_param, buf);    
    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    conn_wait_time = 6 *CONN_INTVAL_UNIT_US(conn_intval_cnt) ; 
    calc_alive_time(conn_wait_time ,&wait_time);

    sleep (wait_time.tv_sec );
    usleep(wait_time.tv_usec);

    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }



    FUNC_END();


    }

    conn_intval_cnt      = HCI_CMD_PARAM_CONN_INT_MIN ;

    }


    FUNC_END();
    
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;
}

verdict Sla_time_dep_conn_slave_latency(u8 dut1_fd ,u8 dut2_fd)
{
	int dut1 = 0;
	int dut2 = 0;

	u16 line = 0;
	int verdict = FAIL;
    
	struct itimerval timer;

	u8 buf[SOCKET_BUF_SIZE];    
	u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_TIME_DEP_PATTERN_CONFIG_READ();

    int loop_cnt        = 0    ;
	int loop_cnt_set    = g_slave_param_loop_cnt          ; // # param

    u64 conn_intval_cnt      = 6                           ; // # 30ms
    //u64 conn_intval_cnt_step = HCI_CMD_PARAM_CONN_INT_MAX   ; // # param

    int conn_slave_latency_cnt = 0 ;
    int conn_slave_latency_cnt_step = g_slave_param_conn_slave_latency_step ;

    u64 conn_alive_time = 0     ;
    struct timeval alive_time   ;

    int conn_supervision_timeout   = 3200  ; // # unit = 10ms
        
    Calculate_Execution_Time_Start();

    for ( ; loop_cnt < loop_cnt_set ; loop_cnt ++){

    // # seems 500 is okay...
    for ( ; conn_slave_latency_cnt < HCI_CMD_PARAM_CONN_LATENCY_MAX_V42
          ; conn_slave_latency_cnt += conn_slave_latency_cnt_step){

    // # check alive time with round times
    conn_alive_time = (conn_slave_latency_cnt + 1)* \
                      CONN_INTVAL_ROUND_CHECK * \
                      CONN_INTVAL_UNIT_US(conn_intval_cnt) ; 

    calc_alive_time(conn_alive_time ,&alive_time);

    LOG_INFO("loop_cnt %d slave_latency_cnt %d\n" , loop_cnt , conn_slave_latency_cnt);
    LOG_INFO("alive_time sec :%f usec :%f \n" , (float)alive_time.tv_sec , (float)alive_time.tv_usec);
    
    // Uptest(white list) config
RESTART:    
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;

	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);    
	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);

	g_pattern_param.create_conn_param.Conn_Interval_Min[0]	    =    conn_intval_cnt & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1]	    =   (conn_intval_cnt & 0xff00) >> 8;	
	g_pattern_param.create_conn_param.Conn_Interval_Max[0]	    =    conn_intval_cnt & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1]	    =   (conn_intval_cnt & 0xff00) >> 8;	
	g_pattern_param.create_conn_param.Conn_Latency[0]		    =    conn_slave_latency_cnt & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (conn_slave_latency_cnt & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=    conn_supervision_timeout   & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (conn_supervision_timeout   & 0xff00) >> 8;

    
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


    sleep(1);

	if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
		line = __LINE__;
		goto RESTART;
	}
	if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto RESTART;
	}

	conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
	conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];			


	if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
		line = __LINE__;
		goto RESTART;
	}
	if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto RESTART;
	}
	
	//######################################


    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
    
    COMM_Disconnect_Config(dut1, &g_pattern_param, buf);
    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    //# sleep for waiting disconnect 
    sleep (alive_time.tv_sec );
    usleep(alive_time.tv_usec);

    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if( HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto RESTART;
    }


    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if( HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto RESTART;
    }


    FUNC_END();


    }

    conn_slave_latency_cnt = 0  ;

    }

    FUNC_END();

    
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;
}

verdict Sla_time_dep_conn_supervision_timeout(u8 dut1_fd ,u8 dut2_fd)
{
	int dut1 = 0;
	int dut2 = 0;

	u16 line = 0;
	int verdict = FAIL;
    
	struct itimerval timer;

	u8 buf[SOCKET_BUF_SIZE];    
	u8 conn_handles_mas[2];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_TIME_DEP_PATTERN_CONFIG_READ();

    int loop_cnt        = 0    ;
	int loop_cnt_set    = g_slave_param_loop_cnt            ; // # param

    u64 conn_intval_cnt      = 24                           ; // # 30ms
    //u64 conn_intval_cnt_step = HCI_CMD_PARAM_CONN_INT_MAX   ; // # param

    int conn_slave_latency_cnt        = 0 ;

    int conn_supervision_timeout      = HCI_CMD_PARAM_SUPERVISION_TO_MIN ;
    int conn_supervision_timeout_step = g_slave_param_conn_supervision_timeout_step ;

    u64 conn_alive_time = 0     ;
    struct timeval alive_time   ;
        
    Calculate_Execution_Time_Start();

    for ( ; loop_cnt < loop_cnt_set ; loop_cnt ++){

    for ( ; conn_supervision_timeout < HCI_CMD_PARAM_SUPERVISION_TO_MAX  
          ; conn_supervision_timeout += conn_supervision_timeout_step){

    // # check alive time with round times
    #if 0
    conn_alive_time = (conn_slave_latency_cnt + 1)* \
                      CONN_INTVAL_ROUND_CHECK * \
                      CONN_INTVAL_UNIT_US(conn_intval_cnt) ; 
    #endif
    conn_alive_time = CONN_SUPERTO_UNIT_US(conn_supervision_timeout) ;

    calc_alive_time(conn_alive_time ,&alive_time);

    LOG_INFO("loop_cnt %d conn_supervision_timeout %d\n" , loop_cnt , conn_supervision_timeout);
    LOG_INFO("alive_time sec :%f usec :%f \n" , (float)alive_time.tv_sec , (float)alive_time.tv_usec);
    
    // Uptest(white list) config
RESTART:    
	COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8;	
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);

	VERDICT_RESULT_WITH_LINE();

	COMM_INI_Initiating_Config(dut1, &g_pattern_param);

	g_pattern_param.create_conn_param.Conn_Interval_Min[0]	    =    conn_intval_cnt & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1]	    =   (conn_intval_cnt & 0xff00) >> 8;	
	g_pattern_param.create_conn_param.Conn_Interval_Max[0]	    =    conn_intval_cnt & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1]	    =   (conn_intval_cnt & 0xff00) >> 8;	
	g_pattern_param.create_conn_param.Conn_Latency[0]		    =    conn_slave_latency_cnt & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (conn_slave_latency_cnt & 0xff00) >> 8;;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=    conn_supervision_timeout   & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (conn_supervision_timeout   & 0xff00) >> 8;

    
	verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();


    sleep(1);

	if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
		line = __LINE__;
		goto RESTART;
	}
	if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto RESTART;
	}

	conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
	conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];			


	if (SUCCESS != QUERY_LE_Event(dut2_fd, buf,	_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
		line = __LINE__;
		goto RESTART;
	}
	if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto RESTART;
	}
	
	//######################################

    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
    
    COMM_Disconnect_Config(dut1, &g_pattern_param, buf);
    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //# sleep for waiting disconnect 
    sleep (alive_time.tv_sec );
    usleep(alive_time.tv_usec);


    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if( HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    FUNC_END();


    }

    conn_supervision_timeout      = HCI_CMD_PARAM_SUPERVISION_TO_MIN ;

    }

    FUNC_END();


    
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;

FUN_FAIL:
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
	return FAIL;
}

verdict Adv_modify_adv_data_and_scn_rsp_data(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    int dut1 = 0;
    u16 line;    
   
    u8 adv_data = 0;
    int adv_data_cnt = 0;
    u8 scn_rsp_data = 0x55;
    int scn_rsp_data_cnt = 0;

    int adv_type_cnt = 0;
    int query_adv_event_type = 0;
    int scn_type_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    int scan_intval = 300; //ms
    u64 poll_time   = 10 * MS2US(scan_intval);
    
	struct itimerval timer;

    Calculate_Execution_Time_Start();

    for(adv_type_cnt = 0; adv_type_cnt < 4; adv_type_cnt++) {
        if(adv_type_cnt == HCI_CMD_PARAM_ADV_DIRECT_IND) {
            continue;
        }
        for(scn_type_cnt = 0; scn_type_cnt < 2; scn_type_cnt++) {

            // # config white list @ scanner
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, adv_addr, &g_pattern_param);
            COMM_Add_Device_To_White_List(dut1_fd, g_pattern_param);

            // # config white list @ advertiser
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, scan_addr, &g_pattern_param);
            COMM_Add_Device_To_White_List(dut2_fd, g_pattern_param);

            // # scanner config
            if(scn_type_cnt == HCI_CMD_PARAM_PASSIVE_SCAN) {
                printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
                COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);   
                set_scan_interval(300);
                set_scan_windows(300);
                set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
                verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();
            }
            else if(scn_type_cnt == HCI_CMD_PARAM_ACTIVE_SCAN) {
                printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
                COMM_SCN_Active_Scanning_Config(0, &g_pattern_param);
                set_scan_interval(300);
                set_scan_windows(300);
                set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        
	            verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
	            VERDICT_RESULT_WITH_LINE(); 
            }
            else {
                line = __LINE__ ;
                goto FUN_FAIL;
            }
            
            // # advertiser config
            if(adv_type_cnt == HCI_CMD_PARAM_ADV_IND) {
                printf("\nHCI_CMD_PARAM_ADV_IND\n");
                COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
                g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
                g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
                g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
                g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
                set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
                verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();

                query_adv_event_type = HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND;
            }
            else if(adv_type_cnt == HCI_CMD_PARAM_ADV_SCAN_IND) {
                printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
                COMM_Scan_Response_Data_Set_Config(dut2_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
                verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();

                COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
                g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
                g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
                g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
                g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
                set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
                verdict = COMM_ADV_Discoverable_Advertising(dut2_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();

                query_adv_event_type = HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND;
            }else if(adv_type_cnt == HCI_CMD_PARAM_ADV_NONCONN_IND) {
                printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
                COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
                g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
                g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
                g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
                g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
                set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
                verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();

                query_adv_event_type = HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND;
            }
            else {
                line = __LINE__ ;
                goto FUN_FAIL;
            }
            
            adv_data = 0;

            while(adv_data < 10) {
                for (adv_data_cnt = 0; adv_data_cnt	< HCI_CMD_PARAM_ADV_DATA_LEN_MAX ; adv_data_cnt++)
        			g_pattern_param.adv_data_param.Advertising_Data[adv_data_cnt] = adv_data;

                verdict = COMM_ADV_Advertising_Data_Set(dut2_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();
                printf("\nUpdate adv_data %x\n", adv_data);

                if(adv_type_cnt != HCI_CMD_PARAM_ADV_NONCONN_IND) {
                    for (scn_rsp_data_cnt = 0; scn_rsp_data_cnt	< HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX ; scn_rsp_data_cnt++)
            			g_pattern_param.scn_rsp_param.Scan_Response_Data[scn_rsp_data_cnt] = scn_rsp_data;

                    verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
                    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_COMMAND_DISALLOWED);
                }

                usleep(poll_time);
         
                if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, query_adv_event_type)) {                                          
                    line = __LINE__ ;
                    goto FUN_FAIL;
                }            
                else if(EQUAL != hci_le_event_advertising_report_parsing(query_adv_event_type, buf, g_pattern_param)) {
                    printf("\nRecv adv_data %x\n", buf[_BT_HCI_EVT_ADV_RPT_DATA]);
                    printf("adv not coming\n");
                    line = __LINE__ ;
                    goto FUN_FAIL;
                }
                else {
                    printf("\nRecv adv_data %x\n", buf[_BT_HCI_EVT_ADV_RPT_DATA]);
                }
               
                adv_data++;
            }  

            dut_reset_with_mask_en(dut1_fd);
            dut_reset_with_mask_en(dut2_fd);

        }
    }

    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Sla_check_conn_with_all_adv_type (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;

    struct itimerval timer;

    u8 buf[SOCKET_BUF_SIZE];    
    //u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    int adv_type_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    int conn_intval     = 40;
    int sla_latency     = 0;
    int supervisionTO   = 3200;    
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    for(adv_type_cnt = 0; adv_type_cnt < 4; adv_type_cnt++) {

        // Uptest(white list) config
        COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
        memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
        g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
        verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        // # advertiser config
        if(adv_type_cnt == HCI_CMD_PARAM_ADV_IND) {
            printf("\nHCI_CMD_PARAM_ADV_IND\n");
            COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
            set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
            g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        }
        else if(adv_type_cnt == HCI_CMD_PARAM_ADV_SCAN_IND) {
            printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
            COMM_Scan_Response_Data_Set_Config(dut2_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
            verdict = COMM_Scan_Response_Data_Set(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            COMM_ADV_Discoverable_Advertising_Config(0, &g_pattern_param);
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
            set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
            g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            verdict = COMM_ADV_Discoverable_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        }else if(adv_type_cnt == HCI_CMD_PARAM_ADV_NONCONN_IND) {
            printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
            COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
            g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
            g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
            set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
            g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        }
        else if(adv_type_cnt == HCI_CMD_PARAM_ADV_DIRECT_IND) {
            COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
            g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
            verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        }
        else {
            line = __LINE__ ;
            goto FUN_FAIL;
        }

        COMM_INI_Initiating_Config(dut1, &g_pattern_param);

        g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xE0;
        g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0x01;
        g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xE0;
        g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0x01;

        g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
        g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
        g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
        g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
        g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
        g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
        //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
        //superviision TO > (1+connSlaveLatency)*Conninterval
        g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
        g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
        
        verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        sleep(5);

        if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }

        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
            
            printf("\nfail dut1 0x%x\n", buf[_BT_HCI_EVT_CON_COMP_STATUS]);
            if(adv_type_cnt != HCI_CMD_PARAM_ADV_SCAN_IND && adv_type_cnt != HCI_CMD_PARAM_ADV_NONCONN_IND) {
                line = __LINE__;
                goto FUN_FAIL;
            }
        }
        else {
            printf("\nsucess dut1 0x%x\n", buf[_BT_HCI_EVT_CON_COMP_STATUS]);
        }

        //conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        //conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1]; 

        if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }

        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
            printf("\nfail adv_type %d, dut2 0x%x\n", adv_type_cnt, buf[_BT_HCI_EVT_CON_COMP_STATUS]);
            if(adv_type_cnt != HCI_CMD_PARAM_ADV_SCAN_IND && adv_type_cnt != HCI_CMD_PARAM_ADV_NONCONN_IND) {
                line = __LINE__;
                goto FUN_FAIL;
            }
        }
        else {
            printf("\nsucess adv_type %d, dut2 0x%x\n", adv_type_cnt, buf[_BT_HCI_EVT_CON_COMP_STATUS]);
        }

        conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];         

        //######################################
        if (((conn_handles_sla[1] << 8) + conn_handles_sla[0]) == 0x3) {
            printf("\ndisconnect\n");
            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];

            COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0] = HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
        }
        dut_reset_with_mask_en(dut1_fd);
        dut_reset_with_mask_en(dut2_fd);
    }

    
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);

    return PASS;    
                        
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);

    return FAIL;
}

verdict Whitelist_add_remove(u8 dut_fd)
{
    int verdict = FAIL;
    u16 line;    

    COMM_Dut_clean_buffer(dut_fd);
        
    //# boundary testing
    verdict = COMM_Read_LE_White_List_Size(dut_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();   

    s8 left_size = g_pattern_param.white_list_param.Size[0];
    while ( left_size >= 0 ){
        LOG_INFO("[Round 1 => left %d]\n" , left_size);

        COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr + left_size,&g_pattern_param);
        verdict = COMM_Add_Device_To_White_List(dut_fd,g_pattern_param);        

        if (left_size > 0){
            VERDICT_RESULT_WITH_LINE();
        }
        else{
            VERDICT_FAIL_RESULT_WITH_LINE();            
        }

        left_size -- ;        
    }

    //# duplicate addr testing
    verdict = COMM_Clear_White_List(dut_fd);        
    VERDICT_RESULT_WITH_LINE(); 

    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut_fd,g_pattern_param);    
    VERDICT_RESULT_WITH_LINE();

    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut_fd,g_pattern_param);    
    VERDICT_FAIL_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut_fd,g_pattern_param); 
    VERDICT_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut_fd,g_pattern_param); 
    VERDICT_FAIL_RESULT_WITH_LINE();

    //# different addr testing
    verdict = COMM_Clear_White_List(dut_fd);        
    VERDICT_RESULT_WITH_LINE(); 

    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut_fd,g_pattern_param);    
    VERDICT_RESULT_WITH_LINE();

    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut_fd,g_pattern_param);    
    VERDICT_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut_fd,g_pattern_param); 
    VERDICT_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut_fd,g_pattern_param); 
    VERDICT_RESULT_WITH_LINE();
    
    left_size = g_pattern_param.white_list_param.Size[0];
    
    while ( left_size >= 0 ){
        LOG_INFO("[Round 2 => %d]\n" , left_size);

        COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr + left_size,&g_pattern_param);
        verdict = COMM_Add_Device_To_White_List(dut_fd,g_pattern_param);        

        if (left_size > 0){
            VERDICT_RESULT_WITH_LINE();
        }
        else{
            VERDICT_FAIL_RESULT_WITH_LINE();
        }

        left_size -- ;        
    }

    verdict = COMM_Clear_White_List(dut_fd);        
    VERDICT_RESULT_WITH_LINE(); 

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;


FUN_FAIL:
    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}


verdict Whitelist_adv(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    int dut1 = 0;
    u16 line;    

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_STABLE_PATTERN_CONFIG_READ();

    int scan_intval = g_adv_stable_scan_intval ; // #param
    
    struct itimerval timer;
    struct timeval start_time;                      
        
    Calculate_Execution_Time_Start();

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

    // # scanner config
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);   
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (scan_intval & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (scan_intval & 0xff00) >> 8;   
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Channel_Map[0]  =  HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0]   =  \
        HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;       
    gettimeofday(&start_time,NULL);
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_Read_LE_White_List_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();   

    LOG_INFO("Run case 1\n");
    // # adv enable with filter policy      ; can not add / remove /clear
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut2_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    verdict = COMM_Clear_White_List(dut2_fd);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    sleep(1);
    if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {                                          
        line = __LINE__ ;
        goto FUN_FAIL;
    }            
    else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
        LOG_INFO("adv not coming\n");
        line = __LINE__ ;
        goto FUN_FAIL;
    }


    COMM_ADV_Disable_Config(dut2_fd,&g_pattern_param);
    COMM_ADV_Disable(dut2_fd,g_pattern_param);

    LOG_INFO("Run case 2\n");
    // # adv enable without filter policy   ; can     add / remove /clear  
    g_pattern_param.adv_param.Advertising_Filter_Policy[0]   =  \
        HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;       
    gettimeofday(&start_time,NULL);
    
	g_pattern_param.Advertising_Enable[0] = HCI_CMD_PARAM_ADV_ENABLE;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    // # adv enable with filter policy      ; can not add / remove /clear
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut2_fd,g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_Clear_White_List(dut2_fd);            
    VERDICT_RESULT_WITH_LINE();

    sleep(1);
    if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {                                          
        line = __LINE__ ;
        goto FUN_FAIL;
    }            
    else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
        LOG_INFO("adv not coming\n");
        line = __LINE__ ;
        goto FUN_FAIL;
    }

    COMM_ADV_Disable_Config(dut2_fd,&g_pattern_param);
    COMM_ADV_Disable(dut2_fd,g_pattern_param);

    FUNC_END();            
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;


FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}


verdict Whitelist_scn(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    int dut1 = 0;
    u16 line;    

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SCN_STABLE_PATTERN_CONFIG_READ();

    int scan_intval = g_scn_stable_scan_intval ; // #param
    
    struct itimerval timer;
    struct timeval start_time;                      
        
    Calculate_Execution_Time_Start();

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

    // # scanner config
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);   
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (scan_intval & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (scan_intval & 0xff00) >> 8;   
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Channel_Map[0]  =  HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0]   =  \
        HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY;       
    gettimeofday(&start_time,NULL);
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 


    LOG_INFO("Run case 1\n");
    // # scan enable with filter policy      ; can not add / remove /clear
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    sleep(1);
    if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {                                          
        line = __LINE__ ;
        goto FUN_FAIL;
    }            
    else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
        LOG_INFO("adv not coming\n");
        line = __LINE__ ;
        goto FUN_FAIL;
    }


    COMM_SCN_Disable_Config(dut1_fd,&g_pattern_param);
    COMM_SCN_Disable(dut1_fd,g_pattern_param);

    LOG_INFO("Run case 2\n");
    // # scan enable without filter policy   ; can     add / remove /clear  
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  
        HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS;
     
    gettimeofday(&start_time,NULL);
    
    g_pattern_param.Scan_Enable[0] = HCI_CMD_PARAM_SCAN_ENABLE;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    // # scn enable with filter policy      ; can add / remove /clear
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_RESULT_WITH_LINE();

    sleep(1);
    if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {                                          
        line = __LINE__ ;
        goto FUN_FAIL;
    }            
    else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
        LOG_INFO("adv not coming\n");
        line = __LINE__ ;
        goto FUN_FAIL;
    }

    COMM_SCN_Disable_Config(dut1_fd,&g_pattern_param);
    COMM_SCN_Disable(dut1_fd,g_pattern_param);


    FUNC_END();            
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;


FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Whitelist_adv_scn(u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    u16 line;    

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);
    
    struct itimerval timer;
    struct timeval start_time;                      
        
    Calculate_Execution_Time_Start();

    // # config white list
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);

    // # scanner config
    COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
    set_scan_interval(300);    
    set_scan_windows(300);
     
    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    set_adv_interval(20);
    g_pattern_param.adv_param.Advertising_Channel_Map[0]  =  HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
               
    gettimeofday(&start_time,NULL);

    LOG_INFO("Run case 1\n");
    LOG_INFO("# adv + scan\n"); 
    LOG_INFO("adv  enable with filter policy          ; can not add / remove /clear\n");
    LOG_INFO("scan enable with filter policy          ; can not add / remove /clear\n");

    set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY) ;
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);

    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_FAIL_RESULT_WITH_LINE();


    COMM_ADV_Disable_Config( 0 ,&g_pattern_param);
    COMM_ADV_Disable(dut1_fd,g_pattern_param);

    COMM_SCN_Disable_Config( 0 ,&g_pattern_param);
    COMM_SCN_Disable(dut1_fd,g_pattern_param);

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    LOG_INFO("\n");
    LOG_INFO("Run case 2\n");
    LOG_INFO("# adv + scan\n"); 
    LOG_INFO("adv  enable with    filter policy      ; can not add / remove /clear\n");
    LOG_INFO("scan enable without filter policy      ; can     add / remove /clear\n");

    COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
    set_scan_interval(300);    
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS);
     
    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    set_adv_interval(20);
    set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY) ;


    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_FAIL_RESULT_WITH_LINE();


    COMM_ADV_Disable_Config( 0 ,&g_pattern_param);
    COMM_ADV_Disable(dut1_fd,g_pattern_param);

    COMM_SCN_Disable_Config( 0 ,&g_pattern_param);
    COMM_SCN_Disable(dut1_fd,g_pattern_param);

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_RESULT_WITH_LINE();

    sleep(1);


    LOG_INFO("Run case 3\n");
    LOG_INFO("# adv + scan "); 
    LOG_INFO("adv  enable without filter policy       ; can     add / remove /clear\n");
    LOG_INFO("scan enable with    filter policy       ; can not add / remove /clear\n");


    COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
    set_scan_interval(300);    
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY);
     
    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    set_adv_interval(20);
    set_adv_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY) ;

    COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_FAIL_RESULT_WITH_LINE();

    COMM_ADV_Disable_Config( 0 ,&g_pattern_param);
    COMM_ADV_Disable(dut1_fd,g_pattern_param);

    COMM_SCN_Disable_Config( 0 ,&g_pattern_param);
    COMM_SCN_Disable(dut1_fd,g_pattern_param);

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_RESULT_WITH_LINE();

    sleep(1);


    LOG_INFO("Run case 4\n");
    LOG_INFO("# adv + scan \n"); 
    LOG_INFO("adv  enable without filter policy       ; can     add / remove /clear\n");
    LOG_INFO("scan enable without filter policy       ; can     add / remove /clear\n");

    COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
    set_scan_interval(300);    
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY);
     
    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    set_adv_interval(20);
    set_adv_policy(HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS) ;


    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
    verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Disable_Config( 0 ,&g_pattern_param);
    COMM_ADV_Disable(dut1_fd,g_pattern_param);

    COMM_SCN_Disable_Config( 0 ,&g_pattern_param);
    COMM_SCN_Disable(dut1_fd,g_pattern_param);

    verdict = COMM_Clear_White_List(dut1_fd);            
    VERDICT_RESULT_WITH_LINE();

    FUNC_END();            
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;


FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Whitelist_adv_scn_sla(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
    
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);

    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    } 

    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
	g_pattern_param.create_conn_param.Conn_Latency[0]		= 5 ;
	g_pattern_param.create_conn_param.Conn_Latency[1]		= 0 ;
	//The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
	//superviision TO > (1+connSlaveLatency)*Conninterval
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=0x14 ; // 20 * 10ms
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=0x00 ; //

    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(3, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            //######################################

            LOG_INFO("Run case 1\n");
            LOG_INFO("# adv + scan\n"); 
            LOG_INFO("adv  enable with filter policy          ; can not add / remove /clear\n");
            LOG_INFO("scan enable with filter policy          ; can not add / remove /clear\n");

            COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
            set_scan_interval(300);    
            set_scan_windows(300);
            set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);            
            verdict = COMM_SCN_Passive_Scanning(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            set_adv_interval(100);
            set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY) ;            
            verdict = COMM_ADV_NonConnectable_Advertising(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE(); 
            
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            verdict = COMM_Clear_White_List(dut1_fd);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            
            COMM_ADV_Disable_Config( 0 ,&g_pattern_param);
            COMM_ADV_Disable(dut1_fd,g_pattern_param);
            
            COMM_SCN_Disable_Config( 0 ,&g_pattern_param);
            COMM_SCN_Disable(dut1_fd,g_pattern_param);
            
            verdict = COMM_Clear_White_List(dut1_fd);            
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1);
            
            LOG_INFO("\n");
            LOG_INFO("Run case 2\n");
            LOG_INFO("# adv + scan\n"); 
            LOG_INFO("adv  enable with    filter policy      ; can not add / remove /clear\n");
            LOG_INFO("scan enable without filter policy      ; can     add / remove /clear\n");
            
            COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
            set_scan_interval(300);    
            set_scan_windows(300);
            set_scan_policy(HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS);
             
            // # advertiser config
            COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            set_adv_interval(100);

            set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY) ;
            
            
            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            verdict = COMM_ADV_NonConnectable_Advertising(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE(); 
            
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            verdict = COMM_Clear_White_List(dut1_fd);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            
            COMM_ADV_Disable_Config( 0 ,&g_pattern_param);
            COMM_ADV_Disable(dut1_fd,g_pattern_param);
            
            COMM_SCN_Disable_Config( 0 ,&g_pattern_param);
            COMM_SCN_Disable(dut1_fd,g_pattern_param);
            
            verdict = COMM_Clear_White_List(dut1_fd);            
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1);
            
            LOG_INFO("\n");            
            LOG_INFO("Run case 3\n");
            LOG_INFO("# adv + scan \n"); 
            LOG_INFO("adv  enable without filter policy       ; can     add / remove /clear\n");
            LOG_INFO("scan enable with    filter policy       ; can not add / remove /clear\n");
            
            
            COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
            set_scan_interval(300);    
            set_scan_windows(300);
            set_scan_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY);
             
            // # advertiser config
            COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            set_adv_interval(100);

            set_adv_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY) ;
            
            COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            verdict = COMM_ADV_NonConnectable_Advertising(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE(); 
            
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            verdict = COMM_Clear_White_List(dut1_fd);            
            VERDICT_FAIL_RESULT_WITH_LINE();
            
            COMM_ADV_Disable_Config( 0 ,&g_pattern_param);
            COMM_ADV_Disable(dut1_fd,g_pattern_param);
            
            COMM_SCN_Disable_Config( 0 ,&g_pattern_param);
            COMM_SCN_Disable(dut1_fd,g_pattern_param);
            
            verdict = COMM_Clear_White_List(dut1_fd);            
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1);
            
            LOG_INFO("\n");            
            LOG_INFO("Run case 4\n");
            LOG_INFO("# adv + scan \n"); 
            LOG_INFO("adv  enable without filter policy       ; can     add / remove /clear\n");
            LOG_INFO("scan enable without filter policy       ; can     add / remove /clear\n");
            
            COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);
            set_scan_interval(300);    
            set_scan_windows(300);
            set_scan_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY);
             
            // # advertiser config
            COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
            set_adv_interval(100);

            set_adv_policy(HCI_CMD_PARAM_ACCEPT_ALL_ADV_PKTS) ;
            
            
            verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            verdict = COMM_ADV_NonConnectable_Advertising(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE(); 
            
            COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            verdict = COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_random_addr,&g_pattern_param);
            verdict = COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);            
            VERDICT_RESULT_WITH_LINE();
            
            verdict = COMM_Clear_White_List(dut1_fd);            
            VERDICT_RESULT_WITH_LINE();
            
            COMM_ADV_Disable_Config( 0 ,&g_pattern_param);
            COMM_ADV_Disable(dut1_fd,g_pattern_param);
            
            COMM_SCN_Disable_Config( 0 ,&g_pattern_param);
            COMM_SCN_Disable(dut1_fd,g_pattern_param);
            
            verdict = COMM_Clear_White_List(dut1_fd);            
            VERDICT_RESULT_WITH_LINE();



            //######################################
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
			buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
			
			COMM_Disconnect_Config(dut1,&g_pattern_param,buf);
			verdict=COMM_Disconnect(dut1_fd,g_pattern_param);
			VERDICT_RESULT_WITH_LINE();

            FUNC_END();


            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:

    FUNC_END();

    
    LOG_INFO("[Pattern][%s]:%d channel : %d FAIL!!\n" , __FUNCTION__, line, adv_Channel);
    return FAIL;
}


verdict Adv_stability_with_adv_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    int dut1 = 0;
    u16 line;    
    u64 adv_cnt = 0;    

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_STABLE_PATTERN_CONFIG_READ();

    int scan_intval = g_adv_stable_scan_intval ; // #param
    u64 poll_time   = 30 * MS2US(scan_intval) * 0.625;
    int test_time   = g_adv_stable_test_time;  //# param
    
	struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;                      
        
    Calculate_Execution_Time_Start();

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
    
    // # scanner config
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);   
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (scan_intval & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (scan_intval & 0xff00) >> 8;
    
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN & 0xff00) >> 8;
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 
    
    gettimeofday(&start_time,NULL);

    while(1) {

        usleep(poll_time);
        if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {                                          
            continue;
        }            
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
            printf("adv not coming\n");
            line = __LINE__ ;
            goto FUN_FAIL;
        }
        else {
            adv_cnt++; 
            printf("adv coming, chk %lld\n\n" , adv_cnt);
        }
                
        gettimeofday(&current_time,NULL);
    
        if((current_time.tv_sec - start_time.tv_sec) >= test_time){            
            FUNC_END();            
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }        

    }                
    
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Adv_stability_with_adv_scan_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    int dut1 = 0;
    u16 line;    
    u64 adv_cnt = 0;    

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_STABLE_PATTERN_CONFIG_READ();

    int scan_intval = g_adv_stable_scan_intval ; // #param
    u64 poll_time   = 30 * MS2US(scan_intval) * 0.625;
    int test_time   = g_adv_stable_test_time;  //# param
    
	struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;                      
        
    Calculate_Execution_Time_Start();

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
    
    // # scanner config
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);   
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (scan_intval & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (scan_intval & 0xff00) >> 8;
    
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # advertiser config
    COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
    verdict = COMM_ADV_Discoverable_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 
    
    gettimeofday(&start_time,NULL);

    while(1) {

        usleep(poll_time);
        if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND)) {                                          
            continue;
        }            
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_IND, buf, g_pattern_param)) {
            printf("adv not coming\n");
            line = __LINE__ ;
            goto FUN_FAIL;
        }
        else {
            adv_cnt++; 
            printf("adv coming, chk %lld\n\n" , adv_cnt);
        }
                
        gettimeofday(&current_time,NULL);
    
        if((current_time.tv_sec - start_time.tv_sec) >= test_time){            
            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }        

    }                
    
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Adv_stability_with_adv_non_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    int dut1 = 0;
    u16 line;    
    u64 adv_cnt = 0;    

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_STABLE_PATTERN_CONFIG_READ();

    int scan_intval = g_adv_stable_scan_intval ; // #param
    u64 poll_time   = 30 * MS2US(scan_intval) * 0.625;
    int test_time   = g_adv_stable_test_time;  //# param
    
	struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;                      
        
    Calculate_Execution_Time_Start();

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
    
    // # scanner config
    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);   
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (scan_intval & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (scan_intval & 0xff00) >> 8;
    
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # advertiser config
    COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_SCAN_OR_NONCONN_IND & 0xff00) >> 8;
    verdict = COMM_ADV_NonConnectable_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 
    
    gettimeofday(&start_time,NULL);

    while(1) {

        usleep(poll_time);
        if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND)) {                                          
            continue;
        }            
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_NONCONN_IND, buf, g_pattern_param)) {
            printf("adv not coming\n");
            line = __LINE__ ;
            goto FUN_FAIL;
        }
        else {
            adv_cnt++; 
            printf("adv coming, chk %lld\n\n" , adv_cnt);
        }
                
        gettimeofday(&current_time,NULL);
    
        if((current_time.tv_sec - start_time.tv_sec) >= test_time){            
            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);

            return PASS;
        }        

    }                
    
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Adv_stability_with_adv_direct_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    int dut1 = 0;
    u16 line;    
    u64 adv_cnt = 0;    

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    ADV_STABLE_PATTERN_CONFIG_READ();

    int scan_intval = g_adv_stable_scan_intval ; // #param
    u64 poll_time   = 30 * MS2US(scan_intval) * 0.625;
    int loop_cnt    = g_adv_stable_loop_cnt ;
    
	struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;                      
        
    Calculate_Execution_Time_Start();

    for ( ; loop_cnt > 0
          ; loop_cnt -- ){

        // # config white list @ scanner
        COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
        COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
        
        // # scanner config
        COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);   
        g_pattern_param.scn_param.LE_Scan_Interval[0] =  scan_intval & 0x00ff;
        g_pattern_param.scn_param.LE_Scan_Interval[1] = (scan_intval & 0xff00) >> 8;
        g_pattern_param.scn_param.LE_Scan_Window[0] =    scan_intval & 0x00ff;
        g_pattern_param.scn_param.LE_Scan_Window[1] =   (scan_intval & 0xff00) >> 8;
        
        g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
        verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        // # advertiser config
        COMM_ADV_Directed_Advertising_Config(0, &g_pattern_param);        
        g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
        verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE(); 
        
        gettimeofday(&start_time,NULL);

        while(1) {

            usleep(poll_time);
            
            if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {                                          
                continue;
            }            
            else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf, g_pattern_param)) {
                printf("adv not coming\n");
            }
            else {
                adv_cnt++; 
                printf("adv coming, chk %lld\n\n" , adv_cnt);
            }
                    

            gettimeofday(&current_time,NULL);

            if((current_time.tv_sec - start_time.tv_sec) >= 2){

                if(adv_cnt == 0){
                    line = __LINE__ ;
                    goto FUN_FAIL;
                }
                    
                
                if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                    continue;
                }else if (_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != 
                    hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                    continue;
                }
                else {
                    printf("dir timeout coming , loop_cnt %d \n" , loop_cnt);
                    adv_cnt = 0 ;
                    break;
                }       
            }     

        }              
        FUNC_END();
    }

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Scn_stability_passive_with_adv_ind(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    u16 line;    
    u64 adv_cnt = 0;    
    int adv_err_cnt = 0 ;
    int adv_poll_cnt = 100 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SCN_STABLE_PATTERN_CONFIG_READ();

    int adv_intval  = g_scn_stable_adv_intval  ; // #param
    int scan_intval = g_scn_stable_scan_intval ; // #param
    int scan_window = g_scn_stable_scan_window ; // #param

    u64 poll_time   = 30 * MS2US(scan_intval) * 0.625;
    int test_time   = g_scn_stable_test_time;  //# param
    
	struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;                      
        
    Calculate_Execution_Time_Start();

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
    
    // # scanner config
    COMM_SCN_Passive_Scanning_Config( 0 , &g_pattern_param);   
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (scan_intval & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    scan_window & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (scan_window & 0xff00) >> 8;
    
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);

    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
    set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 
    
    gettimeofday(&start_time,NULL);

    while(1) {

        usleep(poll_time);
        if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {                                          
            continue;
        }            
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
            printf("adv not coming\n");
            adv_err_cnt ++ ;

            // #something wrong with advertiser
            if (adv_err_cnt > adv_poll_cnt ){
                goto FUN_FAIL ;
            }
                
            continue;

        }
        else {
            adv_cnt++;
            adv_err_cnt = 0 ;
            printf("adv coming, chk %lld\n\n" , adv_cnt);
        }
                
        gettimeofday(&current_time,NULL);
    
        if((current_time.tv_sec - start_time.tv_sec) >= test_time){
            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);

            return PASS;
        }        

    }                
    
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Scn_stability_active_with_adv_ind_scn_rsp(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];   
    int verdict = FAIL;
    u16 line;    
    int adv_cnt = 0;
    int adv_err_cnt = 0 ;
    int adv_poll_cnt = 100 ;
    int scn_cnt = 0;    
    int scn_err_cnt = 0 ;
    int scn_poll_cnt = 100 ;


    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SCN_STABLE_PATTERN_CONFIG_READ();

    int adv_intval  = g_scn_stable_adv_intval  ; // #param
    int scan_intval = g_scn_stable_scan_intval ; // #param
    int scan_window = g_scn_stable_scan_window ; // #param

    u64 poll_time   = 30 * MS2US(scan_intval) * 0.625;
    int test_time   = g_scn_stable_test_time;  //# param
    
	struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;                      
        
    Calculate_Execution_Time_Start();

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,adv_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut1_fd,g_pattern_param);
    
    // # scanner config
    COMM_SCN_Active_Scanning_Config( 0 , &g_pattern_param);   
    g_pattern_param.scn_param.LE_Scan_Interval[0] =  scan_intval & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1] = (scan_intval & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0] =    scan_window & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1] =   (scan_window & 0xff00) >> 8;
    
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]   =  HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS,scan_addr,&g_pattern_param);
    COMM_Add_Device_To_White_List(dut2_fd,g_pattern_param);

    // # advertiser config
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 
    
    gettimeofday(&start_time,NULL);

    while(1) {

        gettimeofday(&current_time,NULL);
    
        if((current_time.tv_sec - start_time.tv_sec) >= test_time){
            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);

            return PASS;
        }   

        usleep(poll_time);
        
        if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND)) {                                          
            continue;
        }            
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_ADV_IND, buf, g_pattern_param)) {
            printf("adv not coming\n");
            adv_err_cnt ++ ;

            // #something wrong with advertiser
            if (adv_err_cnt > adv_poll_cnt ){
                line = __LINE__ ;
                goto FUN_FAIL ;
            }
                
            continue;
        }
        else {
            adv_cnt++; 
            adv_err_cnt = 0 ;
            printf("adv coming, chk %d\n\n" , adv_cnt);
        }

        if(SUCCESS != QUERY_LE_Event(dut1_fd,buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP)) {                                          
            continue;
        }            
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_SCAN_RSP, buf, g_pattern_param)) {
            printf("scn_rsp not coming\n");
            scn_err_cnt ++ ;
        
            // #something wrong with advertiser
            if (scn_err_cnt > scn_poll_cnt ){
                line = __LINE__ ;                
                goto FUN_FAIL ;
            }
                
            continue;
        }
        else {
            scn_cnt++; 
            scn_err_cnt = 0 ;
            printf("scn_rsp coming, chk %d\n\n" , scn_cnt);
        }

    }                
    
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n", __FUNCTION__, line);
    return FAIL;

}

verdict Sla_conn_adv_ind(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_TIME_IND_PATTERN_CONFIG_READ();

    int loop_cnt        = 0    ;
    int loop_cnt_set    = 10   ;//g_slave_param_loop_cnt          ; // #param
    //int ch_map_cnt      = 0    ; 
    //u16 ch_map_step     = g_slave_param_ch_map_step       ; // #param


    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    //g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_AND_CONN_REQ_FROM_ANY ;
    g_pattern_param.adv_param.Advertising_Interval_Max[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1] = (0x00a0 & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0] =  0x00a0 & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Min[1] = (0x00a0 & 0xff00) >> 8; 
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    //verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);

    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(3, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            //######################################
            for ( ; loop_cnt < loop_cnt_set ; loop_cnt ++){ 

                printf("run loop %d\n" , loop_cnt);

                u64 ch_map = 2 ;
                
                for ( ; ch_map < CH_MAP_FULL ; ch_map <<= 1){
                    //LOG_INFO("check ch_map %lld\n" , ch_map + 1 );
                    COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , ch_map + 1 );
                    verdict = COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();

                    //# wait for updated ch map used
                    MSLEEP(500);
#if 0 // TI will detect the environment and change ch_map             
                    COMM_Ch_Map_Read_Config(&g_pattern_param , conn_handles_mas);
                    verdict = COMM_Ch_Map_Check(dut1_fd , g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();
#endif                    

                }
            }    

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            FUNC_END();
            
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;

        }
    }


FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stability_conn_with_tx_acl_data(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};

    int sla_pkt_chk = 0 ;
    int sla_acl_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    u32 round           = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    u64 sleep_time = 0    ;
    struct timeval alive_time   ;
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
            
        fill_data(acl_data , ++round);

        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);
            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

PKT_CHK:
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);
                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                goto PKT_CHK;
            } 

            sla_pkt_chk = 0;

            printf("\n##get number of completed packets##\n");

ACL_CHK:    
            //step2 ~ 4
            CHECK_NON_DISCONNECT();
    
            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {

                MSLEEP(100);
                
                sla_acl_chk ++ ;
                if (sla_acl_chk == 100){
                    printf("sla no acl pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }               

                goto ACL_CHK;

            }

            sla_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stability_conn_with_rx_acl_data(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    u8 acl_data[ACL_DATA_MAX] = {0};

    int mas_pkt_chk = 0 ;
    int mas_acl_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    u32 round           = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    u64 sleep_time = 0    ;
    struct timeval alive_time   ;
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        fill_data(acl_data , ++round);
            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_len_cnt, acl_data);
            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

PKT_CHK:
            // # check disconnection             
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
				mas_pkt_chk ++ ;

                if (mas_pkt_chk == 100){
                    printf("mas no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }       

                goto PKT_CHK;
            } 

            mas_pkt_chk = 0 ;

            printf("\n##get number of completed packets##\n");

ACL_CHK:
            CHECK_NON_DISCONNECT();

            if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {

                MSLEEP(100);
                
                mas_acl_chk ++ ;
                if (mas_acl_chk == 100){
                    printf("mas no acl pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }               

                goto ACL_CHK;

            }

            mas_acl_chk = 0 ;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
            return PASS;
        }
    }


FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stability_conn_with_trx_acl_data(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data_mas[ACL_DATA_MAX] = {0};
    u8 acl_data_sla[ACL_DATA_MAX] = {0};

	int sla_pkt_chk = 0 ;
	int mas_pkt_chk = 0 ;
	int sla_acl_chk = 0 ;
	int mas_acl_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    u32 round           = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    u64 sleep_time = 0    ;
    struct timeval alive_time   ;
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data_mas[acl_len_cnt] = acl_len_cnt;
        acl_data_sla[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

	g_pattern_param.create_conn_param.LE_Scan_Interval[0]		=   0xA0;
	g_pattern_param.create_conn_param.LE_Scan_Interval[1]		=   0;
	g_pattern_param.create_conn_param.LE_Scan_Window[0]			=   0xA0;
	g_pattern_param.create_conn_param.LE_Scan_Window[1]			=   0;

	g_pattern_param.create_conn_param.Conn_Interval_Min[0]		=    conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1]		=   (conn_intval & 0xff00)  >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0]		=    conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1]		=   (conn_intval & 0xff00)  >> 8;
	g_pattern_param.create_conn_param.Conn_Latency[0]		    =    sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00)  >> 8;
	//The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
	//superviision TO > (1+connSlaveLatency)*Conninterval
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=    supervisionTO & 0x00ff ; //=0xD0;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
            
        round ++ ;
        acl_data_sla[0] = (round & 0xff00) >> 8;
        acl_data_sla[1] =  round & 0x00ff;

        acl_data_mas[0] = ((round+1) & 0xff00) >> 8;
        acl_data_mas[1] =  (round+1) & 0x00ff;

        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_len_cnt, acl_data_mas);
            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data_sla);
            
            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

SLA_PKT_CHK:
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
				sla_pkt_chk ++ ;
				if (sla_pkt_chk == 100){
					printf("sla no number of completed pkts\n");
					line = __LINE__;
					goto FUN_FAIL;					
				}
                goto SLA_PKT_CHK;

            } 

            sla_pkt_chk = 0 ;
            printf("\n##slave get number of completed packets##\n");

MAS_PKT_CHK:
            CHECK_NON_DISCONNECT();

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
				mas_pkt_chk ++ ;
				if (mas_pkt_chk == 100){
					printf("mas no number of completed pkts\n");
					line = __LINE__;
					goto FUN_FAIL;					
				}		
                goto MAS_PKT_CHK;

            } 
            
            mas_pkt_chk = 0 ;
            printf("\n##master get number of completed packets##\n");

MAS_ACL_CHK:
            CHECK_NON_DISCONNECT();

            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                MSLEEP(100);

				mas_acl_chk ++ ;
				if (mas_acl_chk == 100){
					printf("mas no acl pkts\n");
					line = __LINE__;
					goto FUN_FAIL;					
				}					
								
                goto MAS_ACL_CHK;

            }

            mas_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data_sla ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {

                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_) ;
                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],acl_data_sla) ;
            
                line=__LINE__;
                goto FUN_FAIL;
            }

SLA_ACL_CHK:
            CHECK_NON_DISCONNECT();

            if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                MSLEEP(100);
				
				sla_acl_chk ++ ;
				if (sla_acl_chk == 100){
					printf("sla no acl pkts\n");
					line = __LINE__;
					goto FUN_FAIL;					
				}				
				
                goto SLA_ACL_CHK;	

            }

            sla_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data_mas ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {

                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_) ;
                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],acl_data_mas) ;

                line=__LINE__;
                goto FUN_FAIL;
            }
           
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stability_conn_with_rx_acl_data_with_busy_polling(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    u8 acl_data_mas[ACL_DATA_MAX] = {0};

	int mas_pkt_chk = 0 ;
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    u32 round           = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    pid_t pid = -1;    
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data_mas[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

	g_pattern_param.create_conn_param.LE_Scan_Interval[0]		=   0xA0;
	g_pattern_param.create_conn_param.LE_Scan_Interval[1]		=   0;
	g_pattern_param.create_conn_param.LE_Scan_Window[0]			=   0xA0;
	g_pattern_param.create_conn_param.LE_Scan_Window[1]			=   0;

	g_pattern_param.create_conn_param.Conn_Interval_Min[0]		=    conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1]		=   (conn_intval & 0xff00)  >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0]		=    conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1]		=   (conn_intval & 0xff00)  >> 8;
	g_pattern_param.create_conn_param.Conn_Latency[0]		    =    sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00)  >> 8;
	//The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
	//superviision TO > (1+connSlaveLatency)*Conninterval
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=    supervisionTO & 0x00ff ; //=0xD0;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    pid = fork();
    if (pid < 0 ){
        line = __LINE__;
        goto FUN_FAIL;
    }


    while(1)//waiting adv report event , timer or counter
    {

        fill_data(acl_data_mas ,++round);    

        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            if( pid == 0 ){
                u8 cmd_cnt = 0;
                while(cmd_cnt < 10){
                    usleep(100);
                    cmd_cnt ++ ;
                    COMM_Read_Local_features(dut2_fd,g_pattern_param);            
                }
            }

            if( pid != 0 ){
    	
                COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_len_cnt, acl_data_mas);
                
                sleep_time = conn_intval * 30 * 1.25 * 1000 ;
                calc_alive_time( sleep_time , &alive_time) ;

                sleep (alive_time.tv_sec );
                usleep(alive_time.tv_usec);

MAS_PKT_CHK:

                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                    MSLEEP(100);
    				mas_pkt_chk ++ ;
    				if (mas_pkt_chk == 100){
    					printf("mas no number of completed pkts\n");
    					line = __LINE__;
    					goto FUN_FAIL;					
    				}		
                    goto MAS_PKT_CHK;

                } 
                
                mas_pkt_chk = 0 ;
                printf("\n##master get number of completed packets##\n");


            }
        }
        else{

            if( pid == 0 ){
                sleep(1);
                printf("+++ closing child process +++\n");  
                
                _exit(0);                          
            }
            
            if( pid != 0 ){
                int status ;
                //# detect child exit
                if( 0 != waitpid( pid, &status ,WNOHANG)){
                    printf("get child exit \n");                        
                    goto FUN_FAIL;
                }
                
                printf("--- wait child process end ---\n");
                fflush(stdout);
                wait(NULL);                
                printf("--- child process has already end ---\n");     


                // use connect handle to disconnect
                buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
                buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
                
                COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
                g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();
                
                sleep(5);
                
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }       
                if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                
                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                } 
                if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }


                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
                
                return PASS;
            }
        }
    }

FUN_FAIL:
    switch (pid){
        case -1 :
            break;
        case  0 :
            printf("child exit\n");        
            fflush(stdout);
            _exit(0);                          
            break;
        default :
            terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }

    FUNC_END();
    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;


}


verdict Sla_stability_conn_with_tx_acl_data_undir_adv(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};

    int sla_pkt_chk = 0 ;
    int sla_acl_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    u32 round     = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    u64 sleep_time = 0    ;
    struct timeval alive_time   ;
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
            
        fill_data(acl_data , ++round);

        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);
            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

PKT_CHK:
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                goto PKT_CHK;
            } 

            sla_pkt_chk = 0;

            printf("\n##get number of completed packets##\n");

ACL_CHK:
            CHECK_NON_DISCONNECT();
            
            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {

                MSLEEP(100);
                sla_acl_chk ++ ;
                if (sla_acl_chk == 100){
                    printf("sla no acl pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }           
                goto ACL_CHK;
            }

            sla_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stability_conn_with_rx_acl_data_undir_adv(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    u8 acl_data[ACL_DATA_MAX] = {0};

    int mas_pkt_chk = 0 ;
    int mas_acl_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    u32 round     = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    u64 sleep_time = 0    ;
    struct timeval alive_time   ;
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        fill_data(acl_data , ++round);
            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_len_cnt, acl_data);
            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

PKT_CHK:
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);

                mas_pkt_chk ++ ;
                if (mas_pkt_chk == 100){
                    printf("mas no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }       

                goto PKT_CHK;
            } 

            mas_pkt_chk = 0 ;

            printf("\n##get number of completed packets##\n");

ACL_CHK:
            CHECK_NON_DISCONNECT();
            
            if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {

                MSLEEP(100);
                
                mas_acl_chk ++ ;
                if (mas_acl_chk == 100){
                    printf("mas no acl pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }               

                goto ACL_CHK;
            }

            mas_acl_chk = 0 ;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
            return PASS;
        }
    }


FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stability_conn_with_trx_acl_data_undir_adv(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data_mas[ACL_DATA_MAX] = {0};
    u8 acl_data_sla[ACL_DATA_MAX] = {0};

    int sla_pkt_chk = 0 ;
    int mas_pkt_chk = 0 ;
    int sla_acl_chk = 0 ;
    int mas_acl_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    static int  round     = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    u64 sleep_time = 0    ;
    struct timeval alive_time   ;
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data_mas[acl_len_cnt] = acl_len_cnt;
        acl_data_sla[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
            
        round ++ ;
        acl_data_sla[0] = (round & 0xff00) >> 8;
        acl_data_sla[1] =  round & 0x00ff;

        acl_data_mas[0] = ((round+1) & 0xff00) >> 8;
        acl_data_mas[1] =  (round+1) & 0x00ff;

        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_len_cnt, acl_data_mas);
            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data_sla);
            
            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

SLA_PKT_CHK:
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                goto SLA_PKT_CHK;
            } 

            sla_pkt_chk = 0 ;
            printf("\n##slave get number of completed packets##\n");

MAS_PKT_CHK:
            CHECK_NON_DISCONNECT();

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
                mas_pkt_chk ++ ;
                if (mas_pkt_chk == 100){
                    printf("mas no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }       
                goto MAS_PKT_CHK;
            } 
            
            mas_pkt_chk = 0 ;
            printf("\n##master get number of completed packets##\n");


MAS_ACL_CHK:

            CHECK_NON_DISCONNECT();

            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                MSLEEP(100);

                mas_acl_chk ++ ;
                if (mas_acl_chk == 100){
                    printf("mas no acl pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }                   
                                
                goto MAS_ACL_CHK;
            }

            mas_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data_sla ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {

                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_) ;
                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],acl_data_sla) ;
            
                line=__LINE__;
                goto FUN_FAIL;
            }

SLA_ACL_CHK:

            CHECK_NON_DISCONNECT();

            if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                MSLEEP(100);
                
                sla_acl_chk ++ ;
                if (sla_acl_chk == 100){
                    printf("sla no acl pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }               
                
                goto SLA_ACL_CHK;   

            }

            sla_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data_mas ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {

                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_) ;
                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],acl_data_mas) ;

                line=__LINE__;
                goto FUN_FAIL;
            }
           
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stability_encrypt_with_tx_acl_data(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    u8 buf[SOCKET_BUF_SIZE];    
    u16 len ;
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};

    int sla_pkt_chk = 0 ;
    int sla_acl_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    u32 round     = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_COMP_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_COMP_HANDLE+1];
    
    COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
    verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    do{
        socket_msg_get(dut2_fd,&len,buf);
    }while(len <=0);
    printf("Get Event(%d):\n",dut2_fd);
    print_charray(len,buf);

    if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?

    verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    sleep(1); //waiting encryption change
    
    if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        fill_data(acl_data , ++round);
            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){
                        
            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);            

            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

PKT_CHK:
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                goto PKT_CHK;
            } 

            sla_pkt_chk = 0;

            printf("\n##get number of completed packets##\n");

ACL_CHK:    
            //step2 ~ 4
            CHECK_NON_DISCONNECT();
            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {

                MSLEEP(100);
                
                sla_acl_chk ++ ;
                if (sla_acl_chk == 100){
                    printf("sla no acl pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }               

                goto ACL_CHK;
            }

            sla_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
        }
        else{


            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;

        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}



verdict Sla_stability_encrypt_with_rx_acl_data(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    u8 buf[SOCKET_BUF_SIZE];    
    u16 len ;
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};

    int mas_pkt_chk = 0 ;
    int mas_acl_chk = 0 ;

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    u32 round     = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_COMP_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_COMP_HANDLE+1];
    
    COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
    verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    do{
        socket_msg_get(dut2_fd,&len,buf);
    }while(len <=0);
    printf("Get Event(%d):\n",dut2_fd);
    print_charray(len,buf);

    if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?

    verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    sleep(1); //waiting encryption change
    
    if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
            
        fill_data(acl_data , ++round);

        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

                        
            COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_len_cnt, acl_data);            

            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

PKT_CHK:
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);

                mas_pkt_chk ++ ;
                if (mas_pkt_chk == 100){
                    printf("mas no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }       

                goto PKT_CHK;
            } 

            mas_pkt_chk = 0 ;

            printf("\n##get number of completed packets##\n");

ACL_CHK:
            CHECK_NON_DISCONNECT();
            
            if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {

                MSLEEP(100);
                
                mas_acl_chk ++ ;
                if (mas_acl_chk == 100){
                    printf("mas no acl pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }               

                goto ACL_CHK;
            }

            mas_acl_chk = 0 ;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
        }
        else{


            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;

        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stability_encrypt_with_trx_acl_data(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];
    u16 len ;
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data_mas[ACL_DATA_MAX] = {0};
    u8 acl_data_sla[ACL_DATA_MAX] = {0};


    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    static int  round     = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    
	int sla_pkt_chk = 0 ;
	int mas_pkt_chk = 0 ;
	int sla_acl_chk = 0 ;
	int mas_acl_chk = 0 ;
	
    u64 sleep_time = 0    ;
    struct timeval alive_time   ;
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data_mas[acl_len_cnt] = acl_len_cnt;
        acl_data_sla[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

	g_pattern_param.create_conn_param.LE_Scan_Interval[0]		=   0xA0;
	g_pattern_param.create_conn_param.LE_Scan_Interval[1]		=   0;
	g_pattern_param.create_conn_param.LE_Scan_Window[0]			=   0xA0;
	g_pattern_param.create_conn_param.LE_Scan_Window[1]			=   0;

	g_pattern_param.create_conn_param.Conn_Interval_Min[0]		=    conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1]		=   (conn_intval & 0xff00)  >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0]		=    conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1]		=   (conn_intval & 0xff00)  >> 8;
	g_pattern_param.create_conn_param.Conn_Latency[0]		    =    sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00)  >> 8;
	//The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
	//superviision TO > (1+connSlaveLatency)*Conninterval
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=    supervisionTO & 0x00ff ; //=0xD0;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

    COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
    verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    do{
        socket_msg_get(dut2_fd,&len,buf);
    }while(len <=0);
    printf("Get Event(%d):\n",dut2_fd);
    print_charray(len,buf);

    if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
    verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    sleep(1); //waiting encryption change
    
    if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }


    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
            
        round ++ ;
        acl_data_sla[0] = (round & 0xff00) >> 8;
        acl_data_sla[1] =  round & 0x00ff;
        
        acl_data_mas[0] = ((round+1) & 0xff00) >> 8;
        acl_data_mas[1] =  (round+1) & 0x00ff;


        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_len_cnt, acl_data_mas);
            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data_sla);
            
            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

SLA_PKT_CHK:
            CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
				sla_pkt_chk ++ ;
				if (sla_pkt_chk == 100){
					printf("sla no number of completed pkts\n");
					line = __LINE__;
					goto FUN_FAIL;					
				}
                goto SLA_PKT_CHK;
            } 
			sla_pkt_chk = 0 ;
            printf("\n##slave get number of completed packets##\n");

MAS_PKT_CHK:
            CHECK_NON_DISCONNECT();

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);
				mas_pkt_chk ++ ;
				if (mas_pkt_chk == 100){
					printf("mas no number of completed pkts\n");
					line = __LINE__;
					goto FUN_FAIL;					
				}				
				
                goto MAS_PKT_CHK;
            } 
			mas_pkt_chk = 0 ;
            printf("\n##master get number of completed packets##\n");

MAS_ACL_CHK:
            CHECK_NON_DISCONNECT();
            
            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                MSLEEP(100);

				mas_acl_chk ++ ;
				if (mas_acl_chk == 100){
					printf("mas no acl pkts\n");
					line = __LINE__;
					goto FUN_FAIL;					
				}					
								
                goto MAS_ACL_CHK;
            }

            mas_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data_sla ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {

                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_) ;
                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],acl_data_sla) ;

                line=__LINE__;
                goto FUN_FAIL;
            }

			mas_acl_chk = 0;
SLA_ACL_CHK:
            CHECK_NON_DISCONNECT();

            if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                MSLEEP(100);
				
				sla_acl_chk ++ ;
				if (sla_acl_chk == 100){
					printf("sla no acl pkts\n");
					line = __LINE__;
					goto FUN_FAIL;					
				}				
				
                goto SLA_ACL_CHK;
            }

		    sla_acl_chk = 0;

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data_mas ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {

                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_) ;
                print_charray(buf[_BT_HCI_IDX_ACL_DATA_LENGTH_],acl_data_mas) ;

                line=__LINE__;
                goto FUN_FAIL;
            }
           
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS \n", __FUNCTION__);
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stability_ch_map_update(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;
    int conn_event      = g_sla_stable_conn_event_change  ;
    
    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
      

    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];     

        
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){
                        
            CHECK_NON_DISCONNECT();

            COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , CH_MAP_FULL );
            verdict = COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            sleep_time = conn_intval * conn_event * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);

            //# wait for updated ch map used
            //usleep(500 * 1000);
#if 0 // TI will detect the environment and change ch_map             
            COMM_Ch_Map_Read_Config(&g_pattern_param , conn_handles_mas);
            verdict = COMM_Ch_Map_Check(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
#endif
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;

        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stability_conn_param_update(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STABLE_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stable_test_time          ;         //# param
    int conn_intval     = g_sla_stable_conn_intval        ;
    int sla_latency     = g_sla_stable_sla_latency        ;
    int supervisionTO   = g_sla_stable_supervision_to     ;    
    
    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            CHECK_NON_DISCONNECT();

            // # should use master's conn handle
            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = conn_intval & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(conn_intval & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = conn_intval & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(conn_intval & 0xff00)  >> 8;           


            g_pattern_param.conn_update_param.Conn_Latency[0]            = sla_latency & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Latency[1]            =(sla_latency & 0xff00)  >> 8;
            //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
            //superviision TO > (1+connSlaveLatency)*Conninterval
            g_pattern_param.conn_update_param.Supervision_Timeout[0]     = supervisionTO & 0x00ff; //=0xD0;
            g_pattern_param.conn_update_param.Supervision_Timeout[1]     =(supervisionTO & 0xff00)>> 8 ; //=0x07;


            verdict = COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
                 
            //usleep(conn_intval * conn_event * 1.25 * 1000);
            
            sleep(10);
            
            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS == hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(5);
            
            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }       
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            } 
            if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;

        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_connect_and_disconnect (u8 dut1_fd ,u8 dut2_fd)   
{
    int dut1  = 0 ;
    int dut2  = 0 ;

    u16 line  = 0 ;
    int verdict = FAIL;
    Fail_reason reason ={0};
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];
    u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;

    int sla_pkt_chk = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    u32 round           = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;

    int duration       = g_sla_stress_duration      ;
    int duration_max   = g_sla_stress_duration_max  ;

    srand(time(NULL));
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }


    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        COMM_Dut_clean_buffer(dut1_fd);        
        COMM_Dut_clean_buffer(dut2_fd);

        fill_data(acl_data , ++round);

        COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        sleep(1);
        
        if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
       
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
            ++reason.no_create_conn ;            
            dut_reset_with_mask_en(dut1_fd);
            sleep(1);
            continue ;
        }

        conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
                            
        if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {

            ++reason.no_conn_req;
            sleep(1);
            continue ;
        }

        conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];   
        
        sleep(1);

        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_FAILED_TO_BE_ESTABLISHED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.fail_to_establish ;
            sleep(1);
            continue ;
        }

        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.connection_timeout ;
            sleep(1);
            continue ;
        }


        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.connection_timeout ;
            sleep(1);
            continue ;
        }

        
        gettimeofday(&current_time,NULL);
            
        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);          

PKT_CHK:
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);

                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    reason.no_num_pkt_comp ++ ;
                    printf("sla no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                
                goto PKT_CHK;
            } 


            sla_pkt_chk = 0;

            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);
    
            //step2 ~ 4
            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                ++ reason.error_no_acl ;                
                line = __LINE__;
                goto FUN_FAIL;  
            }

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                ++ reason.error_pld_acl ;
                line = __LINE__;
                goto FUN_FAIL;  
            }
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO(" round                        %d \n" , round);
            dump_fail_reason(&reason);

            return PASS;
        }

        // call disconnect func

        // use connect handle to disconnect
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
        
        COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
        verdict = COMM_Disconnect(dut1_fd, g_pattern_param);


        // check disconnect 

        if (duration == 0){
            duration = (rand() % duration_max)+1;   
        }
        
        LOG_INFO("check conn_duration %d\n" , duration);

        sleep(duration);

        duration = g_sla_stress_duration ;
        //# slave diconnect with pass instant , check it if fail.
        
        if(PASS != verdict){

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                 
                }
                else {
                    printf("master disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );
                    line = __LINE__;
                    goto FUN_FAIL;
                }    
            }

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_INSTANT_PASSED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                    reason.instant_passed ++ ;
                }
                else {
                    printf("slave disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );                    
                    line = __LINE__;
                    goto FUN_FAIL;
                }                 
            }
        }
        //# only reset dut1
        dut_reset_with_mask_en(dut1_fd);

    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    dump_fail_reason(&reason);
    return FAIL;

}

verdict Idle_acl_data (u8 dut1_fd)
{
    u16 line = 0;

    u8 buf[SOCKET_BUF_SIZE];

    u8 acl_data[ACL_DATA_MAX] = {0};
    int acl_len_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
    
    // #Send acl data to idle device
    COMM_Send_ACL_Data_Without_event(dut1_fd, dut2_error_conn_handles, 0b00, 0, acl_len_cnt, acl_data);

    sleep(3);
    
    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    printf("\ndut 2 get num of comleted packets event : %d\n", hci_event_num_of_completed_packets_parsing(buf));

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
    return PASS;

FUN_FAIL:
    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Idle_read_remote_info (u8 dut1_fd)
{
    int verdict = FAIL;
    u16 line = 0;

    COMM_Dut_clean_buffer(dut1_fd);

    //Read remote version info
    printf("\n### expect status value : 0x02 ###\n");
    COMM_Read_Remote_Version_Information_Config(dut1_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Read_Remote_Version_Information(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);
    
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );           
    return PASS;

FUN_FAIL:
    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Idle_disconnect (u8 dut1_fd)
{
    int dut2 = 0;
    int verdict = FAIL;
    u16 line = 0;

    u8 buf[SOCKET_BUF_SIZE];

    COMM_Dut_clean_buffer(dut1_fd);

    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = dut2_error_conn_handles[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = dut2_error_conn_handles[1];

    printf("\n### expect status value : 0x02 ###\n");
    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);
    
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
    return PASS;

FUN_FAIL:
    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Idle_LTK_req (u8 dut1_fd)
{
    int verdict = FAIL;
    u16 line = 0;

    COMM_Dut_clean_buffer(dut1_fd);

    printf("\n### expect status value : 0x02 ###\n");
    COMM_Ltk_Req_Rep_Config(dut1_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Ltk_Req_Rep(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);
    
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );           
    return PASS;

FUN_FAIL:
    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Idle_LTK_req_nrep (u8 dut1_fd)
{
    int verdict = FAIL;
    u16 line = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    
    printf("\n### expect status value : 0x02 ###\n");
    COMM_Ltk_Req_Negative_Rep_Config(dut1_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Ltk_Req_Negative_Rep(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);
    
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );            
    return PASS;

FUN_FAIL:
    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_set_param (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict=COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    //Set adv param
    printf("\n### expect status value : 0x0C ###\n");
    set_adv_interval(40);
    COMM_ADV_Advertising_Parameters_Set_Config(dut2,&g_pattern_param);
	verdict = COMM_ADV_Advertising_Parameters_Set(dut2_fd,g_pattern_param);    
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_COMMAND_DISALLOWED);
    
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;

    u8 buf[SOCKET_BUF_SIZE];

    u8 acl_data[ACL_DATA_MAX] = {0};
    int acl_len_cnt = 0;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    
    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
    
    // #Send acl data to adv device
    COMM_Send_ACL_Data_Without_event(dut2_fd, dut2_error_conn_handles, 0b00, 0, acl_len_cnt, acl_data);

    sleep(3);
    
    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    printf("\ndut 2 get num of comleted packets event : %d\n", hci_event_num_of_completed_packets_parsing(buf));

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_read_remote_info (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    //Read remote version info
    printf("\n### expect status value : 0x02 ###\n");
    COMM_Read_Remote_Version_Information_Config(dut2_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Read_Remote_Version_Information(dut2_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);  

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_disconnect (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;

    u8 buf[SOCKET_BUF_SIZE];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = dut2_error_conn_handles[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = dut2_error_conn_handles[1];

    printf("\n### expect status value : 0x02 ###\n");
    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);
    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);  

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_scn_enable (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    COMM_SCN_Enable_Config(dut2, &g_pattern_param);
    verdict = COMM_SCN_Enable(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_scn_param (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    set_scan_interval(500);
    set_scan_windows(500);
	COMM_SCN_Parameters_Set_Config(dut2, &g_pattern_param);
	verdict = COMM_SCN_Parameters_Set(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_LTK_req (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    printf("\n### expect status value : 0x02 ###\n");
    COMM_Ltk_Req_Rep_Config(dut2_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Ltk_Req_Rep(dut2_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);
        
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_LTK_req_nrep (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    printf("\n### expect status value : 0x02 ###\n");
    COMM_Ltk_Req_Negative_Rep_Config(dut2_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Ltk_Req_Negative_Rep(dut2_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);

        
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Adv_data_with_adv_direct_ind(u8 dut1_fd ,u8 dut2_fd)
{
	u8 buf[SOCKET_BUF_SIZE];
	int verdict = FAIL;
	int dut1 = 0;
    int dut2 = 0;
	u16 line = 0;
    u8 adv_data = 0;
    int adv_data_cnt = 0;
    int poll_time = 5 * MS2US(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN_ADV_DIRECT_IND * 0.625); 
	struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();    

    // Uptest(white list) config
	COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);	
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);	
	verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();
            
	COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);
	g_pattern_param.scn_param.Own_Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;     
	g_pattern_param.scn_param.Scanning_Filter_Policy[0] = HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY;
	//the interval of Man/Min must use 0x0500 instead of HCI_CMD_PARAM_SCAN_INT_MAX 
	g_pattern_param.scn_param.LE_Scan_Interval[0] =  0x01E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Interval[1] = (0x01E0 & 0xff00) >> 8;
	g_pattern_param.scn_param.LE_Scan_Window[0] =    0x01E0 & 0x00ff;
	g_pattern_param.scn_param.LE_Scan_Window[1] =   (0x01E0 & 0xff00) >> 8;    
	verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(dut2, &g_pattern_param);
   	g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
	g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
	verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();		

    adv_data = 0;

    while(adv_data < 10) {
        g_pattern_param.adv_data_param.Advertising_Data_Length[0] = HCI_CMD_PARAM_ADV_DATA_LEN_MAX;
	    bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = g_pattern_param.adv_data_param.Advertising_Data_Length;
        for (adv_data_cnt = 0; adv_data_cnt < HCI_CMD_PARAM_ADV_DATA_LEN_MAX ; adv_data_cnt++)
            g_pattern_param.adv_data_param.Advertising_Data[adv_data_cnt] = adv_data;
        bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = g_pattern_param.adv_data_param.Advertising_Data;

        verdict = COMM_ADV_Advertising_Data_Set(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        printf("\nUpdate adv_data %x\n", adv_data);
    
        usleep(poll_time);
    
        if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_, HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND)) {                                          
            line = __LINE__ ;
            goto FUN_FAIL;
        }            
        else if(EQUAL != hci_le_event_advertising_report_parsing(HCI_SUBEVENT_ADV_RPT_EVENT_DIRECT_IND, buf, g_pattern_param)) {
            printf("adv not coming\n");
            line = __LINE__ ;
            goto FUN_FAIL;
        }
        else {
            if(0 != buf[_BT_HCI_EVT_ADV_RPT_DATA_LEN]) {
                printf("adv data error\n");
                line = __LINE__ ;
                goto FUN_FAIL;
            }
        }
       
        adv_data++;
    }  

   
    sleep(3);
    
	if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
		line = __LINE__;
		goto FUN_FAIL;
	}

	if(_BT_HCI_EVT_CMD_COMP_STATUS_DIRECTED_ADVERTISING_TIMEOUT != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto FUN_FAIL;
	}

    FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;
    
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__, line);	
	return FAIL;

}

verdict Adv_reset_enable (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    COMM_Reset(dut2_fd);

    COMM_Dut_clean_buffer(dut1_fd);

    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    //check adv ind
    sleep(3);
    
    adv_cnt = 0;
    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_set_param (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict=COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    //Set scn param
    set_scan_interval(500);
    set_scan_windows(500);
	COMM_SCN_Parameters_Set_Config(dut1, &g_pattern_param);
	verdict = COMM_SCN_Parameters_Set(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_COMMAND_DISALLOWED);
    
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;

    u8 buf[SOCKET_BUF_SIZE];

    u8 acl_data[ACL_DATA_MAX] = {0};
    int acl_len_cnt = 0;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    
    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
    
    // #Send acl data to adv device
    COMM_Send_ACL_Data_Without_event(dut1_fd, dut2_error_conn_handles, 0b00, 0, acl_len_cnt, acl_data);

    sleep(3);
    
    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    printf("\ndut 2 get num of comleted packets event : %d\n", hci_event_num_of_completed_packets_parsing(buf));

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_read_remote_info (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    //Read remote version info
    printf("\n### expect status value : 0x02 ###\n");
    COMM_Read_Remote_Version_Information_Config(dut1_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Read_Remote_Version_Information(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_disconnect (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;

    u8 buf[SOCKET_BUF_SIZE];
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = dut2_error_conn_handles[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = dut2_error_conn_handles[1];

    printf("\n### expect status value : 0x02 ###\n");
    COMM_Disconnect_Config(dut1, &g_pattern_param, buf);
    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER); 

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_adv_enable (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    COMM_ADV_Enable_Config(dut1, &g_pattern_param);
	verdict = COMM_ADV_Enable(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_adv_param (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict=COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    //Set adv param
    set_adv_interval(40);
    COMM_ADV_Advertising_Parameters_Set_Config(dut1, &g_pattern_param);
	verdict = COMM_ADV_Advertising_Parameters_Set(dut1_fd, g_pattern_param);    
    VERDICT_RESULT_WITH_LINE();

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_LTK_req (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    printf("\n### expect status value : 0x02 ###\n");
    COMM_Ltk_Req_Rep_Config(dut1_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Ltk_Req_Rep(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);
        
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_LTK_req_nrep (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    printf("\n### expect status value : 0x02 ###\n");
    COMM_Ltk_Req_Negative_Rep_Config(dut1_fd, &g_pattern_param, dut2_error_conn_handles);
    verdict = COMM_Ltk_Req_Negative_Rep(dut1_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);

        
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Scn_reset_enable (u8 dut1_fd ,u8 dut2_fd)
{
    int verdict = FAIL;
    int dut1 = 0, dut2 = 0;
    u16 line = 0;
    u32 adv_cnt = 0;
    struct itimerval timer;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    COMM_Reset(dut1_fd);

    verdict = COMM_Set_Event_Mask(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_Le_Set_Event_Mask(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_Dut_clean_buffer(dut1_fd);

    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    //check adv ind??
    sleep(3);

    adv_cnt = 0;
    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n", __FUNCTION__, line);
    return FAIL;
}

verdict Sla_reset_adv(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
  
    u8 buf[SOCKET_BUF_SIZE];
    int adv_Channel = 37;
    u32 adv_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(2);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);

    //Config SCN & ADV   
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);

    COMM_SCN_Passive_Scanning_Config(dut1, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_reset_scn(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
  
    u8 buf[SOCKET_BUF_SIZE];
    int adv_Channel = 37;
    u32 adv_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(2);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    dut_reset_with_mask_en(dut1_fd);
    dut_reset_with_mask_en(dut2_fd);

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param); //switch adv & scn addr
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param); //switch adv & scn addr
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    set_adv_interval(20);
    memcpy (g_pattern_param.adv_param.Direct_Address , scan_addr , ADDR_LENGTH); //switch adv & scn addr

    COMM_SCN_Passive_Scanning_Config(dut2, &g_pattern_param);

    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
    
    verdict = COMM_SCN_Passive_Scanning(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict = COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(3);

    COMM_Dut_check_adv_rpt_num(dut2_fd, &adv_cnt, NULL);
        
    printf("\n### adv_cnt %d ###\n", adv_cnt);

    if (adv_cnt <= 0)
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

  
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_Recv_LTK_req_reset (u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    u16 len;
    int verdict=FAIL;
    int dut1 = 0;
    u16 line =0 ;
    struct itimerval timer;
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];
    u16 test_cnt = 100 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

RESTART :

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);
    //here use lowest ch to testing
    g_pattern_param.adv_param.Advertising_Channel_Map[0] =HCI_CMD_PARAM_ENABLE_CHANNEL_37 ;
    verdict=COMM_ADV_Directed_Advertising(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1,&g_pattern_param);
    verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(5);
    
    if(SUCCESS != QUERY_LE_Event(dut1_fd , buf , _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_ , 0 )){
        line=__LINE__;
        goto FUN_FAIL;
    }

    if(SUCCESS != hci_le_event_connection_complete_parsing(0 , buf, g_pattern_param)){
        line=__LINE__;
        goto FUN_FAIL;
    }

    conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
    conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

    if(SUCCESS != QUERY_LE_Event(dut2_fd , buf , _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_ , 0 )){
        line=__LINE__;
        goto FUN_FAIL;
    }

    if(SUCCESS != hci_le_event_connection_complete_parsing(0 , buf, g_pattern_param)){
        line=__LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
    conn_handles_sla[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

    COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
    verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    do{
        socket_msg_get(dut2_fd,&len,buf);
    }while(len <=0);
    
    printf("Get Event(%d):\n",dut2_fd);
    print_charray(len,buf);

    if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }

    // #do terminated

    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];

    COMM_Disconnect_Config(0, &g_pattern_param,buf);
    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);

	VERDICT_RESULT_WITH_LINE();

    sleep(5);

	if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
		line = __LINE__;
		goto FUN_FAIL;
	}
	else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto FUN_FAIL;
	}
    if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


	if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
		line = __LINE__;
		goto FUN_FAIL;
	}
	else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
		line = __LINE__;
		goto FUN_FAIL;
	}
    if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }


	dut_reset_with_mask_en(dut1_fd);
	dut_reset_with_mask_en(dut2_fd);
    FUNC_END();

    if(test_cnt --){
        
        LOG_INFO("leave (%d):\n",test_cnt);
        goto RESTART;
    }

    LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}



verdict Sla_acl_data_err_handle(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
  
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_err[2] = {0x00, 0x00};
    u8 conn_handles_sla[2];
    u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;
    int acl_len_cnt = 0;
    u16 conn_handles_err_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    //Try all error connection handle 0x0000 ~ 0x0fff
    while(conn_handles_err_cnt <= 0x0fff) {
        conn_handles_err[0] = conn_handles_err_cnt & 0x00ff;
        conn_handles_err[1] = (conn_handles_err_cnt & 0xff00) >> 8;

        if(!memcmp(conn_handles_sla, conn_handles_err, sizeof(conn_handles_err))) {
            LOG_INFO("\nSkip real connection handle %x %x\n", conn_handles_sla[0], conn_handles_sla[1]);
            conn_handles_err_cnt++;
            continue;
        }

        LOG_INFO("\nTry error connection handle %x %x\n", conn_handles_err[0], conn_handles_err[1]);
        
        COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_err, 0b00, 0, acl_len_cnt, acl_data);

        MSLEEP(HCI_CMD_PARAM_CONN_INT_MIN * 1.25 * 10);

        CHECK_NON_DISCONNECT();

        if(SUCCESS != QUERY_Acl_Data(dut1_fd, buf))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        if(0 != buf[_BT_HCI_IDX_ACL_DATA_LENGTH_])
        {      
            line=__LINE__;
            goto FUN_FAIL;
        }
        
        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
            line = __LINE__;
            goto FUN_FAIL;                  
        }
        
        conn_handles_err_cnt++;
    }

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_read_remote_info_err_handle(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
        
    struct itimerval timer;
      
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_err[2] = {0x00, 0x00};
    u8 conn_handles_sla[2];

    int adv_Channel = 37;
    u16 conn_handles_err_cnt = 0;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
       
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    //Try all error connection handle 0x0000 ~ 0x0fff
    while(conn_handles_err_cnt <= 0x0fff) {
        conn_handles_err[0] = conn_handles_err_cnt & 0x00ff;
        conn_handles_err[1] = (conn_handles_err_cnt & 0xff00) >> 8;

        if(!memcmp(conn_handles_sla, conn_handles_err, sizeof(conn_handles_err))) {
            LOG_INFO("\nSkip real connection handle %x %x\n", conn_handles_sla[0], conn_handles_sla[1]);
            conn_handles_err_cnt++;    
            continue;
        }

        //Read remote version info
        LOG_INFO("\n### expect status value : 0x02 ###\n");
        LOG_INFO("\nTry error connection handle %x %x\n", conn_handles_err[0], conn_handles_err[1]);
        COMM_Read_Remote_Version_Information_Config(dut2_fd, &g_pattern_param, conn_handles_err);
        verdict = COMM_Read_Remote_Version_Information(dut2_fd, g_pattern_param);
        VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);

        MSLEEP(HCI_CMD_PARAM_CONN_INT_MIN * 1.25 * 10);

        CHECK_NON_DISCONNECT();

        conn_handles_err_cnt++;
    }   
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_disconnect_err_handle(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
  
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_err[2] = {0x00, 0x00};
    u8 conn_handles_sla[2];

    int adv_Channel = 37;
    u16 conn_handles_err_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];
    
    sleep(1);

    //Try all error connection handle 0x0000 ~ 0x0fff
    while(conn_handles_err_cnt <= 0x0fff) {
        conn_handles_err[0] = conn_handles_err_cnt & 0x00ff;
        conn_handles_err[1] = (conn_handles_err_cnt & 0xff00) >> 8;

        if(!memcmp(conn_handles_sla, conn_handles_err, sizeof(conn_handles_err))) {
            LOG_INFO("\nSkip real connection handle %x %x\n", conn_handles_sla[0], conn_handles_sla[1]);
            conn_handles_err_cnt++;    
            continue;
        }

        memset(buf, 0, SOCKET_BUF_SIZE);
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_err[0];
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_err[1];

        LOG_INFO("\n### expect status value : 0x02 ###\n");
        LOG_INFO("\nTry error connection handle %x %x\n", conn_handles_err[0], conn_handles_err[1]);
        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);
        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
        VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);  

        MSLEEP(HCI_CMD_PARAM_CONN_INT_MIN * 1.25 * 10);
        CHECK_NON_DISCONNECT();
    
        conn_handles_err_cnt++;
    }

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_LTK_req_error_handle(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
  
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_err[2] = {0x00, 0x00};
    u8 conn_handles_sla[2];
    u8 conn_handles_mas[2];

    int adv_Channel = 37;
    u16 len;
    u16 conn_handles_err_cnt = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_mas[0] = buf[_BT_HCI_EVT_COMP_HANDLE + 0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_COMP_HANDLE + 1];    

    if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    sleep(1);

    //Try all error connection handle 0x0000 ~ 0x0fff
    while(conn_handles_err_cnt <= 0x0fff) {
        conn_handles_err[0] = conn_handles_err_cnt & 0x00ff;
        conn_handles_err[1] = (conn_handles_err_cnt & 0xff00) >> 8;

        if(!memcmp(conn_handles_sla, conn_handles_err, sizeof(conn_handles_err))) {
            LOG_INFO("\nSkip real connection handle %x %x\n", conn_handles_sla[0], conn_handles_sla[1]);
            conn_handles_err_cnt++;    
            continue;
        }
        
        LOG_INFO("\nTry error connection handle %x %x\n", conn_handles_err[0], conn_handles_err[1]);

        COMM_Start_Encryption_Config(dut1_fd, &g_pattern_param, conn_handles_mas);
        verdict = COMM_Start_Encryption(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        do {
        socket_msg_get(dut2_fd, &len, buf);
        } while(len <= 0);
        printf("Get Event(%d):\n", dut2_fd);

        print_charray(len, buf);

        if(SUCCESS != hci_le_event_ltk_request_parsing(0, buf, g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        COMM_Ltk_Req_Rep_Config(dut2_fd, &g_pattern_param, conn_handles_err);
        verdict = COMM_Ltk_Req_Rep(dut2_fd, g_pattern_param);
        VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);

        MSLEEP(HCI_CMD_PARAM_CONN_INT_MIN * 1.25 * 10);
    
        if (SUCCESS != QUERY_Event(dut2_fd, buf , _BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
    
        if(SUCCESS == hci_event_encryption_change_parsing(0, buf, g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        if(SUCCESS != QUERY_Event(dut1_fd, buf , _BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        if(SUCCESS == hci_event_encryption_change_parsing(0, buf, g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        CHECK_NON_DISCONNECT();

        //set real handle to end procedure 
        COMM_Ltk_Req_Rep_Config(dut2_fd, &g_pattern_param, conn_handles_sla);
        verdict = COMM_Ltk_Req_Rep(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        MSLEEP(HCI_CMD_PARAM_CONN_INT_MIN * 1.25 * 10);

REPEAT1:

        if (SUCCESS != QUERY_Event(dut2_fd, buf , _BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
    
        if(SUCCESS != hci_event_encryption_change_parsing(0, buf, g_pattern_param))
        {
            if (SUCCESS != QUERY_Event(dut2_fd, buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0, buf, g_pattern_param))
			{
				CHECK_NON_DISCONNECT();
                MSLEEP(HCI_CMD_PARAM_CONN_INT_MIN * 1.25 * 10);
				goto REPEAT1;
			}
        }

REPEAT2:

        if(SUCCESS != QUERY_Event(dut1_fd, buf , _BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        if(SUCCESS != hci_event_encryption_change_parsing(0, buf, g_pattern_param))
        {
            if (SUCCESS != QUERY_Event(dut1_fd, buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0, buf, g_pattern_param))
			{
				CHECK_NON_DISCONNECT();
                MSLEEP(HCI_CMD_PARAM_CONN_INT_MIN * 1.25 * 10);
				goto REPEAT2;
			}
        }

        CHECK_NON_DISCONNECT();
        conn_handles_err_cnt++;   
    }
    
    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_LTK_req_nrep_error_handle(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
  
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_err[2] = {0x00, 0x00};
    u8 conn_handles_sla[2];
    u8 conn_handles_mas[2];

    int adv_Channel = 37;
    u16 len;
    u16 conn_handles_err_cnt = 0;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (HCI_CMD_PARAM_CONN_INT_MIN & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_mas[0] = buf[_BT_HCI_EVT_COMP_HANDLE + 0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_COMP_HANDLE + 1];    

    if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    sleep(1);

    //Try all error connection handle 0x0000 ~ 0x0fff
    while(conn_handles_err_cnt <= 0x0fff) {
        conn_handles_err[0] = conn_handles_err_cnt & 0x00ff;
        conn_handles_err[1] = (conn_handles_err_cnt & 0xff00) >> 8;

        if(!memcmp(conn_handles_sla, conn_handles_err, sizeof(conn_handles_err))) {
            LOG_INFO("\nSkip real connection handle %x %x\n", conn_handles_sla[0], conn_handles_sla[1]);
            conn_handles_err_cnt++;    
            continue;
        }
        
        LOG_INFO("\nTry error connection handle %x %x\n", conn_handles_err[0], conn_handles_err[1]);

        COMM_Start_Encryption_Config(dut1_fd, &g_pattern_param, conn_handles_mas);
        verdict = COMM_Start_Encryption(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        do {
            socket_msg_get(dut2_fd, &len, buf);
        } while(len <= 0);
        printf("Get Event(%d):\n", dut2_fd);

        print_charray(len, buf);

        if(SUCCESS != hci_le_event_ltk_request_parsing(0, buf, g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        COMM_Ltk_Req_Negative_Rep_Config(dut2_fd, &g_pattern_param, conn_handles_err);
        verdict = COMM_Ltk_Req_Negative_Rep(dut2_fd, g_pattern_param);
        VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);

        MSLEEP(HCI_CMD_PARAM_CONN_INT_MIN * 1.25 * 10);

        if(SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        if(_BT_HCI_EVT_CMD_COMP_STATUS_PIN_OR_KEY_MISSING == hci_event_encryption_change_parsing(0,buf,g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        CHECK_NON_DISCONNECT();

        COMM_Ltk_Req_Negative_Rep_Config(dut2_fd, &g_pattern_param, conn_handles_sla);
        verdict = COMM_Ltk_Req_Negative_Rep(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        MSLEEP(20);

        if(SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        if(_BT_HCI_EVT_CMD_COMP_STATUS_PIN_OR_KEY_MISSING != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
        conn_handles_err_cnt++;   
    }
        

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_disconnect_twice(u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
  
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];

    int adv_Channel = 37;
    
    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1]; 

    sleep(1);
    
    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);
    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(5);
                
    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }       
    if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    } 
    if( 0 == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);
    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
    VERDICT_ERROR_CODE_CHECK_WITH_LINE(_BT_HCI_EVT_CMD_COMP_STATUS_UNKNOWN_CONNECTION_IDENTIFIER);

    FUNC_END();
    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__ );
            
    return PASS;

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_connect_and_disconnect_slave (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1  = 0 ;
    int dut2  = 0 ;

    u16 line  = 0 ;
    int verdict = FAIL;
    Fail_reason reason ={0};
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];
    u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;

    int sla_pkt_chk = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    u32 round           = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;

    int duration       = g_sla_stress_duration      ;
    int duration_max   = g_sla_stress_duration_max  ;

    srand(time(NULL));
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }


    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        COMM_Dut_clean_buffer(dut1_fd);        
        COMM_Dut_clean_buffer(dut2_fd);

        fill_data(acl_data , ++round);

        COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        sleep(1);
        MSLEEP(250);
        if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
       
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
            ++reason.no_create_conn ;            
            dut_reset_with_mask_en(dut1_fd);
            sleep(1);
            continue ;
        }               
             
        if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {

            ++reason.no_conn_req;
            sleep(1);
            continue ;
        }

        conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];    
        
        sleep(1);

        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_FAILED_TO_BE_ESTABLISHED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.fail_to_establish ;
            sleep(1);
            continue ;

        }

        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.connection_timeout ;
            sleep(1);
            continue ;

        }


        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.connection_timeout ;
            sleep(1);
            continue ;

        }

        
        gettimeofday(&current_time,NULL);
            
        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);          

PKT_CHK:
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);

                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    reason.no_num_pkt_comp ++ ;
                    line = __LINE__;
                    goto FUN_FAIL;  

                }
                
                goto PKT_CHK;
            } 


            sla_pkt_chk = 0;

            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);


            //step2 ~ 4
            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                ++ reason.error_no_acl ;
                
                line = __LINE__;
                goto FUN_FAIL;  


            }

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                ++ reason.error_pld_acl ;
                line = __LINE__;
                goto FUN_FAIL;  

            
            }
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
            
            COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO(" round                        %d \n" , round);
            dump_fail_reason(&reason);

            return PASS;
        }

        // call disconnect func

        // use connect handle to disconnect
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
        
        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);


        // check disconnect 

        if (duration == 0){
            duration = (rand() % duration_max)+1;   
        }
        
        LOG_INFO("check conn_duration %d\n" , duration);

        sleep(duration);

        duration = g_sla_stress_duration ;

        //# slave diconnect with pass instant , check it if fail.
        
        if(PASS != verdict){

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                 
                }
                else {
                    printf("master disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );
                    line = __LINE__;
                    goto FUN_FAIL;
                }    
            }

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_INSTANT_PASSED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                    reason.instant_passed ++ ;
                }
                else {
                    printf("slave disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );                    
                    line = __LINE__;
                    goto FUN_FAIL;
                }                 
            }
        }    
                 
        //# only reset dut1
        dut_reset_with_mask_en(dut1_fd);

        dump_fail_reason(&reason);    
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    dump_fail_reason(&reason);    
    return FAIL;

}

verdict Sla_stress_connect_and_disconnect_rx_not_sync (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1  = 0 ;
    int dut2  = 0 ;

    u16 line  = 0 ;
    int verdict = FAIL;
    Fail_reason reason ={0};
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];
    u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    u32 round           = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;

    int duration       = g_sla_stress_duration      ;
    int duration_max   = g_sla_stress_duration_max  ;

    srand(time(NULL));
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }


    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        COMM_Dut_clean_buffer(dut1_fd);        
        COMM_Dut_clean_buffer(dut2_fd);

        fill_data(acl_data , ++round);

        COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        sleep(1);
        
        if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
       
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
            ++reason.no_create_conn ;            
            dut_reset_with_mask_en(dut1_fd);
            sleep(1);
            continue ;
        }               
             
        if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {

            ++reason.no_conn_req;
            sleep(1);
            continue ;
        }

        conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];    
        
        sleep(1);

        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }

        u8 mas_fail_to_establish = 0;
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_FAILED_TO_BE_ESTABLISHED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++mas_fail_to_establish ;
            sleep(1);
        }

        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }

        u8 sla_fail_to_establish = 0;
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_FAILED_TO_BE_ESTABLISHED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++sla_fail_to_establish ;
            sleep(1);
        }

        if (mas_fail_to_establish && sla_fail_to_establish){
            LOG_INFO("### rx_not_sync !!! ###");
            
            while(1){};
        };

        
        gettimeofday(&current_time,NULL);
            
        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            sleep(1);

        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
            
            COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO(" round                        %d \n" , round);
            dump_fail_reason(&reason);

            return PASS;
        }

        // call disconnect func

        // use connect handle to disconnect
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
        
        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);


        // check disconnect 

        if (duration == 0){
            duration = (rand() % duration_max)+1;   
        }
        
        LOG_INFO("check conn_duration %d\n" , duration);

        sleep(duration);

        duration = g_sla_stress_duration ;

        //# slave diconnect with pass instant , check it if fail.
        
        if(PASS != verdict){

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                 
                }
                else {
                    printf("master disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );
                    line = __LINE__;
                    goto FUN_FAIL;
                }    
            }

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_INSTANT_PASSED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                    reason.instant_passed ++ ;
                }
                else {
                    printf("slave disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );                    
                    line = __LINE__;
                    goto FUN_FAIL;
                }                 
            }
        }    
                 
        //# only reset dut1
        dut_reset_with_mask_en(dut1_fd);

    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    dump_fail_reason(&reason);    
    return FAIL;

}



verdict Sla_stress_connect_encrypt_disconnect (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    Fail_reason reason ={0};
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    u8 buf[SOCKET_BUF_SIZE];
    u16 len ;
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];
    u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;
    int sla_pkt_chk = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    u32 round     = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;

    int duration       = g_sla_stress_duration      ;
    int duration_max   = g_sla_stress_duration_max  ;

    srand(time(NULL));
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }


    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;

    gettimeofday(&start_time,NULL);

    while(1)//waiting time-out or counter
    {

        COMM_Dut_clean_buffer(dut1_fd);        
        COMM_Dut_clean_buffer(dut2_fd);

        fill_data(acl_data , ++round);

        COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        sleep(1);
        
        if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
            ++reason.no_create_conn ;            
            dut_reset_with_mask_en(dut1_fd);
            sleep(1);
            continue ;
        }    
        
        conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
        
        
        if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {

            ++reason.no_conn_req;
            sleep(1);
            continue ;
        }

        conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];    

        sleep(1);

        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_FAILED_TO_BE_ESTABLISHED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.fail_to_establish ;
            sleep(1);
            continue ;
        }

        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.connection_timeout ;
            sleep(1);
            continue ;
        }


        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.connection_timeout ;
            sleep(1);
            continue ;

        }


        COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
        verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        do{
            socket_msg_get(dut2_fd,&len,buf);
        }while(len <=0);
        printf("Get Event(%d):\n",dut2_fd);
        print_charray(len,buf);
        
        if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
        
        COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
        verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        sleep(1); //waiting encryption change
        
        if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
        
        if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
        {

            ++reason.no_encrypt_change_master ;
            
            dut_reset_with_mask_en(dut1_fd);            
            sleep(35);
            continue;
        }
        
        if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
        
        if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
        {

            ++reason.no_encrypt_change_slave ;
            
            dut_reset_with_mask_en(dut1_fd);            
            sleep(35);
            continue;
        }
        
        
        gettimeofday(&current_time,NULL);
            
        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);          

PKT_CHK:

            // # check disconnection             
            // CHECK_NON_DISCONNECT();
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                MSLEEP(100);

                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    reason.no_num_pkt_comp ++ ;
                    line = __LINE__;
                    goto FUN_FAIL;                
                }

                goto PKT_CHK;
            } 

            sla_pkt_chk = 0;

            //usleep(conn_intval* 3 * 1.25 * 1000);

            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);


            //step2 ~ 4
            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {

                ++ reason.error_no_acl ;
                line = __LINE__;
                goto FUN_FAIL;  

            }

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                ++ reason.error_pld_acl ;                
                line = __LINE__;
                goto FUN_FAIL;  

            }
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO(" round                        %d \n" , round);
            dump_fail_reason(&reason);
                            
            return PASS;
        }

        // call disconnect func

        // use connect handle to disconnect
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
        
        COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
        verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();


        // check disconnect 

        if (duration == 0){
            duration = (rand() % duration_max)+1;   
        }
        
        LOG_INFO("check conn_duration %d\n" , duration);

        sleep(duration);

        duration = g_sla_stress_duration ;

        //# slave diconnect with pass instant , check it if fail.
        
        if(PASS != verdict){

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                 
                }
                else {
                    printf("master disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );
                    line = __LINE__;
                    goto FUN_FAIL;
                }    
            }

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_INSTANT_PASSED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                    reason.instant_passed ++ ;
                }
                else {
                    printf("slave disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );                    
                    line = __LINE__;
                    goto FUN_FAIL;
                }                 
            }
        }   
        //# only reset dut1
        dut_reset_with_mask_en(dut1_fd);

    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    dump_fail_reason(&reason);

    return FAIL;

}


verdict Sla_stress_connect_encrypt_disconnect_slave (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1  = 0 ;
    int dut2  = 0 ;

    u16 line  = 0 ;
    int verdict = FAIL;
    Fail_reason reason ={0};
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    u8 buf[SOCKET_BUF_SIZE];
    u16 len ;
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];
    u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;

    int sla_pkt_chk = 0 ;
    int mas_pkt_chk = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    u32 round           = 0    ;
    int acl_len_cnt     = 0    ; 

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;

    int duration       = g_sla_stress_duration      ;
    int duration_max   = g_sla_stress_duration_max  ;

    srand(time(NULL));
    
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }


    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        COMM_Dut_clean_buffer(dut1_fd);        
        COMM_Dut_clean_buffer(dut2_fd);

        COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        sleep(1);
        
        if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
       
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
            ++reason.no_create_conn ;            
            dut_reset_with_mask_en(dut1_fd);
            sleep(1);
            continue ;
        }               

        conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];   
             
        if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {

            ++reason.no_conn_req;
            sleep(1);
            continue ;
        }

        conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
        conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];    
        
        sleep(1);

        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_FAILED_TO_BE_ESTABLISHED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.fail_to_establish ;
            sleep(1);
            continue ;

        }

        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.connection_timeout ;
            sleep(1);
            continue ;

        }


        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {    
            line = __LINE__;
            goto FUN_FAIL;
        }else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
            line = __LINE__;
            goto FUN_FAIL;
        }
        
        if( _BT_HCI_EVT_CMD_COMP_STATUS_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {

            ++reason.connection_timeout ;
            sleep(1);
            continue ;

        }


        COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
        verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        do{
            socket_msg_get(dut2_fd,&len,buf);
        }while(len <=0);
        printf("Get Event(%d):\n",dut2_fd);
        print_charray(len,buf);
        
        if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
        
        COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
        verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
        
        sleep(1); //waiting encryption change
        
        if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
        
        if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
        {

            ++reason.no_encrypt_change_master ;
            
            dut_reset_with_mask_en(dut1_fd);            
            sleep(35);
            continue;
        
        }
        
        if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }
        
        if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
        {

            ++reason.no_encrypt_change_slave ;
            
            dut_reset_with_mask_en(dut1_fd);            
            sleep(35);
            continue;

        }

        
        gettimeofday(&current_time,NULL);
            
        if((current_time.tv_sec - start_time.tv_sec) < test_time){
            int pkt_cnt = 1000;
            while (pkt_cnt --){

                fill_data(acl_data , ++round);
                
                COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);          
SLA_PKT_CHK:
        
                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        reason.no_num_pkt_comp ++ ;
                        
                        line = __LINE__;
                        goto FUN_FAIL;  
                    }
                    
                    goto SLA_PKT_CHK;
                } 


                sla_pkt_chk = 0;

                //usleep(conn_intval* 3 * 1.25 * 1000);

                sleep_time = conn_intval * 30 * 1.25 * 1000 ;
                calc_alive_time( sleep_time , &alive_time) ;

                sleep (alive_time.tv_sec );
                usleep(alive_time.tv_usec);


                //step2 ~ 4
                if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                    line = __LINE__;
                    goto FUN_FAIL;

                }

                if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                    ++ reason.error_no_acl ;
                    line = __LINE__;
                    goto FUN_FAIL;  

                }

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    ++ reason.error_pld_acl ;
                    line = __LINE__;
                    goto FUN_FAIL;  
                
                }

                COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_len_cnt, acl_data);          

MAS_PKT_CHK:
        
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                    MSLEEP(100);

                    mas_pkt_chk ++ ;
                    if (mas_pkt_chk == 100){
                        printf("mas no number of completed pkts\n");
                        reason.no_num_pkt_comp ++ ;
                        
                        line = __LINE__;
                        goto FUN_FAIL;  
                    }
                    
                    goto MAS_PKT_CHK;
                } 


                mas_pkt_chk = 0;

                //usleep(conn_intval* 3 * 1.25 * 1000);

                sleep_time = conn_intval * 30 * 1.25 * 1000 ;
                calc_alive_time( sleep_time , &alive_time) ;

                sleep (alive_time.tv_sec );
                usleep(alive_time.tv_usec);


                //step2 ~ 4
                if (SUCCESS != QUERY_Acl_Data(dut2_fd,buf)) {
                    line = __LINE__;
                    goto FUN_FAIL;

                }

                if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                    ++ reason.error_no_acl ;
                    
                    line = __LINE__;
                    goto FUN_FAIL;  

                }

                if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                    buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
                {
                    ++ reason.error_pld_acl ;
                    line = __LINE__;
                    goto FUN_FAIL;
                
                }
            
               }     
            }
            else{

                // use connect handle to disconnect
                buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
                
                COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                VERDICT_RESULT_WITH_LINE();


                FUNC_END();
                LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
                LOG_INFO(" round                        %d \n" , round);
                dump_fail_reason(&reason);

                return PASS;
            }

        // call disconnect func

        // use connect handle to disconnect
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
        
        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);


        // check disconnect 

        if (duration == 0){
            duration = (rand() % duration_max)+1;   
        }
        
        LOG_INFO("check conn_duration %d\n" , duration);

        sleep(duration);

        duration = g_sla_stress_duration ;

        //# slave diconnect with pass instant , check it if fail.
        
        if(PASS != verdict){

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_CONNECTION_TIMEOUT == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                 
                }
                else {
                    printf("master disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );
                    line = __LINE__;
                    goto FUN_FAIL;
                }    
            }

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {

                if ( HCI_CMD_PARAM_INSTANT_PASSED == buf[_BT_HCI_EVT_DISCONN_COMP_REASON] ){
                    reason.instant_passed ++ ;
                }
                else {
                    printf("slave disconnet reason [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON] );                    
                    line = __LINE__;
                    goto FUN_FAIL;
                }                 
            }
        }    
                 
        //# only reset dut1
        dut_reset_with_mask_en(dut1_fd);

    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    dump_fail_reason(&reason);    
    return FAIL;

}



#define ERROR_UNKNOWN_CID           1
#define ERROR_CONN_ESTABLISH_FAIL   2
#define ERROR_CONN_REQ_FAIL         3
#define ERROR_NUM_OF_PKT_COMP       4


verdict Sla_stress_start_and_restart_encryption (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u64 sleep_time = 0    ;
    struct timeval alive_time   ;

    u8 buf[SOCKET_BUF_SIZE];    
    u16 len ;
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};

    int adv_Channel = 37;
    int sla_pkt_chk = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    u32 round = 0;
    int acl_len_cnt     = 0    ; 
    
    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;

    int duration       = g_sla_stress_duration      ;
    int duration_max   = g_sla_stress_duration_max  ;

    srand(time(NULL));
    Calculate_Execution_Time_Start();

    // # init acl data
    for ( ; acl_len_cnt < ACL_DATA_MAX ; acl_len_cnt ++){
        acl_data[acl_len_cnt] = acl_len_cnt;
    }
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_COMP_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_COMP_HANDLE+1];
    
    COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
    verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    do{
        socket_msg_get(dut2_fd,&len,buf);
    }while(len <=0);
    printf("Get Event(%d):\n",dut2_fd);
    print_charray(len,buf);
    
    if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
    verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
    sleep(1); //waiting encryption change
    
    if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    
    if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
    {
        line=__LINE__;
        goto FUN_FAIL;
    }
    

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        fill_data(acl_data , ++round);

        COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
        verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        do{
            socket_msg_get(dut2_fd,&len,buf);
        }while(len <=0);
        printf("Get Event(%d):\n",dut2_fd);
        print_charray(len,buf);
        if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
        verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        sleep(1); //waiting encryption change

        if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_KEY_REFRESH_COMPLETE_))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

        if(SUCCESS != hci_event_encryption_key_refresh_complte_parsing(0,buf,g_pattern_param))
        {
            line=__LINE__;
            goto FUN_FAIL;
        }

            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

                        
            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_len_cnt, acl_data);
PKT_CHK:
            // # check disconnection             
            CHECK_NON_DISCONNECT();

            gettimeofday(&current_time,NULL);
            printf("pass time %d ; test time %d \n\n" , (u32)(current_time.tv_sec - start_time.tv_sec) , test_time );
    
            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {

                MSLEEP(100);
                sla_pkt_chk ++ ;
                if (sla_pkt_chk == 100){
                    printf("sla no number of completed pkts\n");
                    line = __LINE__;
                    goto FUN_FAIL;                  
                }
                goto PKT_CHK;

            }

            sla_pkt_chk = 0;

            //usleep(conn_intval* 3 * 1.25 * 1000);

            sleep_time = conn_intval * 30 * 1.25 * 1000 ;
            calc_alive_time( sleep_time , &alive_time) ;

            sleep (alive_time.tv_sec );
            usleep(alive_time.tv_usec);


            //step2 ~ 4
            if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf)) {
                line = __LINE__;
                goto FUN_FAIL;

            }

            if (0x02 != (buf[_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_+1] & 0xF0) >> 4) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if (0 != memcmp(buf+_BT_HCI_IDX_ACL_DATA_PAYLOAD_ , acl_data ,
                buf[_BT_HCI_IDX_ACL_DATA_LENGTH_]))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;
        }

        // restart encrypiton duration
        
        if (duration == 0){
            duration = (rand() % duration_max)+1;   
        }
        
        LOG_INFO("[sleep duration %d]\n" , duration);
        
        sleep(duration);
        
        duration = g_sla_stress_duration ;


    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_channel_map_update (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    // # get random number channel num    
    int low = 0, up= 36;
    int i,     num = 37;
    int arr[37];
    u32 ch_map_low = 0;
    u8  ch_map_hi  = 0;

    u64 ch_map     = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();
    
    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;

    int duration       = g_sla_stress_duration      ;
    int duration_max   = g_sla_stress_duration_max  ;

    int chmap_num      = g_sla_stress_ch_map_num    ;

    srand(time(NULL));
    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];        

        
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    
    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        gettimeofday(&current_time,NULL);

        shuffle(arr, num, low, up);
        
        for(i=0; i < chmap_num; ++i){
        
            //printf("ch = %d\n", arr[i]);
            if (arr[i] < 32){
                ch_map_low |= (1 << arr[i]);
                //printf("%x %x \n\n" , ch_map_hi , ch_map_low);
            }else{
                ch_map_hi  |= (1 << (arr[i]- 32)) ;
                //printf("%x %x \n\n" , ch_map_hi , ch_map_low);
            }
        
        }

        ch_map = ((u64)(ch_map_hi) << 32 ) | ch_map_low ;

        LOG_INFO("ch map = %x %x\n" , ch_map_hi  , ch_map_low);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){
                        
            COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , ch_map );
            verdict = COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            //usleep(conn_intval * conn_event * 1.25 * 1000);            
            //# wait for updated ch map used
            //usleep(500 * 1000);
#if 0 // TI will detect the environment and change ch_map             
            COMM_Ch_Map_Read_Config(&g_pattern_param , conn_handles_mas);
            verdict = COMM_Ch_Map_Check(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
#endif
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;
        }

        // # reset chmap
        ch_map     = 0 ;
        ch_map_hi  = 0;
        ch_map_low = 0;

        // # restart chmap update
        
        if (duration == 0){
            duration = (rand() % duration_max)+1;   
        }
        
        LOG_INFO("[sleep duration %d]\n" , duration);
        
        sleep(duration);
        
        duration = g_sla_stress_duration ;


    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_channel_map_update_max_trx_acl (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    u32 acl_data_cnt_sla = 0;
    u32 acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    u16 len ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;
    //int chmap_num       = g_sla_stress_ch_map_num         ;


    pid_t pid = -1;    
    u8 check_disconnect  = 0 ;
    int diff  =  0;
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    COMM_Dut_check_payload(dut1_fd , 1);
    COMM_Dut_check_payload(dut2_fd , 1);
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;

    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
    acl_le_pkts_mas = FIXED_MAS_LE_PDU_BUF ;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

            COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
            verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
            printf("Get Event(%d):\n",dut2_fd);
            print_charray(len,buf);
            
            if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
            
            verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1); //waiting encryption change
            
            if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            pid = fork();
            
            if (pid < 0 ){
                line = __LINE__;
                goto FUN_FAIL;
            }

            //######################################
            while(1){
                MSLEEP(1);
                //run child task
                if( pid == 0 ){
                    if(acl_le_pkts_mas > 0){

                        acl_data_len_random = acl_data_len;

                        fill_data(acl_data ,send_cnt);
                        
                        // # init acl data with 1
                        for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_mas;
                        }

                        COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_mas -- ;
                        
                        LOG_INFO("- acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);

                        acl_data_cnt_mas ++;
                        send_cnt ++ ;
                    }


                    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                       
                        LOG_INFO("+ acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);
                    }                     

                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) >= test_time){                        
                        sleep(1);
                        printf("+++ closing child process +++\n");  

                        _exit(0);
                    }else{
                    
                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;

                            check_disconnect = 1;
    
                            //# toggle chmap update 
                            static u64 ch_map_filp = CH_MAP_ODD;
                            ch_map_filp = (~ch_map_filp ) & CH_MAP_FULL ;
                                                        
                            COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , ch_map_filp );
                            verdict = COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
                            VERDICT_RESULT_WITH_LINE();                            

                            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            

                        }
                        
						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }

                    }
                }

                //===========================================================
                //run parent task

                if( pid != 0 ){

                    int status ;
                    //# detect child exit
                    if( 0 != waitpid( pid, &status ,WNOHANG)){
                        printf("get child exit \n");                        
                        goto FUN_FAIL;
                    }
                    
                    if(acl_le_pkts_sla > 0){

                        acl_data_len_random = acl_data_len;

                        fill_data(acl_data ,send_cnt);
                        
                        // # init acl data with 1
                        for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_sla;
                        }

                        //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                        COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_sla -- ;
                        LOG_INFO("- acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);

                        acl_data_cnt_sla ++;
                        send_cnt ++ ;
                    }

                    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;

                        LOG_INFO("+ acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);                
                    } 
                
                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) < (test_time)){
                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;

                            check_disconnect = 1;

                            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            


                        }
                        
                        if((current_time.tv_sec  - start_time.tv_sec ) % 4 == 0){
                            check_disconnect = 0;
                        }
                        
                    }
                    else{

                        printf("--- wait child process end ---\n");
                        fflush(stdout);
                        wait(NULL);                
                        printf("--- child process has already end ---\n");            

                        // use connect handle to disconnect
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
                        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                        VERDICT_RESULT_WITH_LINE();
                    
                        FUNC_END();
                        LOG_INFO("[Pattern][%s]SUCCESS %d\n", __FUNCTION__ , send_cnt);
                  
                        return PASS;
                    }
                }
          }                     
        }
    }


FUN_FAIL:

    switch (pid){
        case -1 :
            break;
        case  0 :
            printf("child exit\n");        
            fflush(stdout);
            _exit(0);                          
            break;
        default :
            terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }

    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}



verdict Sla_stress_connect_param_update_with_slave_latency (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int sla_latency_old = 0;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));

        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        sla_latency_old = sla_latency;

        sla_latency = (rand() % (CONN_SUPERTO_UNIT_US(supervisionTO)/(2*CONN_INTVAL_UNIT_US(conn_intval))))+1;   

        sla_latency = sla_latency > HCI_CMD_PARAM_CONN_LATENCY_MAX_V42 ? \
                        HCI_CMD_PARAM_CONN_LATENCY_MAX_V42: sla_latency;

        if (sla_latency_old == sla_latency){
            if(sla_latency > 1){
                sla_latency --;
            }
        }
        
        LOG_INFO("[sla_latency = %d]\n" , sla_latency);
            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = conn_intval & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(conn_intval & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = conn_intval & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(conn_intval & 0xff00)  >> 8;           


            g_pattern_param.conn_update_param.Conn_Latency[0]            = sla_latency & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Latency[1]            =(sla_latency & 0xff00)  >> 8;
            //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
            //superviision TO > (1+connSlaveLatency)*Conninterval
            g_pattern_param.conn_update_param.Supervision_Timeout[0]     = supervisionTO & 0x00ff; //=0xD0;
            g_pattern_param.conn_update_param.Supervision_Timeout[1]     =(supervisionTO & 0xff00)>> 8 ; //=0x07;

            verdict = COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
REPEAT :             
            CHECK_NON_DISCONNECT();            
            gettimeofday(&current_time,NULL);
            printf("pass time %d ; test time %d \n\n" , (u32)(current_time.tv_sec - start_time.tv_sec) , test_time );

            sleep(1);

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                goto REPEAT;
            }
            else if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                goto REPEAT;
            }     

         
            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                goto REPEAT;
            }
            else if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                goto REPEAT;
            }     

        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_connect_param_update_with_conn_interval (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));

        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    int conn_intval_old = 0;

    while(1)//waiting adv report event , timer or counter
    {
        conn_intval_old = conn_intval ;

        conn_intval = (rand() % (HCI_CMD_PARAM_CONN_INT_MAX - HCI_CMD_PARAM_CONN_INT_MIN) ) + HCI_CMD_PARAM_CONN_INT_MIN;   

        if (conn_intval_old == conn_intval){
            if(conn_intval <= HCI_CMD_PARAM_CONN_INT_MAX){
                conn_intval --;
            }
        }

        
        LOG_INFO("[conn_intval = %d]\n" , conn_intval);
            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = conn_intval & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(conn_intval & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = conn_intval & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(conn_intval & 0xff00)  >> 8;           


            g_pattern_param.conn_update_param.Conn_Latency[0]            = sla_latency & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Latency[1]            =(sla_latency & 0xff00)  >> 8;
            //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
            //superviision TO > (1+connSlaveLatency)*Conninterval
            g_pattern_param.conn_update_param.Supervision_Timeout[0]     = supervisionTO & 0x00ff; //=0xD0;
            g_pattern_param.conn_update_param.Supervision_Timeout[1]     =(supervisionTO & 0xff00)>> 8 ; //=0x07;

            verdict = COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

REPEAT :             
            CHECK_NON_DISCONNECT();

            gettimeofday(&current_time,NULL);
            printf("pass time %d ; test time %d \n\n" , (u32)(current_time.tv_sec - start_time.tv_sec) , test_time );

            sleep(1);
         
            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                goto REPEAT;
            }
            else if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                goto REPEAT;
            }     

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                goto REPEAT;
            }
            else if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                goto REPEAT;
            }     


        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_connect_param_update_max_trx_acl (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    u32 acl_data_cnt_sla = 0;
    u32 acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    u16 len ;

    char now[256];

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;


    pid_t pid = -1;    
    u8 check_disconnect  = 0 ;
    int diff  =  0;
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    COMM_Dut_check_payload(dut1_fd , 1);
    COMM_Dut_check_payload(dut2_fd , 1);
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;

    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;

    acl_le_pkts_mas = FIXED_MAS_LE_PDU_BUF ;            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

            COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
            verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
            printf("Get Event(%d):\n",dut2_fd);
            print_charray(len,buf);
            
            if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
            
            verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1); //waiting encryption change
            
            if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            pid = fork();
            
            if (pid < 0 ){
                printf("pid error [%d]\n" , pid);
                line = __LINE__;
                goto FUN_FAIL;
            }

            //######################################
            while(1){
                //run child task
                if( pid == 0 ){
                    
                    if(acl_le_pkts_mas > 0){

                        acl_data_len_random = acl_data_len;

                        fill_data(acl_data ,send_cnt);
                        
                        // # init acl data with 1
                        for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_mas;
                        }

                        COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_mas -- ;

                        LOG_INFO("%s - acl_le_pkts_mas = %d\n" , now ,acl_le_pkts_mas);

                        acl_data_cnt_mas ++;
                        send_cnt ++ ;
                    }


                    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                                               
                        LOG_INFO("%s + acl_le_pkts_mas = %d\n" , now ,acl_le_pkts_mas);
                    }                     

                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) >= test_time){                        
                        sleep(1);
                        printf("+++ closing child process +++\n");  

                        _exit(0);
                    }else{
                    
                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){

                            diff = current_time.tv_sec  - start_time.tv_sec ;
                            check_disconnect = 1;

                            conn_intval = (rand() % (HCI_CMD_PARAM_CONN_INT_MAX - HCI_CMD_PARAM_CONN_INT_MIN) ) + HCI_CMD_PARAM_CONN_INT_MIN;                               

                            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
                            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = conn_intval & 0x00ff;
                            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(conn_intval & 0xff00)  >> 8;
                            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = conn_intval & 0x00ff;
                            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(conn_intval & 0xff00)  >> 8;                                                                   
                            g_pattern_param.conn_update_param.Conn_Latency[0]            = sla_latency & 0x00ff;
                            g_pattern_param.conn_update_param.Conn_Latency[1]            =(sla_latency & 0xff00)  >> 8;
                            //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
                            //superviision TO > (1+connSlaveLatency)*Conninterval
                            g_pattern_param.conn_update_param.Supervision_Timeout[0]     = supervisionTO & 0x00ff; //=0xD0;
                            g_pattern_param.conn_update_param.Supervision_Timeout[1]     =(supervisionTO & 0xff00)>> 8 ; //=0x07;
                            
                            // don't check verdict 
                            COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
                            log_time(now);                                                                   
                            LOG_INFO("conn update : %s %d [%d]\n" , now , conn_intval , verdict);

                            VERDICT_RESULT_WITH_LINE();


                            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {                                
                                LOG_INFO("disconnect [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON]);
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            

                        }
                        
                        if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }
                    }
                }

                //===========================================================
                //run parent task

                if( pid != 0 ){
                    
                    int status ;
                    //# detect child exit
                    if( 0 != waitpid( pid, &status ,WNOHANG)){
                        printf("get child exit \n");                        
                        goto FUN_FAIL;
                    }
                    
                    
                    if(acl_le_pkts_sla > 0){

                        acl_data_len_random = acl_data_len;

                        fill_data(acl_data ,send_cnt);
                        
                        // # init acl data with 1
                        for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_sla;
                        }

                        COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_sla -- ;                        
                        LOG_INFO("%s - acl_le_pkts_sla = %d\n" , now,acl_le_pkts_sla);

                        acl_data_cnt_sla ++;
                        send_cnt ++ ;
                    }

                    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                        LOG_INFO("%s + acl_le_pkts_sla = %d\n" , now ,acl_le_pkts_sla);                
                    } 
                
                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) < (test_time)){
                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;
                            check_disconnect = 1;

                            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                LOG_INFO("disconnect [%d]\n" , buf[_BT_HCI_EVT_DISCONN_COMP_REASON]);                                
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            


                        }
                        
                        if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }
                        
                    }
                    else{

                        printf("--- wait child process end ---\n");
                        fflush(stdout);
                        wait(NULL);                
                        printf("--- child process has already end ---\n");            

                        // use connect handle to disconnect
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
                        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                        VERDICT_RESULT_WITH_LINE();
                    
                        FUNC_END();
                        LOG_INFO("[Pattern][%s]SUCCESS %d\n", __FUNCTION__ , send_cnt);
                  
                        return PASS;
                    }
                }
          }                     
        }
    }


FUN_FAIL:    
    switch (pid){
        case -1 :
            break;
        case  0 :
            printf("child exit\n");        
            fflush(stdout);
            _exit(0);                          
            break;
        default :
            terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }
    FUNC_END();
    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_connect_param_update_max_conn_interval_slave_latency (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = HCI_CMD_PARAM_CONN_INT_MAX        ;
    int sla_latency     = HCI_CMD_PARAM_MAX_SLAVE_LATENCY_WITH_MAX_CONN_INT_AND_TO        ;
    int supervisionTO   = HCI_CMD_PARAM_SUPERVISION_TO_MAX     ;    

    Calculate_Execution_Time_Start();
    srand(time(NULL));
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    sleep(4);

    printf("set sleep mode with golden dev \n");
    TI_sleep_mode_configurations(dut1_fd);

    while(1)//waiting adv report event , timer or counter
    {

        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){
        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_connect_param_update_max_min_conn_interval_and_channel_map_update (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    int wait_intvak_cnt = 12;

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];

    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = HCI_CMD_PARAM_CONN_INT_MAX      ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    u64 ch_map          = CH_MAP_ODD;

    Calculate_Execution_Time_Start();
    srand(time(NULL));

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    
    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          
    
    
    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {

        conn_intval = (conn_intval == HCI_CMD_PARAM_CONN_INT_MAX) ? HCI_CMD_PARAM_CONN_INT_MIN : HCI_CMD_PARAM_CONN_INT_MAX;

        LOG_INFO("[conn_intval = %d]\n" , conn_intval);
            
        gettimeofday(&current_time,NULL);

        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = conn_intval & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(conn_intval & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = conn_intval & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(conn_intval & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Latency[0]            = sla_latency & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Latency[1]            =(sla_latency & 0xff00)  >> 8;
            //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
            //superviision TO > (1+connSlaveLatency)*Conninterval
            g_pattern_param.conn_update_param.Supervision_Timeout[0]     = supervisionTO & 0x00ff; //=0xD0;
            g_pattern_param.conn_update_param.Supervision_Timeout[1]     =(supervisionTO & 0xff00)>> 8 ; //=0x07;

            verdict = COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            MSLEEP(wait_intvak_cnt * 1.25 * conn_intval);

REPEAT1 :             
            CHECK_NON_DISCONNECT();
            
            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                MSLEEP(wait_intvak_cnt * 1.25 * conn_intval);
                goto REPEAT1;
            }
            else if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                MSLEEP(wait_intvak_cnt * 1.25 * conn_intval);
                goto REPEAT1;
            }     

REPEAT2 :  
            CHECK_NON_DISCONNECT();
            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
                MSLEEP(wait_intvak_cnt * 1.25 * conn_intval);
                goto REPEAT2;
            }
            else if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
                MSLEEP(wait_intvak_cnt * 1.25 * conn_intval);
                goto REPEAT2;
            }

            ch_map = (ch_map == CH_MAP_ODD) ? CH_MAP_EVEN : CH_MAP_ODD;

            COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , ch_map);
            verdict = COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE(); 

            MSLEEP(wait_intvak_cnt * 1.25 * conn_intval);
            CHECK_NON_DISCONNECT();

        }
        else{

            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
            
            COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();


            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_traffic_tx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;

    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    int acl_data_cnt_sla = 0;

    u64 send_cnt     = 0 ;
    int delta_time_cnt   = 0;

    u8 check_disconnect  = 0 ;
    int diff  =  0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;   
    
    int check_times = 0;

    Calculate_Execution_Time_Start();
    srand(time(NULL));

    COMM_Dut_check_payload(dut1_fd , 1);
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            //conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            //conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];         
            
            //######################################
            while(1){
                MSLEEP(1);
                while(acl_le_pkts_sla > 0){
                    if (acl_data_len == 0){

                        acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                        }
                    }
                    else{

                        acl_data_len_random = acl_data_len;

                        fill_data(acl_data ,send_cnt);
    
                        // # init acl data with 1
                        for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_sla;
                        }
                    }

                    //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                    COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                    acl_le_pkts_sla -- ;
                    //LOG_INFO("- acl_le_pkts = %d\n\n" , acl_le_pkts_sla);

                    acl_data_cnt_sla ++;
                    send_cnt ++ ;
                }

WAIT_PKT_SEND :
                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                    acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
    		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                    delta_time_cnt ++ ; 
    	            //gettimeofday(&delta_time[delta_time_cnt],NULL);
                    //pkt_complete[delta_time_cnt] = acl_le_pkts_sla;
                    //LOG_INFO("+ acl_le_pkts = %d\n" , acl_le_pkts_sla);
                }else{

                    goto WAIT_PKT_SEND;
    	        }               

                gettimeofday(&current_time,NULL);
                
                if((current_time.tv_sec - start_time.tv_sec) < test_time){
                    //pkt_cnt ++ ;
                    //# check every 5 sec , avoid busy polling decrease throughput
                    if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                        diff = current_time.tv_sec  - start_time.tv_sec ;

                        check_disconnect = 1;
                        
                        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }       
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            

                    
                        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        } 
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            


                    }

                    if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                        check_disconnect = 0;
                    }

                }
                else{
                    // use connect handle to disconnect
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];

                    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();
                
                    FUNC_END();
                    LOG_INFO("[Pattern][%s]SUCCESS %d\n", __FUNCTION__ , check_times);

                    return PASS;
                }

            }
                        
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_traffic_rx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;

    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    int acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    int delta_time_cnt   = 0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;   
    
    int check_times = 0;
    u8 check_disconnect  = 0 ;
    int diff  =  0;

    Calculate_Execution_Time_Start();
    srand(time(NULL));

    COMM_Dut_check_payload(dut2_fd , 1);
    
    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];         
            
            //######################################
            while(1){
                MSLEEP(1);
                while(acl_le_pkts_mas > 0){
                    if (acl_data_len == 0){

                        acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                        }
                    }
                    else{

                        acl_data_len_random = acl_data_len;

                        fill_data(acl_data ,send_cnt);
    
                        // # init acl data with 1
                        for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_mas;;
                        }
                    }

                    //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                    COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                    acl_le_pkts_mas -- ;
                    //LOG_INFO("- acl_le_pkts = %d\n\n" , acl_le_pkts_sla);

                    acl_data_cnt_mas ++;
                    send_cnt ++ ;
                }

WAIT_PKT_SEND :
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }

                if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                    acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
    		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                    delta_time_cnt ++ ; 
    	            //gettimeofday(&delta_time[delta_time_cnt],NULL);
                    //pkt_complete[delta_time_cnt] = acl_le_pkts_sla;
                    //LOG_INFO("+ acl_le_pkts = %d\n" , acl_le_pkts_sla);
                }else{
                
                    goto WAIT_PKT_SEND;
    	        }               

                gettimeofday(&current_time,NULL);
                
                if((current_time.tv_sec - start_time.tv_sec) < test_time){
                    //pkt_cnt ++ ;
                    //# check every 5 sec , avoid busy polling decrease throughput
                    if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                        diff = current_time.tv_sec  - start_time.tv_sec ;

                        check_disconnect = 1;
                        
                        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }       
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            
                    
                        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        } 
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            


                    }

                    if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                        check_disconnect = 0;
                    }


                }
                else{
                    // use connect handle to disconnect
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];

                    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();
                
                    FUNC_END();
                    LOG_INFO("[Pattern][%s]SUCCESS %d\n", __FUNCTION__ , check_times);

                    return PASS;
                }

            }
                        
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_traffic_encrypt_trx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    u32 acl_data_cnt_sla = 0;
    u32 acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    u16 len ;
    u8 check_disconnect  = 0 ;
    int diff  =  0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;

    pid_t pid = -1;    
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    COMM_Dut_check_payload(dut1_fd , 1);
    COMM_Dut_check_payload(dut2_fd , 1);
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;

    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

            COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
            verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
            printf("Get Event(%d):\n",dut2_fd);
            print_charray(len,buf);
            
            if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
            
            verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1); //waiting encryption change
            
            if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            pid = fork();
            
            if (pid < 0 ){
                line = __LINE__;
                goto FUN_FAIL;
            }
                        
            //######################################
            while(1){
                MSLEEP(1);
                //run child task
                if( pid == 0 ){
                    if(acl_le_pkts_mas > 0){
                        if (acl_data_len == 0){

                            acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                            for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                            }
                        }
                        else{

                            acl_data_len_random = acl_data_len;

                            fill_data(acl_data ,send_cnt);
                            
                            // # init acl data with 1
                            for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = acl_data_cnt_mas;
                            }

                        }

                        //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                        COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_mas -- ;
                        
                        //LOG_INFO("- acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);

                        acl_data_cnt_mas ++;
                        send_cnt ++ ;
                    }


                    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                       
                        //LOG_TIME();                    
                        //LOG_INFO("+ acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);
                    }                     

                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) >= test_time){                        
                        sleep(1);
                        printf("+++ closing child process +++\n");  

                        _exit(0);
                    }else{
                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;

                            check_disconnect = 1;

                            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            


                        }

						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }

                        
                    }
                }

                //===========================================================
                //run parent task

                if( pid != 0 ){

                    //# detect child exit
                    int status;
                    if( 0 != waitpid( pid, &status ,WNOHANG)){
                        printf("get child exit \n");                        
                        goto FUN_FAIL;
                    }
                    
                    if(acl_le_pkts_sla > 0){
                        if (acl_data_len == 0){

                            acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                            for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                            }
                        }
                        else{

                            acl_data_len_random = acl_data_len;

                            fill_data(acl_data ,send_cnt);

                            
                            // # init acl data with 1
                            for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = acl_data_cnt_sla;
                            }

                        }

                        //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                        COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_sla -- ;
                        //LOG_INFO("- acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);

                        acl_data_cnt_sla ++;
                        send_cnt ++ ;
                    }

                    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;

                        //LOG_INFO("+ acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);                
                    } 
                
                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) < (test_time)){

                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                                diff = current_time.tv_sec  - start_time.tv_sec ;

                                check_disconnect = 1;

                                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                }
                                else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                } 
                                if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                }                            
                        }

						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }


                    }
                    else{

                        printf("--- wait child process end ---\n");
                        fflush(stdout);
                        wait(NULL);                
                        printf("--- child process has already end ---\n");            

                        // use connect handle to disconnect
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
                        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                        VERDICT_RESULT_WITH_LINE();
                    
                        FUNC_END();
                        LOG_INFO("[Pattern][%s]SUCCESS %d\n", __FUNCTION__ , send_cnt);
                  
                        return PASS;
                    }
                }
          }                     
        }
    }


FUN_FAIL:

    switch (pid){
        case -1 :
            break;
        case  0 :
            printf("child exit\n");        
            fflush(stdout);
            _exit(0);                          
            break;
        default :
            terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }    

    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_traffic_encrypt_trx_acl_data_6pdu (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    u32 acl_data_cnt_sla = 0;
    u32 acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    u16 len ;
    u8 check_disconnect  = 0 ;
    int diff  =  0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;

    pid_t pid = -1;    
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    COMM_Dut_check_payload(dut1_fd , 1);
    COMM_Dut_check_payload(dut2_fd , 1);
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;

#if 0
    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
#endif
    acl_le_pkts_mas = FIXED_MAS_LE_PDU_BUF ;

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

            COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
            verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
            printf("Get Event(%d):\n",dut2_fd);
            print_charray(len,buf);
            
            if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
            
            verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1); //waiting encryption change
            
            if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            pid = fork();
            
            if (pid < 0 ){
                line = __LINE__;
                goto FUN_FAIL;
            }

            //######################################
            while(1){
                MSLEEP(1);
                //run child task
                if( pid == 0 ){
                    if(acl_le_pkts_mas > 0){
                        if (acl_data_len == 0){

                            acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                            for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                            }
                        }
                        else{

                            acl_data_len_random = acl_data_len;

                            fill_data(acl_data ,send_cnt);
                            
                            // # init acl data with 1
                            for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = acl_data_cnt_mas;
                            }

                        }

                        //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                        COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_mas -- ;
                        
                        //LOG_INFO("- acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);

                        acl_data_cnt_mas ++;
                        send_cnt ++ ;
                    }


                    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                       
                        //LOG_TIME();                    
                        LOG_INFO("+ acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);
                    }                     

                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) >= test_time){                        
                        sleep(1);
                        printf("+++ closing child process +++\n");  

                        _exit(0);
                    }else{
                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;

                            check_disconnect = 1;

                            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            


                        }

						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }

                        
                    }
                }

                //===========================================================
                //run parent task

                if( pid != 0 ){

                    //# detect child exit
                    int status;
                    if( 0 != waitpid( pid, &status ,WNOHANG)){
                        printf("get child exit \n");                        
                        goto FUN_FAIL;
                    }
                    
                    if(acl_le_pkts_sla > 0){
                        if (acl_data_len == 0){

                            acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                            for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                            }
                        }
                        else{

                            acl_data_len_random = acl_data_len;

                            fill_data(acl_data ,send_cnt);

                            
                            // # init acl data with 1
                            for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = acl_data_cnt_sla;
                            }

                        }

                        //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                        COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_sla -- ;
                        LOG_INFO("- acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);

                        acl_data_cnt_sla ++;
                        send_cnt ++ ;
                    }

                    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;

                        //LOG_INFO("+ acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);                
                    } 
                
                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) < (test_time)){

                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                                diff = current_time.tv_sec  - start_time.tv_sec ;

                                check_disconnect = 1;

                                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                }
                                else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                } 
                                if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                    line = __LINE__;
                                    goto FUN_FAIL;
                                }                            
                        }

						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }


                    }
                    else{

                        printf("--- wait child process end ---\n");
                        fflush(stdout);
                        wait(NULL);                
                        printf("--- child process has already end ---\n");            

                        // use connect handle to disconnect
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
                        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                        VERDICT_RESULT_WITH_LINE();
                    
                        FUNC_END();
                        LOG_INFO("[Pattern][%s]SUCCESS %d\n", __FUNCTION__ , send_cnt);
                  
                        return PASS;
                    }
                }
          }                     
        }
    }


FUN_FAIL:
    
    switch (pid){
        case -1 :
            break;
        case  0 :
            printf("child exit\n");        
            fflush(stdout);
            _exit(0);                          
            break;
        default :
            terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stress_max_traffic_tx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    int delta_time_array_size = 10240;

    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   
    struct timeval delta_time[delta_time_array_size];
    int pkt_complete[delta_time_array_size];

    u8 buf[SOCKET_BUF_SIZE];    
    //u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    int acl_data_cnt_sla = 0;

    int send_cnt     = 0 ;
    int delta_time_cnt   = 0;

    int round        = 0 ;
    u8 check_disconnect  = 0 ;
    int diff  =  0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;   
    
    int check_times = 0;

    Calculate_Execution_Time_Start();
    srand(time(NULL));
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            //conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            //conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];         
            
            //######################################
            while(1){
                MSLEEP(1);
                if(acl_le_pkts_sla > 0){
                    if (acl_data_len == 0){

                        acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                        }
                    }
                    else{

                        acl_data_len_random = acl_data_len;
    
                        // # init acl data with 1
                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_sla;
                        }
                    }

                    //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                    COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                    acl_le_pkts_sla -- ;
                    //LOG_INFO("- acl_le_pkts = %d\n\n" , acl_le_pkts_sla);

                    acl_data_cnt_sla ++;
                    send_cnt ++ ;
                }

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                    acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
    		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                    delta_time_cnt ++ ; 
    	            gettimeofday(&delta_time[delta_time_cnt],NULL);
                    pkt_complete[delta_time_cnt] = acl_le_pkts_sla;
                    //LOG_INFO("+ acl_le_pkts = %d\n" , acl_le_pkts_sla);
                }  
                  
                gettimeofday(&current_time,NULL);
                
                if((current_time.tv_sec - start_time.tv_sec) < test_time){

                    //# check every 5 sec , avoid busy polling decrease throughput
                    if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                        diff = current_time.tv_sec  - start_time.tv_sec ;

                        check_disconnect = 1;
                        
                        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }       
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            

                    
                        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        } 
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            


                    }

                    if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                        check_disconnect = 0;
                    }



                }
                else{
                    // use connect handle to disconnect
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];

                    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();
                
                    FUNC_END();
                    LOG_INFO("[Pattern][%s]SUCCESS %d %d\n", __FUNCTION__ , send_cnt , check_times);
	                for (round = 1; round < delta_time_cnt ; round ++){
		                printf("round [%d] [%d]: sec %ld\t , usec %ld\t	,diff %ld\n" , 
			                round , 
                            pkt_complete[round],
			                delta_time[round].tv_sec , 
			                delta_time[round].tv_usec ,
                            delta_time[round].tv_usec - delta_time[round-1].tv_usec);
	                }

                    float diff_time_sec  = delta_time[round].tv_sec   - delta_time[1].tv_sec ; 
                    float diff_time_usec = delta_time[round].tv_usec  - delta_time[1].tv_usec ; 
                    float duration = diff_time_sec*1000000 + diff_time_usec ;

                    LOG_INFO("duration %f \n" , duration); 

                    LOG_INFO("air throughput = %f kbps\n" , (send_cnt*8*27*1000)/(duration));
                    
                    return PASS;
                }

            }
                        
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_max_traffic_rx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;

    int delta_time_array_size = 10240;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   
    struct timeval delta_time[delta_time_array_size];
    int pkt_complete[delta_time_array_size];


    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    int acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    int delta_time_cnt   = 0;

    int round        = 0 ;
    u8 check_disconnect  = 0 ;
    int diff  =  0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;

    
    int check_times = 0;
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    
    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);

    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  
            
            //######################################
            while(1){
                MSLEEP(1);
                if(acl_le_pkts_mas > 0){

                    if (acl_data_len == 0){

                        acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                        }
                    }
                    else{

                        acl_data_len_random = acl_data_len;
    
                        // # init acl data with 1
                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_mas;
                        }
                    }

                    //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                    COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                    acl_le_pkts_mas -- ;
                                                        
                    //LOG_INFO("- acl_le_pkts = %d\n" , acl_le_pkts_mas);

                    acl_data_cnt_mas ++;
                    send_cnt ++ ;
                }


                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                    acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
    		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                    
                    delta_time_cnt ++ ; 
    	            gettimeofday(&delta_time[delta_time_cnt],NULL);
                    pkt_complete[delta_time_cnt] = acl_le_pkts_mas;
                    //LOG_INFO("+ acl_le_pkts = %d\n" , acl_le_pkts_mas);                 
                }  
                    
                gettimeofday(&current_time,NULL);
                
                if((current_time.tv_sec - start_time.tv_sec) < test_time){

                    //# check every 5 sec , avoid busy polling decrease throughput
                    if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                        diff = current_time.tv_sec  - start_time.tv_sec ;

                        check_disconnect = 1;
                        
                        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }       
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            

                    
                        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        } 
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            


                    }

                    if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                        check_disconnect = 0;
                    }



                }
                else{

                    // use connect handle to disconnect
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];

                    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();
                
                    FUNC_END();
                    LOG_INFO("[Pattern][%s]SUCCESS %d %d\n", __FUNCTION__ , send_cnt , check_times);

	                for (round = 1; round < delta_time_cnt ; round ++){
		                printf("round [%d] [%d]: sec %ld\t , usec %ld\t	,diff %ld\n" , 
			                round , 
                            pkt_complete[round],
			                delta_time[round].tv_sec , 
			                delta_time[round].tv_usec ,
                            delta_time[round].tv_usec - delta_time[round-1].tv_usec);
	                }

                    float diff_time_sec  = delta_time[round].tv_sec   - delta_time[1].tv_sec ; 
                    float diff_time_usec = delta_time[round].tv_usec  - delta_time[1].tv_usec ; 
                    float duration = diff_time_sec*1000000 + diff_time_usec ;

                    LOG_INFO("duration %f \n" , duration); 
                    LOG_INFO("air throughput = %f kbps\n" , (send_cnt*8*27*1000)/(duration));                    
                    return PASS;
                }
            }
                        
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    
    return FAIL;

}

verdict Sla_stress_max_traffic_trx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;

    int delta_time_array_size = 10240;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    struct timeval delta_time[delta_time_array_size];
    int pkt_complete[delta_time_array_size];

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    u32 acl_data_cnt_sla = 0;
    u32 acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    int delta_time_cnt   = 0;

    int round        = 0 ;
    u8 check_disconnect  = 0 ;
    int diff  =  0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;

    pid_t pid = -1;    

    int check_times = 0;
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;

    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);

#if 0

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;

	g_pattern_param.adv_param.Advertising_Interval_Min[0]=(HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN) & 0x00ff;
	g_pattern_param.adv_param.Advertising_Interval_Min[1]=((HCI_CMD_PARAM_ADVERTISING_INTERVAL_MIN) & 0xff00) >> 8;


    g_pattern_param.adv_data_param.Advertising_Data_Length[0]=22;
    bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = g_pattern_param.adv_data_param.Advertising_Data_Length;

    u8 adata[22] = { 0x02, 0x01, 0x06, 0x03, 0x03, 0x10, 0x18, 0x03, 0x03, 0x0a, 0x18,
                     0x0a, 0x09, 0x69, 0x43, 0x6f, 0x6d, 0x6d, 0x2E, 0x42, 0x4c, 0x45};

    memcpy( g_pattern_param.adv_data_param.Advertising_Data, adata, 22) ; 
    bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = g_pattern_param.adv_data_param.Advertising_Data;

    verdict = COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);

#endif   

    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ;      //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;

    //sleep(30);
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

            pid = fork();
            
            if (pid < 0 ){
                line = __LINE__;
                goto FUN_FAIL;
            }

            //######################################
            while(1){
                MSLEEP(1);
                //run child task
                if( pid == 0 ){
                    if(acl_le_pkts_mas > 0){
                        if (acl_data_len == 0){

                            acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                            for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                            }
                        }
                        else{

                            acl_data_len_random = acl_data_len;
        
                            for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = acl_data_cnt_mas;
                            }
                        }

                        //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                        COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_mas -- ;
                        
                        //LOG_INFO("- acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);

                        acl_data_cnt_mas ++;
                        send_cnt ++ ;
                    }


                    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
        		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;

                        delta_time_cnt ++ ; 
                        gettimeofday(&delta_time[delta_time_cnt],NULL);
                        pkt_complete[delta_time_cnt] = acl_le_pkts_mas;
                       
                        //LOG_TIME();                    
                        //LOG_INFO("+ acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);
                    }                     

                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) >= test_time){                        
                        sleep(1);
                        printf("+++ closing child process +++\n");
                        LOG_INFO("master tx :\n");

                        for (round = 1; round < delta_time_cnt ; round ++){
                            LOG_INFO("round [%d] [%d]: sec %u\t , usec %u\t ,diff %u\n" , 
                                round , 
                                pkt_complete[round],
                                (unsigned int)delta_time[round].tv_sec , 
                                (unsigned int)delta_time[round].tv_usec ,
                                (unsigned int)(delta_time[round].tv_usec - delta_time[round-1].tv_usec));
                        }
                
                        float diff_time_sec  = delta_time[round].tv_sec   - delta_time[1].tv_sec ; 
                        float diff_time_usec = delta_time[round].tv_usec  - delta_time[1].tv_usec ; 
                        float duration = diff_time_sec*1000000 + diff_time_usec ;
                           
                        LOG_INFO("duration %f \n" , duration); 
                        LOG_INFO("air throughput = %f kbps\n" , (send_cnt*8*27*1000)/(duration));     

                        _exit(0);
                    }else{
                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;

                            check_disconnect = 1;

                            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            


                        }

						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }


                        
                    }
                }

                //===========================================================
                //run parent task

                if( pid != 0 ){

                    //# detect child exit
					int status ;
                    if( 0 != waitpid( pid, &status ,WNOHANG)){
                        printf("get child exit \n");                        
                        goto FUN_FAIL;
                    }
                    
                    if(acl_le_pkts_sla > 0){
                        if (acl_data_len == 0){

                            acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                            for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                            }
                        }
                        else{

                            acl_data_len_random = acl_data_len;
        
                            // # init acl data with 1
                            for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                                acl_data[acl_init_cnt] = acl_data_cnt_sla;
                            }
                        }

                        //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                        COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_sla -- ;
                        //LOG_INFO("- acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);

                        acl_data_cnt_sla ++;
                        send_cnt ++ ;
                    }

                    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
        		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;

                        //LOG_INFO("+ acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);

                        delta_time_cnt ++ ; 
                        gettimeofday(&delta_time[delta_time_cnt],NULL);
                        pkt_complete[delta_time_cnt] = acl_le_pkts_sla;                        
                    } 
                
                    gettimeofday(&current_time,NULL);
                    
                    if((current_time.tv_sec - start_time.tv_sec) < (test_time)){

                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;

                            check_disconnect = 1;

                            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            


                        }

						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }



                    }
                    else{

                        printf("--- wait child process end ---\n");
                        fflush(stdout);
                        wait(NULL);                
                        printf("--- child process has already end ---\n");            

                        // use connect handle to disconnect
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
                        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                        VERDICT_RESULT_WITH_LINE();
                    
                        FUNC_END();
                        LOG_INFO("[Pattern][%s]SUCCESS %d %d\n", __FUNCTION__ , send_cnt , check_times);

                        LOG_INFO("slave tx :\n");
                        for (round = 1; round < delta_time_cnt ; round ++){
                            LOG_INFO("round [%d] [%d]: sec %u\t , usec %u\t ,diff %u\n" , 
                                round , 
                                pkt_complete[round],
                                (unsigned int)delta_time[round].tv_sec , 
                                (unsigned int)delta_time[round].tv_usec ,
                                (unsigned int)(delta_time[round].tv_usec - delta_time[round-1].tv_usec));
                        }
                        
                        float diff_time_sec  = delta_time[round].tv_sec   - delta_time[1].tv_sec ; 
                        float diff_time_usec = delta_time[round].tv_usec  - delta_time[1].tv_usec ; 
                        float duration = diff_time_sec*1000000 + diff_time_usec ;
                        
                        LOG_INFO("duration %f \n" , duration); 
                        LOG_INFO("air throughput = %f kbps\n" , (send_cnt*8*27*1000)/(duration));                    
                        return PASS;
                    }
                }
          }                     
        }
    }


FUN_FAIL:    
    
    switch (pid){
        case -1 :
            break;
        case  0 :
            printf("child exit\n");        
            fflush(stdout);
            _exit(0);                          
            break;
        default :
            terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }

    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_max_traffic_encrypt_tx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    int delta_time_array_size = 10240;

    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   
    struct timeval delta_time[delta_time_array_size];
    int pkt_complete[delta_time_array_size];

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    int acl_data_cnt_sla = 0;

    int send_cnt     = 0 ;
    int delta_time_cnt   = 0;

    int round        = 0 ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;   
    
    int check_times = 0;
    u16 len = 0;
    u8 check_disconnect  = 0 ;
    int diff  =  0;

    Calculate_Execution_Time_Start();
    srand(time(NULL));
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];         

            COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
            verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
            printf("Get Event(%d):\n",dut2_fd);
            print_charray(len,buf);
            
            if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
            
            verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1); //waiting encryption change
            
            if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            
            //######################################
            while(1){
                MSLEEP(1);
                if(acl_le_pkts_sla > 0){

                    if (acl_data_len == 0){

                        acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                        }
                    }
                    else{

                        acl_data_len_random = acl_data_len;
    
                        // # init acl data with 1
                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_sla;
                        }
                    }

                    //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                    COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                    acl_le_pkts_sla -- ;
                    //LOG_INFO("- acl_le_pkts = %d\n\n" , acl_le_pkts_sla);

                    acl_data_cnt_sla ++;
                    send_cnt ++ ;
                }

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                    acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
    		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                    delta_time_cnt ++ ; 
    	            gettimeofday(&delta_time[delta_time_cnt],NULL);
                    pkt_complete[delta_time_cnt] = acl_le_pkts_sla;
                    //LOG_INFO("+ acl_le_pkts = %d\n" , acl_le_pkts_sla);
                }  
                  
                gettimeofday(&current_time,NULL);
                
                if((current_time.tv_sec - start_time.tv_sec) < test_time){

                    //# check every 5 sec , avoid busy polling decrease throughput
                    if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                        diff = current_time.tv_sec  - start_time.tv_sec ;

                        check_disconnect = 1;
                        
                        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }       
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            

                    
                        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        } 
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            


                        check_times ++ ;
                    }

                    if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                        check_disconnect = 0;
                    }



                }
                else{

                    // use connect handle to disconnect
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_mas[0];
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_mas[1];
                    
                    COMM_Disconnect_Config(dut1, &g_pattern_param, buf);                
                    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                    verdict = COMM_Disconnect(dut1_fd, g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();

                
                    FUNC_END();
                    LOG_INFO("[Pattern][%s]SUCCESS %d %d\n", __FUNCTION__ , send_cnt , check_times);
	                for (round = 1; round < delta_time_cnt ; round ++){
		                printf("round [%d] [%d]: sec %ld\t , usec %ld\t	,diff %ld\n" , 
			                round , 
                            pkt_complete[round],
			                delta_time[round].tv_sec , 
			                delta_time[round].tv_usec ,
                            delta_time[round].tv_usec - delta_time[round-1].tv_usec);
	                }

                    float diff_time_sec  = delta_time[round].tv_sec   - delta_time[1].tv_sec ; 
                    float diff_time_usec = delta_time[round].tv_usec  - delta_time[1].tv_usec ; 
                    float duration = diff_time_sec*1000000 + diff_time_usec ;

                    LOG_INFO("duration %f \n" , duration); 

                    LOG_INFO("air throughput = %f kbps\n" , (send_cnt*8*27*1000)/(duration));
                    
                    return PASS;

                }

            }
                        
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stress_max_traffic_encrypt_rx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;

    int delta_time_array_size = 10240;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   
    struct timeval delta_time[delta_time_array_size];
    int pkt_complete[delta_time_array_size];


    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    int acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    int delta_time_cnt   = 0;

    int round        = 0 ;
    u16 len ;
    u8 check_disconnect  = 0 ;
    int diff  =  0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;

    
    int check_times = 0;
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    
    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);

    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();


    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

            COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
            verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
            printf("Get Event(%d):\n",dut2_fd);
            print_charray(len,buf);
            
            if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
            
            verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1); //waiting encryption change
            
            if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            
            //######################################
            while(1){
                MSLEEP(1);
                if(acl_le_pkts_mas > 0){

                    if (acl_data_len == 0){

                        acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                        }
                    }
                    else{

                        acl_data_len_random = acl_data_len;
    
                        // # init acl data with 1
                        for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_mas;
                        }
                    }

                    //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                    COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                    acl_le_pkts_mas -- ;
                                                        
                    //LOG_INFO("- acl_le_pkts = %d\n" , acl_le_pkts_mas);

                    acl_data_cnt_mas ++;
                    send_cnt ++ ;
                }


                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                    acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
    		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                    
                    delta_time_cnt ++ ; 
    	            gettimeofday(&delta_time[delta_time_cnt],NULL);

                    pkt_complete[delta_time_cnt] = acl_le_pkts_mas;

                    //LOG_INFO("+ acl_le_pkts = %d\n" , acl_le_pkts_mas);                 
                }  
                    
                gettimeofday(&current_time,NULL);
                
                if((current_time.tv_sec - start_time.tv_sec) < test_time){

                    //# check every 5 sec , avoid busy polling decrease throughput
                    if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                        diff = current_time.tv_sec  - start_time.tv_sec ;

                        check_disconnect = 1;
                        
                        if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }       
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            

                    
                        if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }
                        else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        } 
                        if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                            line = __LINE__;
                            goto FUN_FAIL;
                        }                            


                        check_times ++ ;
                        //LOG_INFO("check %d \n" , check_times );
                    }


                    if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                        check_disconnect = 0;
                    }


                }
                else{

                    // use connect handle to disconnect
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
                    
                    COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                    g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                    verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                    VERDICT_RESULT_WITH_LINE();

                
                    FUNC_END();
                    LOG_INFO("[Pattern][%s]SUCCESS %d %d\n", __FUNCTION__ , send_cnt , check_times);

	                for (round = 1; round < delta_time_cnt ; round ++){
		                printf("round [%d] [%d]: sec %ld\t , usec %ld\t	,diff %ld\n" , 
			                round , 
                            pkt_complete[round],
			                delta_time[round].tv_sec , 
			                delta_time[round].tv_usec ,
                            delta_time[round].tv_usec - delta_time[round-1].tv_usec);
	                }

                    float diff_time_sec  = delta_time[round].tv_sec   - delta_time[1].tv_sec ; 
                    float diff_time_usec = delta_time[round].tv_usec  - delta_time[1].tv_usec ; 
                    float duration = diff_time_sec*1000000 + diff_time_usec ;

                    LOG_INFO("duration %f \n" , duration); 
                    LOG_INFO("air throughput = %f kbps\n" , (send_cnt*8*27*1000)/(duration));                    

                    return PASS;

                }
            }
                        
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}


verdict Sla_stress_max_traffic_encrypt_trx_acl_data (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;
    
    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;   

    u8 buf[SOCKET_BUF_SIZE];    
    u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};
    u8 acl_le_pkts_sla;
    u8 acl_le_pkts_mas;

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    u32 acl_data_cnt_sla = 0;
    u32 acl_data_cnt_mas = 0;

    int send_cnt     = 0 ;
    u16 len ;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;


    pid_t pid = -1;    
    u8 check_disconnect  = 0 ;
    int diff  =  0;
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));

    COMM_Dut_check_payload(dut1_fd , 1);
    COMM_Dut_check_payload(dut2_fd , 1);
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;

    verdict=COMM_Read_LE_Buffer_Size(dut1_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
            
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    gettimeofday(&start_time,NULL);

    while(1)//waiting adv report event , timer or counter
    {
        if(1 == read_le_event_get())
        {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];          


            if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];  

            COMM_Start_Encryption_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
            verdict=COMM_Start_Encryption(dut1_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            do{
                socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
            printf("Get Event(%d):\n",dut2_fd);
            print_charray(len,buf);
            
            if(SUCCESS != hci_le_event_ltk_request_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            COMM_Ltk_Req_Rep_Config(dut2_fd,&g_pattern_param, conn_handles_sla);//peer conn_handle?
            
            verdict=COMM_Ltk_Req_Rep(dut2_fd,g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            sleep(1); //waiting encryption change
            
            if (SUCCESS != QUERY_Event(dut2_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if (SUCCESS != QUERY_Event(dut1_fd,buf ,_BT_HCI_EVENT_OP_ENCRYPTION_CHANGE_))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }
            
            if(SUCCESS != hci_event_encryption_change_parsing(0,buf,g_pattern_param))
            {
                line=__LINE__;
                goto FUN_FAIL;
            }

            pid = fork();
            
            if (pid < 0 ){
                line = __LINE__;
                goto FUN_FAIL;
            }

            //######################################
            while(1){
                MSLEEP(1);
                //run child task
                if( pid == 0 ){
                    if(acl_le_pkts_mas > 0){

                        acl_data_len_random = acl_data_len;

                        fill_data(acl_data ,send_cnt);

                        
                        // # init acl data with 1
                        for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_mas;
                        }

                        COMM_Send_ACL_Data_Without_event(dut1_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_mas -- ;
                        
                        //LOG_INFO("- acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);

                        acl_data_cnt_mas ++;
                        send_cnt ++ ;
                    }


                    if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;
                       
                        //LOG_TIME();                    
                        //LOG_INFO("+ acl_le_pkts_mas = %d\n" , acl_le_pkts_mas);
                    }                     

                    gettimeofday(&current_time,NULL);

                    if((current_time.tv_sec - start_time.tv_sec) >= test_time){                        
                        sleep(1);
                        printf("+++ closing child process +++\n");  

                        _exit(0);
                    }else{
                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;

                            check_disconnect = 1;

                            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            


                        }

						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }

                        
                    }
                }

                //===========================================================
                //run parent task

                if( pid != 0 ){

                    //# detect child exit
					int status ;
                    if( 0 != waitpid( pid, &status ,WNOHANG)){
                        printf("get child exit \n");                        
                        goto FUN_FAIL;
                    }
                    
                    if(acl_le_pkts_sla > 0){

                        acl_data_len_random = acl_data_len;

                        fill_data(acl_data ,send_cnt);
                        
                        // # init acl data with 1
                        for ( acl_init_cnt = 3 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                            acl_data[acl_init_cnt] = acl_data_cnt_sla;
                        }

                        //LOG_INFO("acl_data_len = %d \n" , acl_data_len_random);

                        COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                        acl_le_pkts_sla -- ;
                        //LOG_INFO("- acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);

                        acl_data_cnt_sla ++;
                        send_cnt ++ ;
                    }

                    if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                        line = __LINE__;
                        goto FUN_FAIL;
                    }
                    else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                        acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
                                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS] ;

                        //LOG_INFO("+ acl_le_pkts_sla = %d\n" , acl_le_pkts_sla);                
                    } 
                
                    gettimeofday(&current_time,NULL);
                    
                    if((current_time.tv_sec - start_time.tv_sec) < (test_time)){

                        //# check every 5 sec , avoid busy polling decrease throughput
                        if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                            diff = current_time.tv_sec  - start_time.tv_sec ;

                            check_disconnect = 1;

                            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }
                            else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            } 
                            if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                                line = __LINE__;
                                goto FUN_FAIL;
                            }                            

                        }

						if((current_time.tv_sec  - start_time.tv_sec )  == (diff + 1)){                            
                            check_disconnect = 0;
                        }


                    }
                    else{

                        printf("--- wait child process end ---\n");
                        fflush(stdout);
                        wait(NULL);                
                        printf("--- child process has already end ---\n");            

                        // use connect handle to disconnect
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
                        buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
                        COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
                        g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
                        verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
                        VERDICT_RESULT_WITH_LINE();
                    
                        FUNC_END();
                        LOG_INFO("[Pattern][%s]SUCCESS %d\n", __FUNCTION__ , send_cnt);
                  
                        return PASS;
                    }
                }
          }                     
        }
    }


FUN_FAIL:

    switch (pid){
        case -1 :
            break;
        case  0 :
             printf("child exit\n");
            sleep(1);
            fflush(stdout);
            _exit(0);                          
            break;
        default :
             terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }

    FUNC_END();
    
    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);
    return FAIL;

}

verdict Sla_stress_max_traffic_tx_acl_data_without_flow_ctrl (u8 dut1_fd ,u8 dut2_fd)
{
    int dut1 = 0;
    int dut2 = 0;

    u16 line = 0;
    int verdict = FAIL;

    struct itimerval timer;
    struct timeval start_time;                      
    struct timeval current_time;
    struct timeval start_query_num_of_packets_time;                      
    struct timeval current_query_num_of_packets_time;

    u8 buf[SOCKET_BUF_SIZE];    
    //u8 conn_handles_mas[2];
    u8 conn_handles_sla[2];

    u8 acl_data[ACL_DATA_MAX] = {0};

    int acl_init_cnt = 0 ;
    u8 acl_le_pkts_sla;
    int acl_data_cnt_sla = 0;
    u32 acl_le_pkts_send_cnt_sla = 0;
    u32 acl_le_pkts_miss_cnt_sla = 0;
    u32 acl_le_pkts_recv_cnt_mas = 0;

    u8 check_disconnect  = 0 ;
    int diff  =  0;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    SLA_STRESS_PATTERN_CONFIG_READ();

    int test_time       = g_sla_stress_test_time          ;         //# param
    int conn_intval     = g_sla_stress_conn_intval        ;
    int sla_latency     = g_sla_stress_sla_latency        ;
    int supervisionTO   = g_sla_stress_supervision_to     ;    
    int acl_data_len    = g_sla_stress_acl_date_len       ;   
    
    Calculate_Execution_Time_Start();
    srand(time(NULL));
    
    verdict=COMM_Read_LE_Buffer_Size(dut2_fd,&g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets * 2;

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);

    g_pattern_param.create_conn_param.LE_Scan_Interval[0]       =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Interval[1]       =   0;
    g_pattern_param.create_conn_param.LE_Scan_Window[0]         =   0xA0;
    g_pattern_param.create_conn_param.LE_Scan_Window[1]         =   0;

    g_pattern_param.create_conn_param.Conn_Interval_Min[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Min[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Interval_Max[0]      =    conn_intval & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Interval_Max[1]      =   (conn_intval & 0xff00)  >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]           =    sla_latency & 0x00ff;
    g_pattern_param.create_conn_param.Conn_Latency[1]           =   (sla_latency & 0xff00)  >> 8;
    //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
    //superviision TO > (1+connSlaveLatency)*Conninterval
    g_pattern_param.create_conn_param.Supervision_Timeout[0]    =    supervisionTO & 0x00ff ; //=0xD0;
    g_pattern_param.create_conn_param.Supervision_Timeout[1]    =   (supervisionTO & 0xff00)>> 8 ; //=0x07;
    
    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(dut1_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    //conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    //conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1]; 

    if (SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];         
            
    //######################################

    gettimeofday(&start_time, NULL);

    while(1){

        for(acl_data_cnt_sla = 0; acl_data_cnt_sla < acl_le_pkts_sla; acl_data_cnt_sla++) {

            if (acl_data_len == 0){
                acl_data_len = (rand() % ACL_DATA_MAX) + 1;
            }

            for ( acl_init_cnt = 0 ; acl_init_cnt < acl_data_len ; acl_init_cnt ++){
                acl_data[acl_init_cnt] = acl_data_cnt_sla;
            }

            COMM_Send_ACL_Data_Without_event(dut2_fd, conn_handles_sla, 0b00, 0, acl_data_len, acl_data);

            MSLEEP(1);
        }

        acl_le_pkts_send_cnt_sla = 0;
        acl_le_pkts_miss_cnt_sla = 0;

        gettimeofday(&start_query_num_of_packets_time, NULL);

        while(1) {
            MSLEEP(1 * 1.25 * conn_intval);

            COMM_Dut_check_data_buffer_overflow_num(dut2_fd, &acl_le_pkts_miss_cnt_sla);
            COMM_Dut_check_num_of_packets_num(dut2_fd, &acl_le_pkts_send_cnt_sla);

            if((acl_le_pkts_send_cnt_sla + acl_le_pkts_miss_cnt_sla) == acl_le_pkts_sla) {
                break;
            }
            else {
                gettimeofday(&current_query_num_of_packets_time, NULL);
                if((current_query_num_of_packets_time.tv_sec - start_query_num_of_packets_time.tv_sec) > 
                    (supervisionTO * 10 / 1000) + 1) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
            }
        }

        LOG_INFO("Sla Send : %d Miss : %d\n", acl_le_pkts_send_cnt_sla, acl_le_pkts_miss_cnt_sla);

        MSLEEP(3 * 1.25 * conn_intval);

        acl_le_pkts_recv_cnt_mas = 0;
        COMM_Dut_check_rx_acl_packets_cnt(dut1_fd, &acl_le_pkts_recv_cnt_mas);

        if(acl_le_pkts_recv_cnt_mas != acl_le_pkts_send_cnt_sla) {
            line = __LINE__;
            goto FUN_FAIL;
        }

        LOG_INFO("Mas Recv : %d\n", acl_le_pkts_recv_cnt_mas);

        COMM_Dut_clean_buffer(dut2_fd);
        COMM_Dut_clean_buffer(dut1_fd);

        gettimeofday(&current_time, NULL);
                
        if((current_time.tv_sec - start_time.tv_sec) < test_time){

            //# check every 5 sec , avoid busy polling decrease throughput
            if(((current_time.tv_sec  - start_time.tv_sec ) % 5 == 0) && (check_disconnect == 0)){
                diff = current_time.tv_sec  - start_time.tv_sec ;

                check_disconnect = 1;
                        
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }       
                if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }                            

                if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                } 
                if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }                            
            }

            if((current_time.tv_sec  - start_time.tv_sec ) == (diff + 1)){                            
                check_disconnect = 0;
            }
        }
        else{
            // use connect handle to disconnect
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
            buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];

            COMM_Disconnect_Config(dut2, &g_pattern_param, buf);                
            g_pattern_param.disconn_param.Reason[0] = HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST;
            verdict = COMM_Disconnect(dut2_fd, g_pattern_param);
            VERDICT_RESULT_WITH_LINE();
            
            FUNC_END();
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
   
            return PASS;
        }
    }
                        
FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL!!\n" , __FUNCTION__, line);

    return FAIL;
}

verdict TEST_MAS_Master_Sending_Conn_Req(u8 dut1_fd )
{
	int verdict=FAIL;
	int dut1 =0;
	u16 line =0 ;

	COMM_INI_Initiating_Config(dut1,&g_pattern_param);
	verdict=COMM_INI_Initiating(dut1_fd,g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

#if 0
	u64 ch_map =0x05;
	sleep(1);
	COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , ch_map);
	COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
#endif


#if 0
	u8 conn_handle[2] ={0x01 ,0x04};
	sleep(2);
	COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handle);
	COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
#endif

	LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
	return PASS;

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
	return FAIL;


}

verdict Perf_Scan_Active(u8 dut1_fd ,u8 dut2_fd){

	int verdict = FAIL;
	int dut1 = 0, dut2 = 0;
	u16 line = 0;
	u32 adv_cnt = 0;
    u32 scan_rsp_cnt = 0;
	struct itimerval timer;
    u16 time_reduce = 1;
    u16 test_time   = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
    
	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    set_adv_interval(20);    

    COMM_SCN_Active_Scanning_Config(0, &g_pattern_param);
    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        
	verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE(); 

	verdict=COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

	while (1)//waiting adv report event , timer or counter
	{
	    if (1 == read_le_event_get())
        {   
            while (read_le_event_get()){                
                MSLEEP(10);
            }

            COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, &scan_rsp_cnt);

            printf("\n### adv_cnt %d | scan_rsp_cnt %d ###\n", adv_cnt, scan_rsp_cnt);

            // the ideal value : (30(s) / 25(ms)) * (300(ms) / 300(ms)) = 1200
            //adv_cnt + scan_rsp_cnt = 1200 * 2 = 2400
            if (((float)(((adv_cnt + scan_rsp_cnt) * 100) / ((2400) / time_reduce))) <= 90) {
                LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
		        LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 2400 / time_reduce);
		        LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d | scan_rsp_cnt %d | total_cnt %d\n", __FUNCTION__, adv_cnt, scan_rsp_cnt, adv_cnt + scan_rsp_cnt);
		        LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_cnt + scan_rsp_cnt) * 100) / (2400 / time_reduce)));
                line=__LINE__;
			    goto FUN_FAIL;
            }
            else {			

                FUNC_END();

                LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
		        LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 2400 / time_reduce);
		        LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d | scan_rsp_cnt %d | total_cnt %d\n", __FUNCTION__, adv_cnt, scan_rsp_cnt, adv_cnt + scan_rsp_cnt);
		        LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_cnt + scan_rsp_cnt) * 100) / (2400 / time_reduce)));
            }        

		    return PASS;
            
        }
    }

FUN_FAIL:    
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}


verdict Perf_Scan_Passive(u8 dut1_fd ,u8 dut2_fd){

	int verdict = FAIL;
	int dut1 = 0, dut2 = 0;
	u16 line = 0;
	u32 adv_cnt = 0;
	struct itimerval timer;
    u16 time_reduce = 1;
    u16 test_time   = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
	memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
	verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

	COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    set_adv_interval(20); 

    COMM_SCN_Passive_Scanning_Config(0, &g_pattern_param);
    
    set_scan_interval(300);
    set_scan_windows(300);
    set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        
    verdict = COMM_SCN_Passive_Scanning(dut1_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE(); 

	verdict=COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    read_le_event_enable();

    event_query_timer_config(test_time/time_reduce, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

	while (1)//waiting adv report event , timer or counter
	{
	    if (1 == read_le_event_get())
        {   
            while (read_le_event_get()){
                
                MSLEEP(100);
            }

            COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, NULL);
            
            printf("\n### adv_cnt %d ###\n", adv_cnt);

            // the ideal value : (30(s) / 25(ms)) * (300(ms) / 300(ms)) = 1200
            if (((float)((adv_cnt * 100) / ((1200) / time_reduce))) <= 90) {
                LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
		        LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1200 / time_reduce);
		        LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_cnt);
		        LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / (1200 / time_reduce)));
                line=__LINE__;
			    goto FUN_FAIL;
            }
            else {			

                FUNC_END();

                LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
		        LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, 1200 / time_reduce);
		        LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_cnt);
		        LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / (1200 / time_reduce)));
            }        

		    return PASS;
            
        }
    }

FUN_FAIL:    
    FUNC_END();

	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

verdict Perf_Adv_plus_scan_favor_adv(u8 dut1_fd ,u8 dut2_fd){

    int verdict = FAIL;
    u16 line = 0;
    u32 adv_cnt_peer  = 0;
    u32 adv_cnt_local = 0; 
    u32 scan_rsp_cnt_peer = 0;
    u32 scan_rsp_cnt_local = 0;

    struct itimerval timer;
    u16 test_time   = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
#if 0
    COMM_INI_Connection_Setup_White_Listed_Config(0, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(0, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(0, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(0, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
#endif

    //peer = advertiser ; local = adv+scanner ,priority = adv , active
    SSV_Set_adv_channel_priority(dut1_fd ,ADVERTISING_CHANNEL_FAVOR_ADVERTISER);

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    //set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    set_adv_interval(20);    

    COMM_SCN_Active_Scanning_Config( 0, &g_pattern_param);
    set_scan_interval(300);
    set_scan_windows(300);
    //set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);

    verdict=COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict=COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){
        MSLEEP(10);
    }

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt_local, &scan_rsp_cnt_local);

    LOG_INFO("peer = advertiser ; local = adv+scanner ,priority = adv , active\n");            
    LOG_INFO("Ideal value : %d\n", 2400);
    LOG_INFO("Exp   value : adv_cnt_local %d | scan_rsp_cnt_local %d | total_cnt_local %d\n", 
                                        adv_cnt_local, scan_rsp_cnt_local, adv_cnt_local + scan_rsp_cnt_local);
    LOG_INFO("Ratio value : %.2f %%\n", (float)(((adv_cnt_local + scan_rsp_cnt_local) * 100) / (2400)));

    FUNC_END();
    
////
    LOG_INFO("\n");

    Calculate_Execution_Time_Start();
    //peer = scanner ; local = adv+scanner ,priority = adv , active
    SSV_Set_adv_channel_priority(dut1_fd ,ADVERTISING_CHANNEL_FAVOR_ADVERTISER);

    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    //set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    set_adv_interval(20);    

    COMM_SCN_Active_Scanning_Config(0, &g_pattern_param);
    set_scan_interval(300);
    set_scan_windows(300);
    //set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);

    verdict = COMM_SCN_Active_Scanning(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    verdict=COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict=COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){
        MSLEEP(10);
    }

    COMM_Dut_check_adv_rpt_num(dut2_fd, &adv_cnt_peer, &scan_rsp_cnt_peer);

    LOG_INFO("peer = scanner ; local = adv+scanner ,priority = adv , active\n");            
    LOG_INFO("Ideal value : %d\n", 2400);
    LOG_INFO("Exp   value : adv_cnt_peer %d | scan_rsp_cnt_peer %d | total_cnt_peer %d\n", 
                                        adv_cnt_peer, scan_rsp_cnt_peer, adv_cnt_peer + scan_rsp_cnt_peer);
    LOG_INFO("Ratio value : %.2f %%\n", (float)(((adv_cnt_peer + scan_rsp_cnt_peer) * 100) / (2400)));

    FUNC_END();
            
    return PASS;
            

FUN_FAIL:    
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;


}


verdict Perf_Adv_plus_scan_favor_scn(u8 dut1_fd ,u8 dut2_fd){

    int verdict = FAIL;
    u16 line = 0;
    u32 adv_cnt_peer  = 0;
    u32 adv_cnt_local = 0; 
    u32 scan_rsp_cnt_peer = 0;
    u32 scan_rsp_cnt_local = 0;

    struct itimerval timer;
    u16 test_time   = 30;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();
#if 0
    COMM_INI_Connection_Setup_White_Listed_Config(0, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(0, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(0, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, adv_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Connection_Setup_White_Listed_Config(0, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
#endif

    //peer = advertiser ; local = adv+scanner ,priority = scan , active
    SSV_Set_adv_channel_priority(dut1_fd ,ADVERTISING_CHANNEL_FAVOR_SCANNER_INITIATOR);
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    //set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    set_adv_interval(20);    

    COMM_SCN_Active_Scanning_Config(0, &g_pattern_param);
    set_scan_interval(300);
    set_scan_windows(300);
    //set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);

    verdict=COMM_ADV_Undirected_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict=COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){
        MSLEEP(10);
    }

    COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt_local, &scan_rsp_cnt_local);

    LOG_INFO("peer = advertiser ; local = adv+scanner ,priority = scan , active\n");            
    LOG_INFO("Ideal value : %d\n", 2400);
    LOG_INFO("Exp   value : adv_cnt_local %d | scan_rsp_cnt_local %d | total_cnt_local %d\n", 
                                        adv_cnt_local, scan_rsp_cnt_local, adv_cnt_local + scan_rsp_cnt_local);
    LOG_INFO("Ratio value : %.2f %%\n", (float)(((adv_cnt_local + scan_rsp_cnt_local) * 100) / (2400)));

    FUNC_END();

////////

    LOG_INFO("\n");

    Calculate_Execution_Time_Start();
    //peer = scanner ; local = adv+scanner ,priority = adv , active
    SSV_Set_adv_channel_priority(dut1_fd ,ADVERTISING_CHANNEL_FAVOR_SCANNER_INITIATOR);
    COMM_ADV_Undirected_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    //set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    set_adv_interval(20);    

    COMM_SCN_Active_Scanning_Config(0, &g_pattern_param);
    set_scan_interval(300);
    set_scan_windows(300);
    //set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);

    verdict=COMM_SCN_Active_Scanning(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    verdict=COMM_ADV_Undirected_Advertising(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();
        
    verdict = COMM_SCN_Active_Scanning(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE(); 

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){
        MSLEEP(10);
    }

    COMM_Dut_check_adv_rpt_num(dut2_fd, &adv_cnt_peer, &scan_rsp_cnt_peer);

    LOG_INFO("peer = scanner ; local = adv+scanner ,priority = scan , active\n");            
    LOG_INFO("Ideal value : %d\n", 2400);
    LOG_INFO("Exp   value : adv_cnt_peer %d | scan_rsp_cnt_peer %d | total_cnt_peer %d\n", 
                                        adv_cnt_peer, scan_rsp_cnt_peer, adv_cnt_peer + scan_rsp_cnt_peer);
    LOG_INFO("Ratio value : %.2f %%\n", (float)(((adv_cnt_peer + scan_rsp_cnt_peer) * 100) / (2400)));

    FUNC_END();
            
    return PASS;
            

FUN_FAIL:    
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;


}

verdict Perf_Sla_Adv(dut_setting *sla_adv, dut_setting *mas, dut_setting *scn, int adv_type, int scn_type){

    int dut1_fd = mas->dut_fd;
    int dut2_fd = sla_adv->dut_fd;
    int verdict = FAIL;
    u16 line = 0;
   
    struct itimerval timer;
    
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];

    int adv_Channel = 37;
    u32 adv_adv_cnt = 0;
    u32 adv_scn_rsp_cnt = 0;

    COMM_Dut_clean_buffer(sla_adv->dut_fd);
    COMM_Dut_clean_buffer(mas->dut_fd);
    COMM_Dut_clean_buffer(scn->dut_fd);

    MULTIROLE_SLA_PERF_PATTERN_CONFIG_READ();

    int test_time   = g_multirole_sla_perf_test_time;
    int adv_intval = g_multirole_sla_perf_adv_intval;
    int scn_intval = g_multirole_sla_perf_scan_intval;
    int scn_window = g_multirole_sla_perf_scan_window;
    int conn_intval = g_multirole_sla_perf_conn_intval;
    int sla_latency = g_multirole_sla_perf_sla_latency;
    int supervisionTO = g_multirole_sla_perf_supervision_to; 
     
    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(sla_adv->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, mas->dut_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(sla_adv->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    memcpy (g_pattern_param.adv_param.Direct_Address, mas->dut_addr, ADDR_LENGTH);//should be peer addr!!!
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(sla_adv->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(mas->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, sla_adv->dut_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (conn_intval & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (conn_intval & 0xff00) >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]		    =   sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=   supervisionTO & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(mas->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(mas->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(sla_adv->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    sleep(1);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv->dut_fd, g_pattern_param);

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(sla_adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(sla_adv->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(sla_adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address , sla_adv->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(sla_adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN){
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();    
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;    
    }

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){
        
        MSLEEP(100);
    }

    CHECK_NON_DISCONNECT();

    COMM_Dut_check_adv_rpt_num(scn->dut_fd, &adv_adv_cnt, &adv_scn_rsp_cnt);

    int ideal_val = ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval);
    if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN && adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        // the ideal value : ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval)
        if (((float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            line=__LINE__;
    	    goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
        }
    }
    else {
        if (((float)((adv_adv_cnt * 100) / ideal_val)) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            line=__LINE__;
    	    goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
        } 
    }      
 
    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
    COMM_Disconnect_Config(sla_adv->dut_fd, &g_pattern_param, buf);
    verdict = COMM_Disconnect(sla_adv->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;        

FUN_FAIL:    

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

verdict Perf_Sla_Scn(dut_setting *sla_scn, dut_setting *mas, dut_setting *adv, int scn_type, int adv_type){

    int dut1_fd = mas->dut_fd;
    int dut2_fd = sla_scn->dut_fd;
    int verdict = FAIL;
    u16 line = 0;
   
    struct itimerval timer;
    
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];

    int adv_Channel = 37;
    u32 scn_adv_cnt = 0;
    u32 scn_scn_rsp_cnt = 0;

    COMM_Dut_clean_buffer(sla_scn->dut_fd);
    COMM_Dut_clean_buffer(mas->dut_fd);
    COMM_Dut_clean_buffer(adv->dut_fd);

    MULTIROLE_SLA_PERF_PATTERN_CONFIG_READ();

    int test_time   = g_multirole_sla_perf_test_time;
    int adv_intval = g_multirole_sla_perf_adv_intval;
    int scn_intval = g_multirole_sla_perf_scan_intval;
    int scn_window = g_multirole_sla_perf_scan_window;
    int conn_intval = g_multirole_sla_perf_conn_intval;
    int sla_latency = g_multirole_sla_perf_sla_latency;
    int supervisionTO = g_multirole_sla_perf_supervision_to;
     
    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(sla_scn->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, mas->dut_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(sla_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    memcpy (g_pattern_param.adv_param.Direct_Address, mas->dut_addr, ADDR_LENGTH);//should be peer addr!!!
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(sla_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(mas->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, sla_scn->dut_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (conn_intval & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (conn_intval & 0xff00) >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]		    =   sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=   supervisionTO & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(mas->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(mas->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(sla_scn->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    sleep(1);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, adv->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(adv->dut_fd, g_pattern_param);

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(adv->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(sla_scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(sla_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN){
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(sla_scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(sla_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();    
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;    
    }

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);


    while (read_le_event_get()){
        
        MSLEEP(100);
    }

    CHECK_NON_DISCONNECT();

    COMM_Dut_check_adv_rpt_num(sla_scn->dut_fd, &scn_adv_cnt, &scn_scn_rsp_cnt);

    int ideal_val = ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval);
    if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN && adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        // the ideal value : ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval)
        if (((float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            line=__LINE__;
    	    goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
        }
    }
    else {
        if (((float)((scn_adv_cnt * 100) / ideal_val)) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
            line=__LINE__;
    	    goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
        } 
    }       
 
    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
    COMM_Disconnect_Config(sla_scn->dut_fd, &g_pattern_param, buf);
    verdict = COMM_Disconnect(sla_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;        

FUN_FAIL:    

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);
    return FAIL;

}

verdict Perf_Sla_Adv_Scn(dut_setting *sla_adv_scn, dut_setting *mas, dut_setting *scn, dut_setting *adv, int adv_type, int scn_type){

    int dut1_fd = mas->dut_fd;
    int dut2_fd = sla_adv_scn->dut_fd;
    int verdict = FAIL;
    u16 line = 0;
   
    struct itimerval timer;
    
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];

    int adv_Channel = 37;
    u32 adv_adv_cnt = 0;
    u32 scn_adv_cnt = 0;
    u32 adv_scn_rsp_cnt = 0;
    u32 scn_scn_rsp_cnt = 0;

    COMM_Dut_clean_buffer(sla_adv_scn->dut_fd);
    COMM_Dut_clean_buffer(mas->dut_fd);
    COMM_Dut_clean_buffer(scn->dut_fd);
    COMM_Dut_clean_buffer(adv->dut_fd);

    MULTIROLE_SLA_PERF_PATTERN_CONFIG_READ();

    int test_time   = g_multirole_sla_perf_test_time;
    int adv_intval = g_multirole_sla_perf_adv_intval;
    int scn_intval = g_multirole_sla_perf_scan_intval;
    int scn_window = g_multirole_sla_perf_scan_window;
    int conn_intval = g_multirole_sla_perf_conn_intval;
    int sla_latency = g_multirole_sla_perf_sla_latency;
    int supervisionTO = g_multirole_sla_perf_supervision_to;

    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(sla_adv_scn->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, mas->dut_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    memcpy (g_pattern_param.adv_param.Direct_Address, mas->dut_addr, ADDR_LENGTH);//should be peer addr!!!
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(mas->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, sla_adv_scn->dut_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (conn_intval & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (conn_intval & 0xff00) >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]		    =   sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=   supervisionTO & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(mas->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(mas->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(sla_adv_scn->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    sleep(1);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv_scn->dut_fd, g_pattern_param);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, adv->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv_scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(adv->dut_fd, g_pattern_param);

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) {   
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv_scn->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(sla_adv_scn->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv_scn->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) { 
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(adv->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(sla_adv_scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(sla_adv_scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){
        
        MSLEEP(100);
    }

    CHECK_NON_DISCONNECT();

    COMM_Dut_check_adv_rpt_num(scn->dut_fd, &adv_adv_cnt, &adv_scn_rsp_cnt);

    COMM_Dut_check_adv_rpt_num(sla_adv_scn->dut_fd, &scn_adv_cnt, &scn_scn_rsp_cnt);

    int ideal_val = ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval);
    if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN && adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        // the ideal value : ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval)
        if (((float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90 || ((float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            line=__LINE__;
            goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
        }
    }
    else {
        if (((float)((adv_adv_cnt * 100) / ideal_val)) <= 90 || ((float)((scn_adv_cnt * 100) / ideal_val)) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
            line=__LINE__;
            goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
        } 
    }
 
    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
    COMM_Disconnect_Config(sla_adv_scn->dut_fd, &g_pattern_param, buf);
    verdict = COMM_Disconnect(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;        

FUN_FAIL:    

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__, line);
    return FAIL;

}

verdict Perf_Sla_Adv_Scn_trx(dut_setting *sla_adv_scn, dut_setting *mas, dut_setting *scn, dut_setting *adv, int adv_type, int scn_type){

    int dut1_fd = mas->dut_fd;
    int dut2_fd = sla_adv_scn->dut_fd;
    int verdict = FAIL;
    u16 line = 0;
   
    struct itimerval timer;
    
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];
    u8 conn_handles_mas[2];

    int adv_Channel = 37;
    u32 adv_adv_cnt = 0;
    u32 scn_adv_cnt = 0;
    u32 adv_scn_rsp_cnt = 0;
    u32 scn_scn_rsp_cnt = 0;

    pid_t pid = -1; 
    u8 acl_le_pkts_sla;
    u8 acl_le_pkts_mas;   

    u8 acl_data_len_random = 0 ;

    int acl_init_cnt = 0 ;
    u32 acl_data_cnt_sla = 0;
    u32 acl_data_cnt_mas = 0;
    u8 acl_data[ACL_DATA_MAX] = {0};
    int acl_data_len    = ACL_DATA_MAX;

    COMM_Dut_clean_buffer(sla_adv_scn->dut_fd);
    COMM_Dut_clean_buffer(mas->dut_fd);
    COMM_Dut_clean_buffer(scn->dut_fd);
    COMM_Dut_clean_buffer(adv->dut_fd);

    MULTIROLE_SLA_PERF_PATTERN_CONFIG_READ();

    int test_time   = g_multirole_sla_perf_test_time;
    int adv_intval = g_multirole_sla_perf_adv_intval;
    int scn_intval = g_multirole_sla_perf_scan_intval;
    int scn_window = g_multirole_sla_perf_scan_window;
    int conn_intval = g_multirole_sla_perf_conn_intval;
    int sla_latency = g_multirole_sla_perf_sla_latency;
    int supervisionTO = g_multirole_sla_perf_supervision_to;
     
    Calculate_Execution_Time_Start();

    verdict=COMM_Read_LE_Buffer_Size(sla_adv_scn->dut_fd, &g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_sla = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;

    verdict=COMM_Read_LE_Buffer_Size(mas->dut_fd, &g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    acl_le_pkts_mas = g_pattern_param.buff_size_param.HCI_Total_Num_LE_ACL_Data_Packets;
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(sla_adv_scn->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, mas->dut_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    memcpy (g_pattern_param.adv_param.Direct_Address, mas->dut_addr, ADDR_LENGTH);//should be peer addr!!!
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(mas->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, sla_adv_scn->dut_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (conn_intval & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (conn_intval & 0xff00) >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]		    =   sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=   supervisionTO & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(mas->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(mas->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1]; 

    if (SUCCESS != QUERY_LE_Event(sla_adv_scn->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    sleep(1);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv_scn->dut_fd, g_pattern_param);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, adv->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv_scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(adv->dut_fd, g_pattern_param);

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) {   
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv_scn->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(sla_adv_scn->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv_scn->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) { 
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(adv->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(sla_adv_scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(sla_adv_scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    CHECK_NON_DISCONNECT();

    pid = fork();
            
    if (pid < 0){
        line = __LINE__;
        goto FUN_FAIL;
    }

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);    
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){
        if(pid == 0) {
            if(acl_le_pkts_mas > 0){
                if (acl_data_len == 0){

                    acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                    for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                        acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                    }
                }
                else{

                    acl_data_len_random = acl_data_len;

                    for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                        acl_data[acl_init_cnt] = acl_data_cnt_mas;
                    }
                }

                COMM_Send_ACL_Data_Without_event(mas->dut_fd, conn_handles_mas, 0b00, 0, acl_data_len_random, acl_data);
                acl_le_pkts_mas --;
                acl_data_cnt_mas ++;
            }

            if(SUCCESS != QUERY_Event(mas->dut_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {
                acl_le_pkts_mas += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS];
            }

            if((acl_data_cnt_mas % 200) == 0) {
                if(SUCCESS != QUERY_Event(mas->dut_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                } 
                if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }   
            }
        }

        if(pid != 0) {
            //# detect child exit
			int status ;
            if( 0 != waitpid( pid, &status ,WNOHANG)){
                printf("get child exit \n");                        
                break;
            }

            if(acl_le_pkts_sla > 0){
                if (acl_data_len == 0){

                    acl_data_len_random = (rand() % ACL_DATA_MAX) + 1;

                    for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                        acl_data[acl_init_cnt] = (rand() % 0xff) + 1;
                    }
                }
                else{

                    acl_data_len_random = acl_data_len;

                    // # init acl data with 1
                    for ( acl_init_cnt = 0 ; acl_init_cnt < ACL_DATA_MAX ; acl_init_cnt ++){
                        acl_data[acl_init_cnt] = acl_data_cnt_sla;
                    }
                }

                COMM_Send_ACL_Data_Without_event(sla_adv_scn->dut_fd, conn_handles_sla, 0b00, 0, acl_data_len_random, acl_data);
                acl_le_pkts_sla -- ;
                acl_data_cnt_sla ++;
            }

            if(SUCCESS != QUERY_Event(sla_adv_scn->dut_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }
            else if(0 != hci_event_num_of_completed_packets_parsing(buf)) {

                acl_le_pkts_sla += (buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS + 1] << 8) +
		                            buf[_BT_HCI_IDX_EVENT_NUM_OF_PACKETS];                    
            } 

            if((acl_data_cnt_sla % 200) == 0) {
                if(SUCCESS != QUERY_Event(sla_adv_scn->dut_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                } 
                if( 0 != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }   
            }
        }
        MSLEEP(1);
    }

    switch (pid){
        case -1 :
            break;
        case  0 :
            printf("child exit\n");        
            fflush(stdout);
            _exit(0);                          
            break;
        default :
            terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }


    CHECK_NON_DISCONNECT();

    COMM_Dut_check_adv_rpt_num(scn->dut_fd, &adv_adv_cnt, &adv_scn_rsp_cnt);

    COMM_Dut_check_adv_rpt_num(sla_adv_scn->dut_fd, &scn_adv_cnt, &scn_scn_rsp_cnt);

    int ideal_val = ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval);
    if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN && adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        // the ideal value : ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval)
        if (((float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90 || ((float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            line=__LINE__;
            goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
        }
    }
    else {
        if (((float)((adv_adv_cnt * 100) / ideal_val)) <= 90 || ((float)((scn_adv_cnt * 100) / ideal_val)) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
            line=__LINE__;
            goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
        } 
    }
 
    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
    COMM_Disconnect_Config(sla_adv_scn->dut_fd, &g_pattern_param, buf);
    verdict = COMM_Disconnect(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;        

FUN_FAIL:    

    switch (pid){
        case -1 :
            break;
        case  0 :
            printf("child exit\n");        
            fflush(stdout);
            _exit(0);                          
            break;
        default :
            terminate_process(pid);    
            printf("waiting child exit\n");
            fflush(stdout);
            wait(NULL);
            break;
    }

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__, line);
    return FAIL;

}

verdict Perf_Sla_Adv_Scn_iv_update(dut_setting *sla_adv_scn, dut_setting *mas, dut_setting *scn, dut_setting *adv, int adv_type, int scn_type){

    int dut1_fd = mas->dut_fd;
    int dut2_fd = sla_adv_scn->dut_fd;
    int verdict = FAIL;
    u16 line = 0;
   
    struct itimerval timer;
    
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];
    u8 conn_handles_mas[2];

    int adv_Channel = 37;
    u32 adv_adv_cnt = 0;
    u32 scn_adv_cnt = 0;
    u32 adv_scn_rsp_cnt = 0;
    u32 scn_scn_rsp_cnt = 0;

    COMM_Dut_clean_buffer(sla_adv_scn->dut_fd);
    COMM_Dut_clean_buffer(mas->dut_fd);
    COMM_Dut_clean_buffer(scn->dut_fd);
    COMM_Dut_clean_buffer(adv->dut_fd);

    MULTIROLE_SLA_PERF_PATTERN_CONFIG_READ();

    int test_time   = g_multirole_sla_perf_test_time;
    int adv_intval = g_multirole_sla_perf_adv_intval;
    int scn_intval = g_multirole_sla_perf_scan_intval;
    int scn_window = g_multirole_sla_perf_scan_window;
    int conn_intval = g_multirole_sla_perf_conn_intval;
    int sla_latency = g_multirole_sla_perf_sla_latency;
    int supervisionTO = g_multirole_sla_perf_supervision_to;
    int conn_event = g_multirole_sla_perf_conn_event_change;
     
    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(sla_adv_scn->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, mas->dut_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    memcpy (g_pattern_param.adv_param.Direct_Address, mas->dut_addr, ADDR_LENGTH);//should be peer addr!!!
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(mas->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, sla_adv_scn->dut_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (conn_intval & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (conn_intval & 0xff00) >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]		    =   sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=   supervisionTO & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(mas->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(mas->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    if (SUCCESS != QUERY_LE_Event(sla_adv_scn->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    sleep(1);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv_scn->dut_fd, g_pattern_param);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, adv->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv_scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(adv->dut_fd, g_pattern_param);

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) {   
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv_scn->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(sla_adv_scn->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv_scn->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) { 
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(adv->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(sla_adv_scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(sla_adv_scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){

        CHECK_NON_DISCONNECT();
        
        // # should use master's conn handle
        COMM_Conn_Update_Set_Config(mas->dut_fd , &g_pattern_param , conn_handles_mas);
        conn_intval = (conn_intval % 2) ? (conn_intval - 1) : (conn_intval + 1);
        g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = conn_intval & 0x00ff;
        g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(conn_intval & 0xff00)  >> 8;
        g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = conn_intval & 0x00ff;
        g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(conn_intval & 0xff00)  >> 8;           
        g_pattern_param.conn_update_param.Conn_Latency[0]            = sla_latency & 0x00ff;
        g_pattern_param.conn_update_param.Conn_Latency[1]            =(sla_latency & 0xff00)  >> 8;
        //The Supervision_Timeout in milliseconds shall be larger than the Conn_Interval_Max in milliseconds.
        //superviision TO > (1+connSlaveLatency)*Conninterval
        g_pattern_param.conn_update_param.Supervision_Timeout[0]     = supervisionTO & 0x00ff; //=0xD0;
        g_pattern_param.conn_update_param.Supervision_Timeout[1]     =(supervisionTO & 0xff00)>> 8 ; //=0x07;
        verdict = COMM_Conn_Update_Set(mas->dut_fd , g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        MSLEEP(conn_event * 1.25 * conn_intval);

REPEAT1 :             
        CHECK_NON_DISCONNECT();
        
        if(SUCCESS != QUERY_LE_Event(mas->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
            MSLEEP(conn_event * 1.25 * conn_intval);
            goto REPEAT1;
        }
        else if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
            MSLEEP(conn_event * 1.25 * conn_intval);
            goto REPEAT1;
        }     

REPEAT2 :  
        CHECK_NON_DISCONNECT();
        if(SUCCESS != QUERY_LE_Event(sla_adv_scn->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_UPDATE_COMPLETE_, 0)) {
            MSLEEP(conn_event * 1.25 * conn_intval);
            goto REPEAT2;
        }
        else if(SUCCESS != hci_le_event_connection_update_complete_parsing(0, buf, g_pattern_param)) {
            MSLEEP(conn_event * 1.25 * conn_intval);
            goto REPEAT2;
        } 
    }

    CHECK_NON_DISCONNECT();

    COMM_Dut_check_adv_rpt_num(scn->dut_fd, &adv_adv_cnt, &adv_scn_rsp_cnt);

    COMM_Dut_check_adv_rpt_num(sla_adv_scn->dut_fd, &scn_adv_cnt, &scn_scn_rsp_cnt);       

    int ideal_val = ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval);
    if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN && adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        // the ideal value : ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval)
        if (((float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90 || ((float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            line=__LINE__;
            goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
        }
    }
    else {
        if (((float)((adv_adv_cnt * 100) / ideal_val)) <= 90 || ((float)((scn_adv_cnt * 100) / ideal_val)) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
            line=__LINE__;
            goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
        } 
    }
 
    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
    COMM_Disconnect_Config(sla_adv_scn->dut_fd, &g_pattern_param, buf);
    verdict = COMM_Disconnect(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;        

FUN_FAIL:    

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__, line);
    return FAIL;

}

verdict Perf_Sla_Adv_Scn_ch_update(dut_setting *sla_adv_scn, dut_setting *mas, dut_setting *scn, dut_setting *adv, int adv_type, int scn_type){

    int dut1_fd = mas->dut_fd;
    int dut2_fd = sla_adv_scn->dut_fd;
    int verdict = FAIL;
    u16 line = 0;
   
    struct itimerval timer;
    
    u8 buf[SOCKET_BUF_SIZE];
    u8 conn_handles_sla[2];

    int adv_Channel = 37;
    u32 adv_adv_cnt = 0;
    u32 scn_adv_cnt = 0;
    u32 adv_scn_rsp_cnt = 0;
    u32 scn_scn_rsp_cnt = 0;
  
    u64 ch_map = CH_MAP_ODD;

    COMM_Dut_clean_buffer(sla_adv_scn->dut_fd);
    COMM_Dut_clean_buffer(mas->dut_fd);
    COMM_Dut_clean_buffer(scn->dut_fd);
    COMM_Dut_clean_buffer(adv->dut_fd);

    MULTIROLE_SLA_PERF_PATTERN_CONFIG_READ();

    int test_time   = g_multirole_sla_perf_test_time;
    int adv_intval = g_multirole_sla_perf_adv_intval;
    int scn_intval = g_multirole_sla_perf_scan_intval;
    int scn_window = g_multirole_sla_perf_scan_window;
    int conn_intval = g_multirole_sla_perf_conn_intval;
    int sla_latency = g_multirole_sla_perf_sla_latency;
    int supervisionTO = g_multirole_sla_perf_supervision_to;
    int conn_event = g_multirole_sla_perf_conn_event_change;
 
    Calculate_Execution_Time_Start();
        
    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(sla_adv_scn->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, mas->dut_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
    memcpy (g_pattern_param.adv_param.Direct_Address, mas->dut_addr, ADDR_LENGTH);//should be peer addr!!!
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
    verdict = COMM_ADV_Directed_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(mas->dut_fd, &g_pattern_param);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, sla_adv_scn->dut_addr, ADDR_LENGTH );
    g_pattern_param.create_conn_param.Conn_Interval_Min[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Min[1] = (conn_intval & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Conn_Interval_Max[0] = conn_intval & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Interval_Max[1] = (conn_intval & 0xff00) >> 8;
    g_pattern_param.create_conn_param.Conn_Latency[0]		    =   sla_latency & 0x00ff;
	g_pattern_param.create_conn_param.Conn_Latency[1]		    =   (sla_latency & 0xff00) >> 8;
	g_pattern_param.create_conn_param.Supervision_Timeout[0] 	=   supervisionTO & 0x00ff;
	g_pattern_param.create_conn_param.Supervision_Timeout[1] 	=   (supervisionTO & 0xff00) >> 8;
    verdict = COMM_INI_Initiating(mas->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    sleep(1);

    if(SUCCESS != QUERY_LE_Event(mas->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if (SUCCESS != QUERY_LE_Event(sla_adv_scn->dut_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
        line = __LINE__;
        goto FUN_FAIL;
    }
    if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
        line = __LINE__;
        goto FUN_FAIL;
    }

    conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
    conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

    sleep(1);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv_scn->dut_fd, g_pattern_param);

    // # config white list @ scanner
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, adv->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(sla_adv_scn->dut_fd, g_pattern_param);

    // # config white list @ advertiser
    COMM_Add_Device_To_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, sla_adv_scn->dut_addr, &g_pattern_param);
    COMM_Add_Device_To_White_List(adv->dut_fd, g_pattern_param);

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) {   
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv_scn->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(sla_adv_scn->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, sla_adv_scn->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(adv_type == HCI_CMD_PARAM_ADV_NONCONN_IND) { 
        printf("\nHCI_CMD_PARAM_ADV_NONCONN_IND\n");
        COMM_ADV_NonConnectable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr , ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_NonConnectable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        printf("\nHCI_CMD_PARAM_ADV_SCAN_IND\n");
        COMM_Scan_Response_Data_Set_Config(adv->dut_fd, HCI_CMD_PARAM_SCAN_RSP_DATA_LEN_MAX, &g_pattern_param);
        verdict = COMM_Scan_Response_Data_Set(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX, &g_pattern_param);
        memcpy (g_pattern_param.adv_param.Direct_Address, adv->dut_addr, ADDR_LENGTH);
        g_pattern_param.adv_param.Advertising_Interval_Max[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Max[1] = (adv_intval & 0xff00) >> 8;
        g_pattern_param.adv_param.Advertising_Interval_Min[0] =  adv_intval & 0x00ff;
        g_pattern_param.adv_param.Advertising_Interval_Min[1] = (adv_intval & 0xff00) >> 8;
        set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
        verdict = COMM_ADV_Discoverable_Advertising(adv->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    if(scn_type == HCI_CMD_PARAM_PASSIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_PASSIVE_SCAN\n");
        COMM_SCN_Passive_Scanning_Config(sla_adv_scn->dut_fd, &g_pattern_param);   
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Passive_Scanning(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN) {
        printf("\nHCI_CMD_PARAM_ACTIVE_SCAN\n");
        COMM_SCN_Active_Scanning_Config(sla_adv_scn->dut_fd, &g_pattern_param);
        set_scan_interval(scn_intval * 0.625);
        set_scan_windows(scn_window * 0.625);
        set_scan_policy(HCI_CMD_PARAM_IGNORE_ADV_PKTS_FROM_DEV_NOT_IN_WHITE_LIST_ONLY);
        verdict = COMM_SCN_Active_Scanning(sla_adv_scn->dut_fd, g_pattern_param);
        VERDICT_RESULT_WITH_LINE();
    }
    else {
        line = __LINE__;
        goto FUN_FAIL;
    }

    read_le_event_enable();

    event_query_timer_config(test_time, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_disable);

    while (read_le_event_get()){

        CHECK_NON_DISCONNECT();

        ch_map = (ch_map == CH_MAP_ODD) ? CH_MAP_EVEN : CH_MAP_ODD;

        COMM_Ch_Map_Set_Config(mas->dut_fd , &g_pattern_param , ch_map);
        verdict = COMM_Ch_Map_Set(mas->dut_fd , g_pattern_param);
        VERDICT_RESULT_WITH_LINE();

        MSLEEP(conn_event * 1.25 * conn_intval);
    }

    CHECK_NON_DISCONNECT();

    COMM_Dut_check_adv_rpt_num(scn->dut_fd, &adv_adv_cnt, &adv_scn_rsp_cnt);

    COMM_Dut_check_adv_rpt_num(sla_adv_scn->dut_fd, &scn_adv_cnt, &scn_scn_rsp_cnt);   

    int ideal_val = ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval);
    if(scn_type == HCI_CMD_PARAM_ACTIVE_SCAN && adv_type == HCI_CMD_PARAM_ADV_SCAN_IND) {
        // the ideal value : ((test_time * 1000) / ((adv_intval * 0.625) + 5)) * (scn_window / scn_intval)
        if (((float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90 || ((float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2))) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            line=__LINE__;
            goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, adv_adv_cnt + adv_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((adv_adv_cnt + adv_scn_rsp_cnt) * 100) / (ideal_val * 2)));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, (ideal_val * 2));
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : scn_rsp_cnt %d\n", __FUNCTION__, scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Exp   value : total_cnt %d\n", __FUNCTION__, scn_adv_cnt + scn_scn_rsp_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)(((scn_adv_cnt + scn_scn_rsp_cnt) * 100) / (ideal_val * 2)));
        }
    }
    else {
        if (((float)((adv_adv_cnt * 100) / ideal_val)) <= 90 || ((float)((scn_adv_cnt * 100) / ideal_val)) <= 90) {
            LOG_INFO("[Pattern][%s]FAIL\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
            line=__LINE__;
            goto FUN_FAIL;
        }
        else {
            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Sla_adv:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, adv_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_adv_cnt * 100) / ideal_val));
            LOG_INFO("[Pattern][%s]Sla_scn:\n", __FUNCTION__);
            LOG_INFO("[Pattern][%s]Ideal value : %d\n", __FUNCTION__, ideal_val);
            LOG_INFO("[Pattern][%s]Exp   value : adv_cnt %d\n", __FUNCTION__, scn_adv_cnt);
            LOG_INFO("[Pattern][%s]Ratio value : %.2f %%\n", __FUNCTION__, (float)((scn_adv_cnt * 100) / ideal_val));
        } 
    }
          
    memset(buf, 0, SOCKET_BUF_SIZE);
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0] = conn_handles_sla[0];
    buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1] = conn_handles_sla[1];
    
    COMM_Disconnect_Config(sla_adv_scn->dut_fd, &g_pattern_param, buf);
    verdict = COMM_Disconnect(sla_adv_scn->dut_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
    return PASS;        

FUN_FAIL:    

    MULTIROLE_FUNC_END();

    LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__, line);
    return FAIL;

}

verdict CFI_446(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_sla[2];
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(0, &g_pattern_param);
    set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }

   
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);    
    set_conn_interval(4000);
    set_conn_slave_latency(HCI_CMD_PARAM_MAX_SLAVE_LATENCY_WITH_MAX_CONN_INT_AND_TO);
    set_conn_super_timeout(4000);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );

    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(5, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,  _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];
        
            dut_reset_with_mask_en(dut1_fd);

            sleep(10);

            // # Slave Connection Terminated
            // use connect handle to disconnect
            buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_sla[0];
            buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_sla[1];
            
            COMM_Disconnect_Config(dut2,&g_pattern_param,buf);
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_REMOTE_USER_TERMINATED_CONNECTION;
            verdict=COMM_Disconnect(dut2_fd,g_pattern_param);

            //# query dut2

            sleep(60);

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_LMP_LL_Response_Timeout != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }
                        
            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d  FAIL!!\n", __FUNCTION__, line);
    return FAIL;

}

verdict CFI_451_1(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_mas[2];    
    u8 conn_handles_sla[2];
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(0, &g_pattern_param);
    set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
   
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);    
    set_conn_interval(4000);
    set_conn_slave_latency(HCI_CMD_PARAM_MAX_SLAVE_LATENCY_WITH_MAX_CONN_INT_AND_TO);
    set_conn_super_timeout(4000);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );

    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,  _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_mas[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_mas[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];
        
            buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_sla[0];
            buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_sla[1];

            COMM_Conn_Update_Set_Config(0 , &g_pattern_param , conn_handles_mas);
            g_pattern_param.conn_update_param.Conn_Interval_Min[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Min[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;
            g_pattern_param.conn_update_param.Conn_Interval_Max[0]       = HCI_CMD_PARAM_CONN_INT_MIN & 0x00ff;
            g_pattern_param.conn_update_param.Conn_Interval_Max[1]       =(HCI_CMD_PARAM_CONN_INT_MIN & 0xff00)  >> 8;           
            verdict = COMM_Conn_Update_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            sleep(7);
            COMM_Disconnect_Config(0,&g_pattern_param,buf);
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_REMOTE_USER_TERMINATED_CONNECTION;
            verdict=COMM_Disconnect(dut2_fd,g_pattern_param);

            //# query dut2

            sleep(30);

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            sleep(40);

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_REMOTE_USER_TERMINATED_CONNECTION != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

                        
            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d  FAIL!!\n", __FUNCTION__, line);
    return FAIL;

}

verdict CFI_451_2(u8 dut1_fd ,u8 dut2_fd)
{
    u8 buf[SOCKET_BUF_SIZE];
    int verdict = FAIL;
    int dut1 = 0;
    int dut2 = 0;
    u16 line = 0;
    struct itimerval timer;
    u8 conn_handles_sla[2];
    int adv_Channel = 37;

    COMM_Dut_clean_buffer(dut1_fd);
    COMM_Dut_clean_buffer(dut2_fd);

    Calculate_Execution_Time_Start();

    // Uptest(white list) config
    COMM_INI_Connection_Setup_White_Listed_Config(dut2, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, scan_addr, ADDR_LENGTH);
    g_pattern_param.white_list_param.Address_Type[0] = HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS;
    verdict = COMM_INI_Connection_Setup_White_Listed(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_ADV_Directed_Advertising_Config(0, &g_pattern_param);
    set_adv_policy(HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY);
    g_pattern_param.adv_param.Advertising_Filter_Policy[0] = HCI_CMD_PARAM_ALLOW_SCAN_REQ_FROM_WHITELIST_ONLY_AND_CONN_REQ_FROM_WHITELIST_ONLY;
    if(37 == adv_Channel) {
        g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_37;
    }
   
    verdict = COMM_ADV_Directed_Advertising(dut2_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    COMM_INI_Initiating_Config(dut1, &g_pattern_param);    
    set_conn_interval(4000);
    set_conn_slave_latency(HCI_CMD_PARAM_MAX_SLAVE_LATENCY_WITH_MAX_CONN_INT_AND_TO);
    set_conn_super_timeout(4000);
    memcpy(g_pattern_param.create_conn_param.Peer_Address, adv_addr, ADDR_LENGTH );

    verdict = COMM_INI_Initiating(dut1_fd, g_pattern_param);
    VERDICT_RESULT_WITH_LINE();

    event_query_timer_config(1, 0, 0, 0, &timer);
    event_query_timer_start(timer, read_le_event_enable);

    //waiting adv report event , timer or counter
    while(1) {
        if(1 == read_le_event_get()) {
            read_le_event_disable();

            if(SUCCESS != QUERY_LE_Event(dut1_fd, buf,  _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != QUERY_LE_Event(dut2_fd, buf, _BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_, 0)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_le_event_connection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            conn_handles_sla[0] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+0];
            conn_handles_sla[1] = buf[_BT_HCI_EVT_CON_COMP_CONN_HANDLE+1];
        
            buf[_BT_HCI_EVT_COMP_HANDLE+0] = conn_handles_sla[0];
            buf[_BT_HCI_EVT_COMP_HANDLE+1] = conn_handles_sla[1];

            COMM_Ch_Map_Set_Config(0 , &g_pattern_param , CH_MAP_ODD );
            verdict = COMM_Ch_Map_Set(dut1_fd , g_pattern_param);
            VERDICT_RESULT_WITH_LINE();

            sleep(7);
            COMM_Disconnect_Config(0,&g_pattern_param,buf);
            g_pattern_param.disconn_param.Reason[0]= HCI_CMD_PARAM_REMOTE_USER_TERMINATED_CONNECTION;
            verdict=COMM_Disconnect(dut2_fd,g_pattern_param);

            //# query dut2

            sleep(30);

            if(SUCCESS != QUERY_Event(dut2_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_CONNECTION_TERMINATED_BY_LOCAL_HOST != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            sleep(40);

            if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_DISCONNECTION_COMPLETE_)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(SUCCESS != hci_event_disconnection_complete_parsing(0, buf, g_pattern_param)) {
                line = __LINE__;
                goto FUN_FAIL;
            }

            if(HCI_CMD_PARAM_REMOTE_USER_TERMINATED_CONNECTION != buf[_BT_HCI_EVT_DISCONN_COMP_REASON]) {
                line = __LINE__;
                goto FUN_FAIL;
            }

                        
            FUNC_END();

            LOG_INFO("[Pattern][%s]SUCCESS\n", __FUNCTION__);
            return PASS;
        }
    }

FUN_FAIL:
    FUNC_END();

    LOG_INFO("[Pattern][%s]:%d  FAIL!!\n", __FUNCTION__, line);
    return FAIL;

}


//######################################
void comm_init(u8 dut){

	s32 dut_fd=0;
	dut_fd=dut_socket_init(dut);

	COMM_Reset(dut_fd);
	COMM_Set_Event_Mask(dut_fd,&g_pattern_param);
	COMM_Le_Set_Event_Mask(dut_fd,&g_pattern_param);
}

//######################################

static void Cmd_Exit(s32 argc, s8 *argv[]) {
	exit(0);
}

static void Cmd_Echo(s32 argc, s8 *argv[]) {
	u32 loop_i;

	for(loop_i=0; loop_i< argc; loop_i++) {
		printf("# argv %2d is %s\n", loop_i, argv[loop_i]);
	}
}

static void Cmd_TI_DTM(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 5)
	{
		printf("{dut1}.{dut2}.{rfch}.{pkt_cnt}\n");
		return;
	}
	printf("run DTM Rx(dut%d) and Tx(dut%d)\n" ,atoi(argv[1]),atoi(argv[2]));
	TI_DTM( atoi(argv[1]) , atoi(argv[2]) , atoi(argv[3]) , atoi(argv[4]));
}


static void Cmd_TI_Auto_DTM(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 4)
	{
		printf("{dut1}.{dut2}.{pkt_cnt}\n");
		return;
	}
	printf("run Auto Rx(dut%d) and Tx(dut%d)\n" ,atoi(argv[1]),atoi(argv[2]));
	TI_Auto_DTM( atoi(argv[1]),atoi(argv[2]), atoi(argv[3]));
}


static void Cmd_TI_Dtm_Tx(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 6)
	{
		printf("{dut ,ch ,pkt_cnt ,pkt_len ,pld_type}\n");
		return;
	}
	printf("run Auto Tx(dut%d)\n" ,atoi(argv[1]));
	TI_Dtm_Tx( atoi(argv[1]),atoi(argv[2]) ,atoi(argv[3]) ,atoi(argv[4]),atoi(argv[5]));
}

static void Cmd_TI_Dtm_Tx_Cont(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 6)
	{
		printf("{dut ,ch ,0 ,pkt_len ,pld_type}\n");
		return;
	}
	printf("run Auto Tx(dut%d)\n" ,atoi(argv[1]));
	TI_Dtm_Tx_Continue( atoi(argv[1]),atoi(argv[2]) ,0 ,atoi(argv[4]),atoi(argv[5]));
}

static void Cmd_TI_Dtm_Tx_Cont_End(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 6)
	{
		printf("{dut ,ch ,0 ,pkt_len ,pld_type}\n");
		return;
	}
	printf("run Auto Tx(dut%d)\n" ,atoi(argv[1]));
	TI_Dtm_Tx_Continue_End( atoi(argv[1]),atoi(argv[2]) ,0 ,atoi(argv[4]),atoi(argv[5]));
}

static void Cmd_TI_Dtm_Rx(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut , ch }\n");
		return;
	}
	printf("run Auto Rx(dut%d)\n" ,atoi(argv[1]));
	TI_Dtm_Rx( atoi(argv[1]),atoi(argv[2]) );

}

static void Cmd_COMM_Read_BD_Addr(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	COMM_Read_BD_Addr(dut1_fd,g_pattern_param);
}

static void Cmd_TI_Sleep_Mode_Configurations(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	TI_sleep_mode_configurations(dut1_fd);
}


static void Cmd_TI_Get_System_Status(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	TI_Get_System_Status(dut1_fd);
}

static void Cmd_TI_Update_Hci_Baudrate(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	TI_Update_Hci_Baudrate(dut1_fd);
}

static void Cmd_TI_Output_Power(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
    int power_lv;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
    power_lv=atoi(argv[2]);
	dut1_fd=dut_socket_init(dut1);

	TI_Output_power(dut1_fd , power_lv);
}

static void Cmd_TI_Cont_Tx_Mode(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 6)
	{
		printf("{dut, modulation, freq, test_pattern, pwr_level}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;
	u8 cmd_param[TI_CONT_TX_PARAM_NUM];

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	cmd_param[TI_CONT_TX_MOD] = atoi(argv[2]);
	cmd_param[TI_CONT_TX_TP] = atoi(argv[3]);
	cmd_param[TI_CONT_TX_FREQ] = atoi(argv[4]);
	cmd_param[TI_CONT_TX_PWR] = atoi(argv[5]);

	TI_Cont_Tx_Mode(dut1_fd, cmd_param);
}


static void Cmd_TI_Write_BD_Addr(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut, bd_addr}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;
	u64 bd_addr;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	bd_addr = strtoull(argv[2],0,0);

	TI_Write_BD_Addr(dut1_fd, &bd_addr);
}


static void Cmd_TI_Pkt_Tx_Rx(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 10)
	{
		printf("{dut, freq_mode, tx_ch, rx_ch, pkt_type, pkt_pattern, pkt_len, pwr_level, prbs9}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;
	u16 cmd_param[TI_PKT_TXRX_PARAM_NUM];

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	cmd_param[TI_PKT_TXRX_FREQ_MODE] = strtol(argv[2],0,0);
	cmd_param[TI_PKT_TXRX_TX_CH] = strtol(argv[3],0,0);
	cmd_param[TI_PKT_TXRX_RX_CH] = strtol(argv[4],0,0);
	cmd_param[TI_PKT_TXRX_PKT_TYPE] = strtol(argv[5],0,0);
	cmd_param[TI_PKT_TXRX_PKT_PATTERN] = strtol(argv[6],0,0);
	cmd_param[TI_PKT_TXRX_PKT_LEN] = strtol(argv[7],0,0);
	cmd_param[TI_PKT_TXRX_PWR_LEVEL] = strtol(argv[8],0,0);
	cmd_param[TI_PKT_TXRX_PRBS9] = strtol(argv[9],0,0);

	TI_Pkt_Tx_Rx(dut1_fd, cmd_param);
}


static void Cmd_TI_BER_Meter_Start(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 8)
	{
		printf("{dut, ch, bd_addr, pkt_type, pkt_len, num_of_pkt, prbs9}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;
	u16 cmd_param[TI_BER_METER_START_PARAM_NUM];
	u64 bd_addr;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	cmd_param[TI_BER_METER_START_FREQ] = strtol(argv[2],0,0);
	bd_addr = strtoull(argv[3],0,0);
	cmd_param[TI_BER_METER_START_PKT_TYPE] = strtol(argv[4],0,0);
	cmd_param[TI_BER_METER_START_PKT_LEN] = strtol(argv[5],0,0);
	cmd_param[TI_BER_METER_START_NUM_OF_PKT] = strtol(argv[6],0,0);
	cmd_param[TI_BER_METER_START_PRBS9] = strtol(argv[7],0,0);

	TI_BER_Meter_Start(dut1_fd, cmd_param, &bd_addr);
}


static void Cmd_TI_Read_BER_Meter_Result(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	TI_Read_BER_Meter_Result(dut1_fd);
}


static void Cmd_Update_Dut_Baudrate(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int uart_fd = atoi(argv[1]);
    ttyReconfig(uart_fd);
}



static void Cmd_COMM_Device_Address_Set(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_COMM_Device_Address_Set with dut(%d)\n" ,dut1);
#if 0//testing
	COMM_Random_Device_Address_Set_Config(dut1,&g_pattern_param);
	COMM_Random_Device_Address_Set(dut1_fd,&g_pattern_param);
#else
	COMM_Device_Address_Set_Config(dut1,&g_pattern_param);
	COMM_Device_Address_Set(dut1_fd,g_pattern_param);
#endif
}

static void Cmd_COMM_White_List_Add(s32 argc, s8 *argv[]) {
	// # parameters from argv
    if (argc != 3){
        printf("{dut}{add type(adv/scan)}\r\n");
        return;
    }
    
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

    int add_type;
    add_type=atoi(argv[2]);
    
    u8 whitelist_addr[ADDR_LENGTH];

    if(add_type == 1){
        memcpy( whitelist_addr ,adv_addr ,ADDR_LENGTH);
    }else{
        memcpy( whitelist_addr ,scan_addr ,ADDR_LENGTH);
    }

    printf("add white list %2x:%2x:%2x:%2x:%2x:%2x \n" , 
        whitelist_addr[0] , whitelist_addr[1] ,
        whitelist_addr[2] , whitelist_addr[3] , 
        whitelist_addr[4] , whitelist_addr[5]);

#if 1
    COMM_INI_Connection_Setup_White_Listed_Config(dut1, &g_pattern_param);
    memcpy(g_pattern_param.white_list_param.Address, whitelist_addr, ADDR_LENGTH);
    COMM_INI_Connection_Setup_White_Listed(dut1_fd, g_pattern_param);
#endif
}


static void Cmd_COMM_White_List_Remove(s32 argc, s8 *argv[]) {

    static int idx=0;

	// # parameters from argv
    if (argc != 3){
        printf("{dut}{remove type(adv/scan)}\r\n");
        return;
    }

	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

    int add_type;
    add_type=atoi(argv[2]);

    u8 whitelist_addr[ADDR_LENGTH];

    if(add_type == 1){
        memcpy( whitelist_addr ,adv_addr ,ADDR_LENGTH);
    }else{
        memcpy( whitelist_addr ,scan_addr ,ADDR_LENGTH);
    }

    whitelist_addr[5] += idx;
    idx = idx + 1;

    printf("add white list %2x:%2x:%2x:%2x:%2x:%2x \n" ,
        whitelist_addr[0] , whitelist_addr[1] ,
        whitelist_addr[2] , whitelist_addr[3] ,
        whitelist_addr[4] , whitelist_addr[5]);

    COMM_Remove_Device_From_White_List_Config(HCI_CMD_PARAM_PUBLIC_DEVICE_ADDRESS, whitelist_addr, &g_pattern_param);
    COMM_Remove_Device_From_White_List(dut1_fd,g_pattern_param);
}
static void Cmd_COMM_Read_LE_Buffer_Size(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd = 0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	COMM_Read_LE_Buffer_Size(dut1_fd , &g_pattern_param);
}


static void Cmd_COMM_Read_Local_features(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	COMM_Read_Local_features(dut1_fd , g_pattern_param);
}

static void Cmd_COMM_Read_Remote_features(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;
    u8 conn_handles_mas[2];

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

    conn_handles_mas[0]= 4;
    conn_handles_mas[1]= 0;

    COMM_Read_Remote_Supported_Features_Config(dut1_fd,&g_pattern_param, conn_handles_mas);
    COMM_Read_Remote_Supported_Features(dut1_fd, g_pattern_param);

}

static void Cmd_COMM_Read_Local_commands(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	COMM_Read_Local_commands(dut1_fd , g_pattern_param);
}
static void Cmd_COMM_LE_Read_Local_features(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	COMM_LE_Read_Local_features(dut1_fd , g_pattern_param);
}


static void Cmd_COMM_LE_Read_Local_supported_states(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	COMM_LE_Read_Local_supported_states(dut1_fd , g_pattern_param);
}


static void Cmd_COMM_Ch_Map_Set(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut}\n");
		return;
	}
	
	int dut1;
	s32 dut1_fd=0;
	u64 ch_map=0; 
	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	ch_map = atoi(argv[2]);

	printf("run Cmd_COMM_Ch_Map_Set with dut(%d) , map =%llx\n" ,dut1 , ch_map);

	COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , ch_map);
	COMM_Ch_Map_Set(dut1_fd , g_pattern_param);

}


static void Cmd_COMM_Conn_Upate_Set(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 4)
	{
		printf("{dut}\n");
		return;
	}
	
	int dut1;
	s32 dut1_fd=0;
	u8 conn_handle[2];

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	conn_handle[0]=atoi(argv[2]);
	conn_handle[1]=atoi(argv[3]);	 

	printf("run Cmd_COMM_Conn_upate_Set with dut(%d) %d %d \n" ,dut1 , conn_handle[0] , conn_handle[1]);

	COMM_Conn_Update_Set_Config(dut1 , &g_pattern_param , conn_handle);
	COMM_Conn_Update_Set(dut1_fd , g_pattern_param);

}


static void Cmd_COMM_Send_ACL_Data_Fragement(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	
	int dut1;
	s32 dut1_fd=0;
	//u8 conn_handle[2];

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	//conn_handle[0]=atoi(argv[2]);
	//conn_handle[1]=atoi(argv[3]);    

	//printf("run Cmd_COMM_Send_ACL_Data with dut(%d) %d %d \n" ,dut1 , conn_handle[0] , conn_handle[1]);
	printf("run Cmd_COMM_Send_ACL_Data_Fragement with dut(%d)\n" ,dut1);

	u8 buf[SOCKET_BUF_SIZE];
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 acl_data[32]={0};
	u32 test_cnt1=-1;

    int sla_pkt_chk = 0;

	event_query_timer_config(1 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			//######################################

#if 1 //case 4
			for( ; test_cnt1 > 0 ; test_cnt1 --)
			{
				//acl_data_gen_tbx(acl_data , ACL_DATA_MAX ,test_cnt1);
				static u32 acl_cnt = 0;
				acl_data[0] = ACL_DATA_MAX*2 - 4;
				acl_data[1] = 0;
				acl_data[2] = 4;
				acl_data[3] = 0;
				acl_data[4] = 0xde;
				acl_data[5] = 0xad;
				COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b00,0,ACL_DATA_MAX,acl_data);
PKT_CHK1:
    
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                    MSLEEP(100);

                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }            
                    
                    goto PKT_CHK1;
                } 

                sla_pkt_chk = 0;

				//acl_data_gen_tbx(acl_data , ACL_DATA_MAX ,test_cnt1);
				acl_data[0] = 1;
				acl_data[1] = 2;
				acl_data[2] = 3;
				acl_data[3] = 4;
				acl_data[4] = 0xde;
				acl_data[5] = 0xad; 			   
				COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b01,0,ACL_DATA_MAX,acl_data);
PKT_CHK2:
    
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                    MSLEEP(100);

                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }            
                    
                    goto PKT_CHK2;
                } 

                sla_pkt_chk = 0 ;

				sleep(1);
				acl_cnt ++ ;
				printf("send %d times\n" , acl_cnt);

				if (test_cnt1 == 100)
					test_cnt1 = -1;
			}
#endif

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return ;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);

}

#define CHANNEL_ID 0x41
static void Cmd_COMM_Send_ACL_Data_Echo(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	
	int dut1;
	s32 dut1_fd=0;
	//u8 conn_handle[2];

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	//conn_handle[0]=atoi(argv[2]);
	//conn_handle[1]=atoi(argv[3]);    

	//printf("run Cmd_COMM_Send_ACL_Data with dut(%d) %d %d \n" ,dut1 , conn_handle[0] , conn_handle[1]);
	printf("run Cmd_COMM_Send_ACL_Data_Echo with dut(%d)\n" ,dut1);

	u8 buf[SOCKET_BUF_SIZE];
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 acl_data[32]={0};

	u8 cid		 = 0 ;
	u8 pdu_len	 = 0 ;
	u8 l2cap_len = 0 ;

	u8 pld_data  = 0xff ;
	u8 old_data  = 0xff ;
	u8	pld_check_cnt = 0;

	static u8 pld_fill_val = 0x01;
	static u16 zero_data = 0;
	static u32 err_cnt = 0 ;
	static u32 ok_cnt  = 0 ;

    int sla_pkt_chk = 0;
        
	event_query_timer_config(1 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if (SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];

			COMM_Ch_Map_Set_Config(dut1 , &g_pattern_param , 0);
			COMM_Ch_Map_Set(dut1_fd , g_pattern_param);

			//######################################

			while(1){
START:				  
				if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))
				{
					line=__LINE__;
					goto FUN_FAIL;
				}

				pdu_len 	= buf[_BT_HCI_IDX_ACL_DATA_LENGTH_];
				l2cap_len	= buf[_BT_HCI_IDX_ACL_DATA_PAYLOAD_ + 0];
				cid 		= buf[_BT_HCI_IDX_ACL_DATA_PAYLOAD_ + 2];

				if(pdu_len == 0){					 
					sleep(1);
					zero_data ++ ;
					if(zero_data < 20){
						printf("get %d times zero data \n" , zero_data);
						goto START;
					}else{
						goto FUN_FAIL;
					}
				}

				zero_data = 0 ;    
				// # pdu_len != 0
				if((cid != CHANNEL_ID) || (l2cap_len != 23)){
					printf("cid = %d , l2cap_len = %d \n" , cid , l2cap_len );
					err_cnt ++ ;
				}
				else{
				// #rx payload check
					pld_data	= buf[_BT_HCI_IDX_ACL_DATA_PAYLOAD_ + 4];

					printf("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
					printf("rx pld data : old =%d , now =%d\n" , old_data , pld_data);

					// #first time
					if(old_data != 0xff){
						
						if(old_data != pld_data -1){
							printf("compare old and rx pld data failed\n");
							err_cnt ++ ;
						}
						
					}
					
					old_data = pld_data ;

					for ( ; pld_check_cnt < l2cap_len ; pld_check_cnt ++ ){
						if( buf[_BT_HCI_IDX_ACL_DATA_PAYLOAD_ + 4 + pld_check_cnt] != pld_data){
							printf("check rx pld data failed\n");
							err_cnt ++ ;
						}
					}
				}

				// #tx
				ok_cnt ++ ;
				printf("tx pld data : val =%d\n" , pld_fill_val);
				printf("SUCCESS = %d ; FAIL = %d \n" , ok_cnt , err_cnt);
				printf("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");

				acl_data_gen_tbx(acl_data , ACL_DATA_MAX , pld_fill_val);

				pld_fill_val ++ ;

				acl_data[0] = ACL_DATA_MAX - 4;
				acl_data[1] = 0;
				acl_data[2] = CHANNEL_ID;
				acl_data[3] = 0;
				COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b00,0,ACL_DATA_MAX,acl_data);
PKT_CHK:
    
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                    MSLEEP(100);
                    
                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }            
                    
                    goto PKT_CHK;
                } 

				
			}

/*
			if (0x02 != (buf [_BT_HCI_IDX_ACL_DATA_CONN_HANDLE_ + 1] & 0xF0 ) >> 4)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
*/


			return ;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);

}


static void Cmd_COMM_Send_ACL_Data(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	
	int dut1;
	s32 dut1_fd=0;
	//u8 conn_handle[2];

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	//conn_handle[0]=atoi(argv[2]);
	//conn_handle[1]=atoi(argv[3]);    

	//printf("run Cmd_COMM_Send_ACL_Data with dut(%d) %d %d \n" ,dut1 , conn_handle[0] , conn_handle[1]);
	printf("run Cmd_COMM_Send_ACL_Data with dut(%d)\n" ,dut1);

	u8 buf[SOCKET_BUF_SIZE];
	u16 line =0 ;
	struct itimerval timer;
	u8 conn_handles_mas[2];
	u8 acl_data[32]={0};
	u32 test_cnt1=100;
    int sla_pkt_chk = 0 ;

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			conn_handles_mas[0]=buf[_BT_HCI_EVT_COMP_HANDLE+0];
			conn_handles_mas[1]=buf[_BT_HCI_EVT_COMP_HANDLE+1];


			//######################################
#if 0 //case 1
			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				acl_data_gen_tbx(acl_data , 23 ,test_cnt1);
				verdict=COMM_Send_ACL_Data(dut1_fd,conn_handles_mas,0b00,0,23,acl_data);
				VERDICT_RESULT_WITH_LINE();
			}
#endif

#if 0 //case 2
			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				acl_data_gen_tbx(acl_data , ACL_DATA_MAX ,test_cnt1);
				verdict=COMM_Send_ACL_Data(dut1_fd,conn_handles_mas,0b00,0,ACL_DATA_MAX,acl_data);
				VERDICT_RESULT_WITH_LINE();
			}
#endif

#if 0 //case 3
			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				acl_data_gen_tbx(acl_data , 23 ,test_cnt1);
				acl_data[0] = 19;
				acl_data[1] = 0;
				acl_data[2] = 4;
				acl_data[3] = 0;
				verdict=COMM_Send_ACL_Data(dut1_fd,conn_handles_mas,0b00,0,23,acl_data);
				VERDICT_RESULT_WITH_LINE();
			}
#endif

#if 1 //case 4
			for ( ;test_cnt1 > 0 ; test_cnt1 --)
			{
				acl_data_gen_tbx(acl_data , ACL_DATA_MAX ,test_cnt1);
				acl_data[0] = ACL_DATA_MAX - 4;
				acl_data[1] = 0;
				acl_data[2] = 4;
				acl_data[3] = 0;
				COMM_Send_ACL_Data_Without_event(dut1_fd,conn_handles_mas,0b00,0,ACL_DATA_MAX,acl_data);
PKT_CHK:   
                if(SUCCESS != QUERY_Event(dut1_fd, buf, _BT_HCI_EVENT_OP_NUMBER_OF_COMPLETED_PACKETS_)) {
                    line = __LINE__;
                    goto FUN_FAIL;
                }
                else if(1 != hci_event_num_of_completed_packets_parsing(buf)) {
                    MSLEEP(100);

                    sla_pkt_chk ++ ;
                    if (sla_pkt_chk == 100){
                        printf("sla no number of completed pkts\n");
                        line = __LINE__;
                        goto FUN_FAIL;                  
                    }            

                    goto PKT_CHK;
                } 

                sla_pkt_chk = 0;

			}
#endif

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return ;
		}
	}

FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);

}


static void Cmd_COMM_Recv_ACL_Data(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	
	int dut1;
	s32 dut1_fd=0;
	//u8 conn_handle[2];

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_COMM_Recv_ACL_Data with dut(%d)\n" ,dut1);

	u8 buf[SOCKET_BUF_SIZE];
	u16 line =0 ;

	struct itimerval timer;

	event_query_timer_config(5 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1 == read_le_event_get() )
		{
            
            read_le_event_disable();
        
			if (SUCCESS != QUERY_LE_Event(dut1_fd,buf ,
										_BT_HCI_LE_EVENT_SUB_OP_CONNECTION_COMPLETE_,
										0))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			if(SUCCESS != hci_le_event_connection_complete_parsing(0,
										buf,g_pattern_param))
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			
			if (SUCCESS != QUERY_Acl_Data(dut1_fd,buf))//step2 ~ 4
			{
				line=__LINE__;
				goto FUN_FAIL;
			}
			
		}
	}
	
FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);


}


static void Cmd_COMM_ADV_Advertising_Parameters_Set(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 9)
	{
		printf("{dut1}{adv_min}{adv_max}{adv_type}{own_addr_type}{dir_addr_type}{adv_ch}{adv_filter}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_Advertising_Parameters_Set with dut(%d)\n" ,dut1);

    g_pattern_param.adv_param.Advertising_Interval_Min[1]   = (atoi(argv[2]) & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0]   = atoi(argv[2]) & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1]   = (atoi(argv[3]) & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Max[0]   = atoi(argv[3]) & 0x00ff;

    g_pattern_param.adv_param.Advertising_Type[0]           = atoi(argv[4]) ;
    g_pattern_param.adv_param.Own_Address_Type[0]           = atoi(argv[5]) ;
    g_pattern_param.adv_param.Direct_Address_Type[0]        = atoi(argv[6]) ;
    g_pattern_param.adv_param.Advertising_Channel_Map[0]    = atoi(argv[7]) ;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0]  = atoi(argv[8]) ;
   
	COMM_ADV_Advertising_Parameters_Set_Config(dut1,&g_pattern_param);
	COMM_ADV_Advertising_Parameters_Set(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_ADV_Advertising_Data_Set(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut1}{len}\n");
		return;
	}
	int dut1;    
    int data_len = 0;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
    data_len = atoi(argv[2]);
    
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_Advertising_Data_Set with dut(%d)\n" ,dut1);

    g_pattern_param.adv_data_param.Advertising_Data_Length[0] = data_len;

    g_pattern_param.adv_data_param.Advertising_Data[0] = 0x02;
    g_pattern_param.adv_data_param.Advertising_Data[1] = 0x01;
    g_pattern_param.adv_data_param.Advertising_Data[2] = 0x06;
    g_pattern_param.adv_data_param.Advertising_Data[3] = 0x08;
    g_pattern_param.adv_data_param.Advertising_Data[4] = 0x09;
    g_pattern_param.adv_data_param.Advertising_Data[5] = 0x77;
    g_pattern_param.adv_data_param.Advertising_Data[6] = 0x69;
    g_pattern_param.adv_data_param.Advertising_Data[7] = 0x6c;
    g_pattern_param.adv_data_param.Advertising_Data[8] = 0x6c;
    g_pattern_param.adv_data_param.Advertising_Data[9] = 0x69;

    g_pattern_param.adv_data_param.Advertising_Data[10] = 0x61;
    g_pattern_param.adv_data_param.Advertising_Data[11] = 0x6d;
    g_pattern_param.adv_data_param.Advertising_Data[12] = 0x02;
    g_pattern_param.adv_data_param.Advertising_Data[13] = 0x0a;
    g_pattern_param.adv_data_param.Advertising_Data[14] = 0x00;
    g_pattern_param.adv_data_param.Advertising_Data[15] = 0x03;
    g_pattern_param.adv_data_param.Advertising_Data[16] = 0x03;
    g_pattern_param.adv_data_param.Advertising_Data[17] = 0x02;
    g_pattern_param.adv_data_param.Advertising_Data[18] = 0x18;
    g_pattern_param.adv_data_param.Advertising_Data[19] = 0x03;

    g_pattern_param.adv_data_param.Advertising_Data[20] = 0x16;
    g_pattern_param.adv_data_param.Advertising_Data[21] = 0x02;
    g_pattern_param.adv_data_param.Advertising_Data[22] = 0x18;
    g_pattern_param.adv_data_param.Advertising_Data[23] = 0x03;
    g_pattern_param.adv_data_param.Advertising_Data[24] = 0x19;
    g_pattern_param.adv_data_param.Advertising_Data[25] = 0x00;
    g_pattern_param.adv_data_param.Advertising_Data[26] = 0x00;
    g_pattern_param.adv_data_param.Advertising_Data[27] = 0x03;
    g_pattern_param.adv_data_param.Advertising_Data[28] = 0x1a;
    g_pattern_param.adv_data_param.Advertising_Data[29] = 0x20;

    g_pattern_param.adv_data_param.Advertising_Data[30] = 0x00;

    bt_hci_cmd_le_set_advertising_data.parameter_tbl[0].value = g_pattern_param.adv_data_param.Advertising_Data_Length;  
    bt_hci_cmd_le_set_advertising_data.parameter_tbl[1].value = g_pattern_param.adv_data_param.Advertising_Data;

	bt_hci_write_cmd2socket(dut1_fd, &bt_hci_cmd_le_set_advertising_data);

	// for socket
	u16 len;
	u8	buf[SOCKET_BUF_SIZE];

    do{
        socket_msg_get(dut1_fd,&len,buf);
    }while(len <=0);

	printf("Get Event(%d):\n", dut1_fd);
	print_charray(len, buf);

}


static void Cmd_COMM_Scan_Response_Data_Set (s32 argc, s8 *argv[]) {

// # parameters from argv
	if(argc != 2) {
		printf("{dut1}\n");
		return;
	}

	int dut;
	s32 dut_fd=0;

	dut 	= atoi(argv[1]);
	dut_fd	= dut_socket_init(dut);

	printf("set scan response to dut-%d\n", dut_fd);

	u8 scn_rsp_data_len = 31;
	u8 scn_rsp_data[31];;

	u32 loop_i;
	u32 pld0 = 0x31;

	for(loop_i=0; loop_i < 31; loop_i++) {
		scn_rsp_data[loop_i] = loop_i + pld0;
	}

	bt_hci_cmd_le_set_scan_response_data.parameter_tbl[0].value = &scn_rsp_data_len;
	bt_hci_cmd_le_set_scan_response_data.parameter_tbl[1].value =  scn_rsp_data;

	bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_le_set_scan_response_data);

	// for socket
	u16 len;
	u8	buf[SOCKET_BUF_SIZE];

    do{
        socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);

	printf("Get Event(%d):\n", dut_fd);
	print_charray(len, buf);
}

static void Cmd_COMM_ADV_NonConnectable_Advertising(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_NonConnectable_Advertising with dut(%d)\n" ,dut1);
	COMM_ADV_NonConnectable_Advertising_Config(31,&g_pattern_param);
	COMM_ADV_NonConnectable_Advertising(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_ADV_Undirected_Advertising(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_Undirected_Advertising with dut(%d)\n" ,dut1);
	COMM_ADV_Undirected_Advertising_Config(31,&g_pattern_param);
	//g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;
    
	COMM_ADV_Undirected_Advertising(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_ADV_Undirected_Advertising_Stress(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut1}{stress_cnt}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;
    int cnt = 0;
    s8 *tmp_argv[3];
    int i = 0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	cnt=atoi(argv[2]);

	printf("Stress Cmd_TI_COMM_ADV_Undirected_Advertising with dut(%d)\n" ,dut1);

    while(i++ < cnt) {
        printf("!!!!!!!!!!!!!!!!!!!!cnt=%d\n", i);
        COMM_ADV_Undirected_Advertising_Config(31,&g_pattern_param);
        //g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;

        COMM_ADV_Undirected_Advertising(dut1_fd,g_pattern_param);

        //sleep(1);

        tmp_argv[0] = "lecc";
        tmp_argv[1] = "2";
        Cmd_lecc(2, tmp_argv);

        tmp_argv[0] = "ledc";
        tmp_argv[1] = "1";
        tmp_argv[2] = "3";
        Cmd_ledc(3, tmp_argv);
        //sleep(1);

        //COMM_ADV_Disable_Config(dut1,&g_pattern_param);
        //COMM_ADV_Disable(dut1_fd,g_pattern_param);
    }
}

static void Cmd_COMM_Initiator_Stress(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{adv_dut1}{stress_cnt}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;
    int cnt = 0;
    s8 *tmp_argv[3];
    int i = 0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	cnt=atoi(argv[2]);

	printf("Stress init-->conn(master) with dut(%d)\n" ,dut1);

    while(i++ < cnt) {
        printf("!!!!!!!!!!!!!!!!!!!!cnt=%d\n", i);
        COMM_ADV_Undirected_Advertising_Config(31,&g_pattern_param);
        //g_pattern_param.adv_param.Advertising_Channel_Map[0] = HCI_CMD_PARAM_ENABLE_CHANNEL_39;

        COMM_ADV_Undirected_Advertising(dut1_fd,g_pattern_param);
        sleep(1);

        tmp_argv[0] = "lecc";
        tmp_argv[1] = "1";
        Cmd_lecc(2, tmp_argv);
        sleep(1);

        tmp_argv[0] = "ledc";
        tmp_argv[1] = "1";
        tmp_argv[2] = "4";
        Cmd_ledc(3, tmp_argv);
        sleep(1);

        //reset adv(ti).
        dut_reset_with_mask_en(dut1_fd);
        //COMM_ADV_Disable_Config(dut1,&g_pattern_param);
        //COMM_ADV_Disable(dut1_fd,g_pattern_param);
    }
}
static void Cmd_COMM_ADV_Undirected_Advertising_Test(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut1}{dut2}\n");
		return;
	}
	int dut1 , dut2;
	s32 dut1_fd ,dut2_fd;
	u8	buf[SOCKET_BUF_SIZE];
	u16 len;
	int verdict=FAIL;
	int ret;
	u16 line =0 ;

	struct itimerval timer;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run Cmd_TI_COMM_ADV_Undirected_Advertising_Test with dut(%d)\n" ,dut1);
	COMM_ADV_Undirected_Advertising_Config(31,&g_pattern_param);
	COMM_ADV_Undirected_Advertising(dut1_fd,g_pattern_param);

	sleep(1);

	// waiting adv setting data ,then config scan

	COMM_SCN_Passive_Scanning_Config(dut2,&g_pattern_param);
	COMM_SCN_Passive_Scanning(dut2_fd,g_pattern_param);

	event_query_timer_config(20 , 0 , 0 , 0, &timer);
	event_query_timer_start(timer ,read_le_event_enable );

	while(1)//waiting adv report event , timer or counter
	{
		if ( 1== read_le_event_get() )
		{
			//QUERY_LE_Event(dut1_fd);
			buf[_BT_HCI_IDX_INDICATOR_] =	_BT_HCI_INDICATOR_EVENT_;
			buf[_BT_HCI_IDX_EVENT_CODE_]	=	_BT_HCI_EVENT_OP_LE_EVENT_;
			buf[_BT_HCI_IDX_EVENT_LENGTH_]	=	0x00 ;//don't care
			buf[_BT_HCI_IDX_EVENT_PARAMETER_]	= _BT_HCI_LE_EVENT_SUB_OP_ADVERTISING_REPORT_;
			buf[_BT_HCI_IDX_EVENT_PARAMETER_+1] =	0x00 ;//don't care
			buf[_BT_HCI_IDX_EVENT_PARAMETER_+2] = HCI_CMD_PARAM_ADV_IND;

			ret=socket_msg_send(dut2_fd , HCI_CMD_PARAM_ADV_DATA_LEN_MAX ,buf);
			if(SOCKET_SUCCESS != ret)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

            do{
                ret=socket_msg_get(dut2_fd,&len,buf);
            }while(len <=0);
			if(SOCKET_SUCCESS != ret)
			{
				line=__LINE__;
				goto FUN_FAIL;
			}

			printf("Get Event from Buff (%d):\n",dut2_fd);
			print_charray(len,buf);

			//##################################################

			ret=hci_le_event_advertising_report_parsing(HCI_CMD_PARAM_ADV_IND,buf,g_pattern_param);

			if (EQUAL == ret)
			{
				//stop scn before reconfig adv
				//to avoid upper tester too slow to receive old adv report
				COMM_SCN_Disable_Config(dut2,&g_pattern_param);
				verdict=COMM_SCN_Disable(dut2_fd,g_pattern_param);
				VERDICT_RESULT_WITH_LINE();
			}
			else
			{
				line =ret ;
				goto FUN_FAIL;
			}

			read_le_event_disable();

			LOG_INFO("[Pattern][%s]SUCCESS\n" ,__FUNCTION__);
			return ;
		}

	}
FUN_FAIL:
	LOG_INFO("[Pattern][%s]:%d FAIL\n" ,__FUNCTION__,line);

}

static void Cmd_COMM_ADV_Discoverable_Advertising(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_Discoverable_Advertising with dut(%d)\n" ,dut1);
	COMM_ADV_Discoverable_Advertising_Config(HCI_CMD_PARAM_ADV_DATA_LEN_MAX,&g_pattern_param);    
	COMM_ADV_Discoverable_Advertising(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_ADV_Directed_Advertising(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_Directed_Advertising with dut(%d)\n" ,dut1);
	COMM_ADV_Directed_Advertising_Config(dut1,&g_pattern_param);
	COMM_ADV_Directed_Advertising(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_ADV_Low_Duty_Directed_Advertising(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_Directed_Advertising with dut(%d)\n" ,dut1);
	COMM_ADV_Low_Duty_Directed_Advertising_Config(dut1,&g_pattern_param);
	COMM_ADV_Low_Duty_Directed_Advertising(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_ADV_Enable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut1}{Timeout}\n");
		return;
	}
	int dut1;
    int test_time;
	s32 dut1_fd=0;

	struct timeval start_time;                      
    struct timeval current_time;       

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_Enable with dut(%d)\n" ,dut1);

    test_time = atoi(argv[2]);

	COMM_ADV_Enable_Config(dut1,&g_pattern_param);
	COMM_ADV_Enable(dut1_fd,g_pattern_param);

    gettimeofday(&start_time,NULL);

    if( 0 != test_time){
        while(1){
            usleep(10);
            gettimeofday(&current_time,NULL);

            if((current_time.tv_sec - start_time.tv_sec) >= test_time){
                COMM_ADV_Disable_Config(dut1,&g_pattern_param);
                COMM_ADV_Disable(dut1_fd,g_pattern_param);
                return ;
            }
        }
    }

}


static void Cmd_COMM_ADV_Disable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_ADV_Disable with dut(%d)\n" ,dut1);
	COMM_ADV_Disable_Config(dut1,&g_pattern_param);
	COMM_ADV_Disable(dut1_fd,g_pattern_param);
}


static void Cmd_COMM_SCN_Parameters_Set(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 7)
	{
		printf("{dut1}{type}{intval}{window}{own_addr_type}{filter}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_SCN_Parameters_Set with dut(%d)\n" ,dut1);

    g_pattern_param.scn_param.LE_Scan_Type[0]               =  atoi(argv[2]) ;
    g_pattern_param.scn_param.LE_Scan_Interval[0]           =  atoi(argv[3]) & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Interval[1]           = (atoi(argv[3]) & 0xff00) >> 8;
    g_pattern_param.scn_param.LE_Scan_Window[0]             =  atoi(argv[4]) & 0x00ff;
    g_pattern_param.scn_param.LE_Scan_Window[1]             = (atoi(argv[4]) & 0xff00) >> 8;

    g_pattern_param.scn_param.Own_Address_Type[0]           =  atoi(argv[5]) ;
    g_pattern_param.scn_param.Scanning_Filter_Policy[0]     =  atoi(argv[6]) ;
#if 0
    g_pattern_param.adv_param.Advertising_Interval_Min[1]   = (atoi(argv[2]) & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Min[0]   = atoi(argv[2]) & 0x00ff;
    g_pattern_param.adv_param.Advertising_Interval_Max[1]   = (atoi(argv[3]) & 0xff00) >> 8;
    g_pattern_param.adv_param.Advertising_Interval_Max[0]   = atoi(argv[3]) & 0x00ff;

    g_pattern_param.adv_param.Advertising_Type[0]           = atoi(argv[4]) ;
    g_pattern_param.adv_param.Own_Address_Type[0]           = atoi(argv[5]) ;
    g_pattern_param.adv_param.Direct_Address_Type[0]        = atoi(argv[6]) ;
    g_pattern_param.adv_param.Advertising_Channel_Map[0]    = atoi(argv[7]) ;
    g_pattern_param.adv_param.Advertising_Filter_Policy[0]  = atoi(argv[8]) ;
#endif   
	COMM_SCN_Parameters_Set_Config(dut1,&g_pattern_param);
	COMM_SCN_Parameters_Set(dut1_fd,g_pattern_param);
}


static void Cmd_COMM_SCN_Passive_Scanning(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_SCN_Passive_Scanning with dut(%d)\n" ,dut1);
	COMM_SCN_Passive_Scanning_Config(dut1,&g_pattern_param);
	COMM_SCN_Passive_Scanning(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_SCN_Active_Scanning(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_SCN_Active_Scanning with dut(%d)\n" ,dut1);
	COMM_SCN_Active_Scanning_Config(dut1,&g_pattern_param);
	COMM_SCN_Active_Scanning(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_SCN_Enable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_SCN_Ensable with dut(%d)\n" ,dut1);
	COMM_SCN_Enable_Config(dut1,&g_pattern_param);
	COMM_SCN_Enable(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_FULL_SCN_Enable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_SCN_Ensable with dut(%d)\n" ,dut1);
    set_scan_interval(500);
    set_scan_windows(500);
	COMM_SCN_Parameters_Set_Config(dut1, &g_pattern_param);
	COMM_SCN_Parameters_Set(dut1_fd, g_pattern_param);
	COMM_SCN_Enable_Config(dut1,&g_pattern_param);
	COMM_SCN_Enable(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_SCN_Disable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);

	printf("run Cmd_TI_COMM_SCN_Disable with dut(%d)\n" ,dut1);
	COMM_SCN_Disable_Config(dut1,&g_pattern_param);
	COMM_SCN_Disable(dut1_fd,g_pattern_param);
}

static void Cmd_COMM_SCN_Performance(s32 argc, s8 *argv[]) {
	// # parameters from argv
    if(argc != 3)
    {
        printf("{dut1}{Timeout}\n");
        return;
    }
    int dut1;
    int test_time;
    s32 dut1_fd=0;

    struct timeval start_time;                      
    struct timeval current_time;       

    dut1=atoi(argv[1]);
    dut1_fd=dut_socket_init(dut1);
    COMM_Dut_clean_buffer(dut1_fd);

    printf("run Cmd_TI_COMM_SCN_Ensable with dut(%d)\n" ,dut1);

    test_time = atoi(argv[2]);

    COMM_SCN_Enable_Config(dut1,&g_pattern_param);
    COMM_SCN_Enable(dut1_fd,g_pattern_param);

    gettimeofday(&start_time,NULL);

	u32 adv_cnt = 0;
    u32 scan_rsp_cnt = 0;

    if( 0 != test_time){
        while(1){
            usleep(10);
            gettimeofday(&current_time,NULL);

            if((current_time.tv_sec - start_time.tv_sec) >= test_time){
                COMM_SCN_Disable_Config(dut1,&g_pattern_param);
                COMM_SCN_Disable(dut1_fd,g_pattern_param);
                COMM_Dut_check_adv_rpt_num(dut1_fd, &adv_cnt, &scan_rsp_cnt);
                
                printf("\n### adv_cnt %d | scan_rsp_cnt %d ###\n", adv_cnt, scan_rsp_cnt);
		        LOG_INFO("[Pattern][%s] adv_cnt Ratio value : %.2f %%\n", __FUNCTION__, (float)((adv_cnt * 100) / (1200)));                
		        LOG_INFO("[Pattern][%s] scn_rsp Ratio value : %.2f %%\n", __FUNCTION__, (float)((scan_rsp_cnt * 100) / (1200)));
                return ;
            }
        }
    }

}


static void Cmd_COMM_MULTI_SCN_ADV_Enable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 4)
	{
		printf("{dut1}{dut2}{Timeout}\n");
		return;
	}
    
	int dut1;
    int dut2;
    int test_time;
	s32 dut1_fd=0;
	s32 dut2_fd=0;

	struct timeval start_time;                      
    struct timeval current_time;       

	dut1 = atoi(argv[1]);
	dut1_fd = dut_socket_init(dut1);

	dut2 = atoi(argv[2]);
	dut2_fd = dut_socket_init(dut2);

	printf("run Cmd_TI_COMM_MULTI_SCN_ADV_Enable with dut(%d) dut(%d)\n" ,dut1,dut2);

    test_time = atoi(argv[3]);

	COMM_SCN_Enable_Config(dut1,&g_pattern_param);
	COMM_SCN_Enable(dut1_fd,g_pattern_param);

    //usleep(10000);

	COMM_ADV_Enable_Config(dut1,&g_pattern_param);
	COMM_ADV_Enable(dut1_fd,g_pattern_param);

	COMM_ADV_Enable_Config(dut2,&g_pattern_param);
	COMM_ADV_Enable(dut2_fd,g_pattern_param);

    gettimeofday(&start_time,NULL);

    if( 0 != test_time){
        while(1){
            usleep(10);
            gettimeofday(&current_time,NULL);

            if((current_time.tv_sec - start_time.tv_sec) >= test_time){
                COMM_ADV_Disable_Config(dut1,&g_pattern_param);
                COMM_ADV_Disable(dut1_fd,g_pattern_param);

                COMM_ADV_Disable_Config(dut2,&g_pattern_param);
                COMM_ADV_Disable(dut2_fd,g_pattern_param);
                
                return ;
            }
        }
    }

    
}


static void Cmd_DDI_ADV_Non_Connectable_Advertising_Events(s32 argc, s8 *argv[]) {
	// # parameters from argv
	int dut1 ,dut2;

	s32 dut1_fd=0;
	s32 dut2_fd=0;

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut1 ,dut2);
    LOG_INIT();
	LOG_RESULT(DDI_ADV_NonConnectable_Advertising_Events(dut1_fd , dut2_fd));
}

static void Cmd_DDI_ADV_Undirected_Advertising_Events(s32 argc, s8 *argv[]) {
	// # parameters from argv
	int dut1 ,dut2;

	s32 dut1_fd=0;
	s32 dut2_fd=0;

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut1 ,dut2);
    LOG_INIT();
	LOG_RESULT(DDI_ADV_Undirected_Advertising_Events(dut1_fd , dut2_fd));

}

static void Cmd_DDI_ADV_Advertising_Data_Non_Connectable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	int dut1 ,dut2;

	s32 dut1_fd=0;
	s32 dut2_fd=0;

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut1 ,dut2);
    LOG_INIT();
	LOG_RESULT(DDI_ADV_Advertising_Data_Non_Connectable(dut1_fd , dut2_fd));

}

static void Cmd_DDI_ADV_Advertising_Data_Undirected(s32 argc, s8 *argv[]) {
	// # parameters from argv
	int dut1 ,dut2;

	s32 dut1_fd=0;
	s32 dut2_fd=0;

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut1 ,dut2);
    LOG_INIT();
	LOG_RESULT(DDI_ADV_Advertising_Data_Undirected(dut1_fd , dut2_fd));

}

static void Cmd_DDI_ADV_Scan_Request_Undirected_Connectable(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();
	LOG_RESULT(DDI_ADV_Scan_Request_Undirected_Connectable(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_DDI_ADV_Connection_Request(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_ADV_Connection_Request(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_DDI_ADV_Scan_Request_Connection_Request(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_ADV_Scan_Request_Connection_Request(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_DDI_ADV_Discoverable_Advertising_Events(s32 argc, s8 *argv[]) {
	// # parameters from argv
	int dut1 ,dut2;

	s32 dut1_fd=0;
	s32 dut2_fd=0;

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut1 ,dut2);
    LOG_INIT();

	LOG_RESULT(DDI_ADV_Discoverable_Advertising_Events(dut1_fd , dut2_fd));

}

static void Cmd_DDI_ADV_Advertising_Data_Discoverable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	int dut1 ,dut2;

	s32 dut1_fd=0;
	s32 dut2_fd=0;

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut1 ,dut2);
    LOG_INIT();

	LOG_RESULT(DDI_ADV_Advertising_Data_Discoverable(dut1_fd , dut2_fd));

}

static void Cmd_DDI_ADV_Scan_Request_Discoverable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	int dut1 ,dut2;

	s32 dut1_fd=0;
	s32 dut2_fd=0;

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut1 ,dut2);
    LOG_INIT();

	LOG_RESULT(DDI_ADV_Scan_Request_Discoverable(dut1_fd , dut2_fd));

}


static void Cmd_DDI_ADV_Device_Filtering_Discoverable(s32 argc, s8 *argv[]) {
	// # parameters from argv
    if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_ADV_Device_Filtering_Discoverable(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));	
}


static void Cmd_DDI_SCN_Passive_Scanning_Non_Connectable(s32 argc, s8 *argv[]) {
	// # parameters from argv
	int dut1 ,dut2;

	s32 dut1_fd=0;
	s32 dut2_fd=0;

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
	dut2=atoi(argv[2]);
	dut2_fd=dut_socket_init(dut2);

	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut1 ,dut2);
    LOG_INIT();

	LOG_RESULT(DDI_SCN_Passive_Scanning_Non_Connectable(dut1_fd , dut2_fd));

}

static void Cmd_DDI_SCN_Passive_Scanning_Device_Filtering(s32 argc, s8 *argv[]) {
	// # parameters from argv
    if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_SCN_Passive_Scanning_Device_Filtering(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));	
}

static void Cmd_DDI_SCN_Passive_Scanning_Undirected_Events(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_SCN_Passive_Scanning_Undirected_Events(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_DDI_SCN_Passive_Scanning_Directed_Events(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_SCN_Passive_Scanning_Directed_Events(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_DDI_SCN_Passive_Scanning_Discoverable_Events(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_SCN_Passive_Scanning_Discoverable_Events(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_DDI_SCN_Active_Scanning_Device_Filtering(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_SCN_Active_Scanning_Device_Filtering(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_DDI_SCN_Active_Scanning(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_SCN_Active_Scanning(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_DDI_SCN_Scanning_For_Advertiser_Types(s32 argc, s8 *argv[]) {
	// # parameters from argv

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_SCN_Scanning_For_Advertiser_Types(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_DDI_ADV_Scan_Request_Device_Filtering(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(DDI_ADV_Scan_Request_Device_Filtering(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_DDI_ADV_Connection_Request_Device_Filtering(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();


	LOG_RESULT(DDI_ADV_Connection_Request_Device_Filtering(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_DDI_ADV_Directed_Advertising_Events(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();


	LOG_RESULT(DDI_ADV_Directed_Advertising_Events(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_ADV_Accepting_Connections(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_ADV_Accepting_Connections(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_INI_Connection_Initiation(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_INI_Connection_Initiation(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_INI_Connecting_to_Directed_Advertising(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_INI_Connecting_to_Directed_Advertising(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_INI_Initiation_Device_Filtering_Undirected(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_INI_Initiation_Device_Filtering_Undirected(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_INI_Initiation_Device_Filtering_Directed(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_INI_Initiation_Device_Filtering_Directed(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_ADV_Accepting_Connections_Timeout(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_ADV_Accepting_Connections_Timeout(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_CON_ADV_Directed_Advertising_Connection(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(CON_ADV_Directed_Advertising_Connection(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_SLA_Slave_Asymmetric_Connections(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(CON_SLA_Slave_Asymmetric_Connections(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_CON_SLA_Slave_Sending_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(CON_SLA_Slave_Sending_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_SLA_Slave_Receiving_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(CON_SLA_Slave_Receiving_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_SLA_Slave_Sending_and_Receiving_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(CON_SLA_Slave_Sending_and_Receiving_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_CON_SLA_Accepting_Parameter_Update(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(CON_SLA_Accepting_Parameter_Update(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));

}


static void Cmd_CON_SLA_Slave_Sending_Termination(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
	LOG_INIT();
	LOG_RESULT(CON_SLA_Slave_Sending_Termination(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_SLA_Slave_Accepting_Termination(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_SLA_Slave_Accepting_Termination(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_CON_SLA_Slave_Supervision_Timer(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_SLA_Slave_Supervision_Timer(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_SLA_Feature_Setup_Response(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_SLA_Feature_Setup_Response(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_SLA_Slave_Request_Version(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_SLA_Slave_Request_Version(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_SLA_Slave_Respond_Version(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_SLA_Slave_Respond_Version(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_SLA_Slave_Acknowledgement_Scheme(s32 argc, s8 *argv[]) {

    if(argc != 3)
    {
        printf("{dut1}.{dut2}\n");
        return;
    }
    printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();


    LOG_RESULT(CON_SLA_Slave_Acknowledgement_Scheme(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_CON_MAS_Master_Sending_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_MAS_Master_Sending_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_MAS_Events_With_Slave_Latency(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_MAS_Events_With_Slave_Latency(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_MAS_Master_Acknowledgement_Scheme(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_MAS_Master_Acknowledgement_Scheme(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}
static void Cmd_CON_MAS_Master_Receiving_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(CON_MAS_Master_Receiving_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_MAS_Master_Sending_and_Receiving_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_MAS_Master_Sending_and_Receiving_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}



static void Cmd_CON_MAS_Master_Supervision_Timer(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(CON_MAS_Master_Supervision_Timer(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_CON_MAS_Feature_Setup_Request(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_MAS_Feature_Setup_Request(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_MAS_Master_Request_Version(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(CON_MAS_Master_Request_Version(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CON_MAS_Master_Respond_Version(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(CON_MAS_Master_Respond_Version(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_TIM_ADV_Earliest_transmission_to_Advertiser(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(TIM_ADV_Earliest_transmission_to_Advertiser(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_TIM_SLA_Adjusting_Anchor_Point(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(TIM_SLA_Adjusting_Anchor_Point(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}



static void Cmd_TIM_SLA_Earliest_Transmission_Start_to_Slave(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
    LOG_INIT();

	LOG_RESULT(TIM_SLA_Earliest_Transmission_Start_to_Slave(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_TIM_SLA_Latest_Transmission_Start_to_Slave(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(TIM_SLA_Latest_Transmission_Start_to_Slave(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_TIM_SLA_Shortest_Connection_Interval(s32 argc, s8 *argv[]) {

    if(argc != 3)
    {
        printf("{dut1}.{dut2}\n");
        return;
    }
    printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

    LOG_RESULT(TIM_SLA_Shortest_Connection_Interval(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_FRH_ADV_Accepting_Connections_with_Hop_Lengths(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(FRH_ADV_Accepting_Connections_with_Hop_Lengths(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_FRH_SLA_Accepting_Channel_Map_Update(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(FRH_SLA_Accepting_Channel_Map_Update(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}



static void Cmd_SEC_ADV_Advertising_With_Random_Address(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(SEC_ADV_Advertising_With_Random_Address(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_SCN_Random_Address_Scanning(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(SEC_SCN_Random_Address_Scanning(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_SLA_Slave_Encryption_Mode_Setup(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(SEC_SLA_Slave_Encryption_Mode_Setup(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_SLA_Slave_Pause_Encryption(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(SEC_SLA_Slave_Pause_Encryption(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_SLA_Slave_Pause_Encryption_Sending_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(SEC_SLA_Slave_Pause_Encryption_Sending_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_SLA_Slave_Sending_Reject_Ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(SEC_SLA_Slave_Sending_Reject_Ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_SLA_Slave_Receiving_Encrypted_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(SEC_SLA_Slave_Receiving_Encrypted_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_MAS_Master_Encryption_Mode_Setup(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(SEC_MAS_Master_Encryption_Mode_Setup(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_MAS_Master_Pause_Encryption(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(SEC_MAS_Master_Pause_Encryption(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_MAS_Master_Receiving_Reject_Ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();


	LOG_RESULT(SEC_MAS_Master_Receiving_Reject_Ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_SEC_MAS_Master_Encryption_Sending_Data_Before_LL_ENC_RSP(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}

    LOG_INIT();
    
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));
	LOG_RESULT(SEC_MAS_Master_Encryption_Sending_Data_Before_LL_ENC_RSP(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_MAS_Master_Encryption_Setup_Missing_Response(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(SEC_MAS_Master_Encryption_Setup_Missing_Response(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_MAS_Master_Encryption_Setup_Missing_Request(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(SEC_MAS_Master_Encryption_Setup_Missing_Request(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_SEC_MAS_Master_Pause_Encryption_Sending_Data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(SEC_MAS_Master_Pause_Encryption_Sending_Data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_Heart_Rate_1(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_Heart_Rate_1(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_Heart_Rate_2(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_Heart_Rate_2(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_Heart_Rate_3(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_Heart_Rate_3(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Profile_Heart_Rate_4(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_Heart_Rate_4(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Profile_HID_1(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_1(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_HID_2(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_2(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_HID_3(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_3(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_HID_4(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_4(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_HID_5(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_5(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_HID_6(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_6(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_HID_7(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_7(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_HID_8(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_8(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Profile_HID_9(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}.{dut2}\n");
		return;
	}
	printf("run %s with dut(%d) and dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) ,dut_socket_get(atoi(argv[2])));

    LOG_INIT();

	LOG_RESULT(PROF_HID_9(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_time_indep_all_param_check_with_adv_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_time_indep_all_param_check_with_adv_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_time_indep_all_param_check_with_scn_rsp(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_time_indep_all_param_check_with_scn_rsp(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_time_indep_filter_check_with_scn_req(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_time_indep_filter_check_with_scn_req(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_time_indep_filter_check_with_conn_req(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_time_indep_filter_check_with_conn_req(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_time_dep_advint_chmap_check_ex_dir_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_time_dep_advint_chmap_check_ex_dir_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Adv_time_dep_advint_chmap_check_with_dir_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_time_dep_advint_chmap_check_with_dir_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_time_indep_all_param_check_passive_with_adv_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Scn_time_indep_all_param_check_passive_with_adv_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_time_indep_all_param_check_passive_without_scn_rsp(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Scn_time_indep_all_param_check_passive_without_scn_rsp(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_time_indep_all_param_check_active_with_adv_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Scn_time_indep_all_param_check_active_with_adv_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_time_indep_all_param_check_active_with_scn_rsp(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Scn_time_indep_all_param_check_active_with_scn_rsp(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_time_dep_scnint_win_check_ex_dir_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Scn_time_dep_scnint_win_check_ex_dir_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_time_dep_scnint_win_check_with_dir_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Scn_time_dep_scnint_win_check_with_dir_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_time_indep_acl_data_len(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_time_indep_acl_data_len(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_time_indep_ch_map(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_time_indep_ch_map(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_time_dep_conn_intval(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_time_dep_conn_intval(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_time_dep_conn_slave_latency(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_time_dep_conn_slave_latency(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_time_dep_conn_supervision_timeout(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_time_dep_conn_supervision_timeout(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_modify_adv_data_and_scn_rsp_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_modify_adv_data_and_scn_rsp_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_check_conn_with_all_adv_type(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_check_conn_with_all_adv_type(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_conn_adv_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

    LOG_RESULT(Sla_conn_adv_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Whitelist_add_remove(s32 argc, s8 *argv[]) {

	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	printf("run %s with dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])));

    LOG_INIT();

	LOG_RESULT(Whitelist_add_remove(dut_socket_get(atoi(argv[1])) ));
}


static void Cmd_Whitelist_adv(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Whitelist_adv(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Whitelist_scn(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Whitelist_scn(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Whitelist_adv_scn(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Whitelist_adv_scn(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Whitelist_adv_scn_sla(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Whitelist_adv_scn_sla(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Adv_stability_with_adv_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_stability_with_adv_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_stability_with_adv_scan_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_stability_with_adv_scan_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Adv_stability_with_adv_non_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_stability_with_adv_non_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_stability_with_adv_direct_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Adv_stability_with_adv_direct_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_stability_passive_with_adv_ind(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Scn_stability_passive_with_adv_ind(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_stability_active_with_adv_ind_scn_rsp(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Scn_stability_active_with_adv_ind_scn_rsp(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stability_conn_with_tx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_conn_with_tx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stability_conn_with_rx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_conn_with_rx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stability_conn_with_trx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_conn_with_trx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stability_conn_with_rx_acl_data_with_busy_polling(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_conn_with_rx_acl_data_with_busy_polling(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stability_conn_with_tx_acl_data_undir_adv(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_conn_with_tx_acl_data_undir_adv(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stability_conn_with_rx_acl_data_undir_adv(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_conn_with_rx_acl_data_undir_adv(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stability_conn_with_trx_acl_data_undir_adv(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_conn_with_trx_acl_data_undir_adv(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stability_encrypt_with_tx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_encrypt_with_tx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stability_encrypt_with_rx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_encrypt_with_rx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stability_encrypt_with_trx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_encrypt_with_trx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stability_ch_map_update(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_ch_map_update(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stability_conn_param_update(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stability_conn_param_update(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_connect_and_disconnect(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_and_disconnect(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_connect_and_disconnect_slave(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_and_disconnect_slave(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_connect_and_disconnect_rx_not_sync(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_and_disconnect_rx_not_sync(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_connect_encrypt_disconnect(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_encrypt_disconnect(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_connect_encrypt_disconnect_slave(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_encrypt_disconnect_slave(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_start_and_restart_encryption(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_start_and_restart_encryption(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_channel_map_update(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_channel_map_update(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_channel_map_update_max_trx_acl(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_channel_map_update_max_trx_acl(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_connect_param_update_with_slave_latency(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_param_update_with_slave_latency(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_traffic_tx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_traffic_tx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_traffic_rx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_traffic_rx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_traffic_encrypt_trx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_traffic_encrypt_trx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_traffic_encrypt_trx_acl_data_6pdu(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_traffic_encrypt_trx_acl_data_6pdu(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_max_traffic_tx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_max_traffic_tx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_max_traffic_rx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_max_traffic_rx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_max_traffic_trx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_max_traffic_trx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_max_traffic_encrypt_tx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_max_traffic_encrypt_tx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_max_traffic_encrypt_rx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_max_traffic_encrypt_rx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_max_traffic_encrypt_trx_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_max_traffic_encrypt_trx_acl_data(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_max_traffic_tx_acl_data_without_flow_ctrl(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_max_traffic_tx_acl_data_without_flow_ctrl(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_connect_param_update_with_conn_interval(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_param_update_with_conn_interval(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_stress_connect_param_update_with_conn_interval_max_trx_acl(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_param_update_max_trx_acl(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_connect_param_update_max_conn_interval_slave_latency(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_param_update_max_conn_interval_slave_latency(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_stress_connect_param_update_max_min_conn_interval_and_channel_map_update(s32 argc, s8 *argv[]) {

	if(argc != 3)
	{
		printf("{dut1}{dut2} \n");
		return;
	}
	printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2])) );

    LOG_INIT();

	LOG_RESULT(Sla_stress_connect_param_update_max_min_conn_interval_and_channel_map_update(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Idle_acl_data(s32 argc, s8 *argv[]) {

	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	printf("run %s with dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])));

    LOG_INIT();

	LOG_RESULT(Idle_acl_data(dut_socket_get(atoi(argv[1]))));
}

static void Cmd_Idle_read_remote_info(s32 argc, s8 *argv[]) {

	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	printf("run %s with dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])));

    LOG_INIT();

	LOG_RESULT(Idle_read_remote_info(dut_socket_get(atoi(argv[1]))));
}

static void Cmd_Idle_disconnect(s32 argc, s8 *argv[]) {

	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	printf("run %s with dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])));

    LOG_INIT();

	LOG_RESULT(Idle_disconnect(dut_socket_get(atoi(argv[1]))));
}

static void Cmd_Idle_LTK_req(s32 argc, s8 *argv[]) {
    
	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}
	printf("run %s with dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])));
    
    LOG_INIT();
    
    LOG_RESULT(Idle_LTK_req(dut_socket_get(atoi(argv[1]))));
}

static void Cmd_Idle_LTK_req_nrep(s32 argc, s8 *argv[]) {
        
    if(argc != 2)
    {
        printf("{dut1}\n");
        return;
    }
    printf("run %s with dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])));
        
    LOG_INIT();
        
    LOG_RESULT(Idle_LTK_req_nrep(dut_socket_get(atoi(argv[1]))));
}

static void Cmd_Adv_set_param(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_set_param(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_acl_data(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_acl_data(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_read_remote_info(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_read_remote_info(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_disconnect(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_disconnect(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_scn_enable(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_scn_enable(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_scn_param(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_scn_param(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_LTK_req(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_LTK_req(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_LTK_req_nrep(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_LTK_req_nrep(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_data_with_adv_direct_ind(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_data_with_adv_direct_ind(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Adv_reset_enable(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Adv_reset_enable(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_set_param(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_set_param(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_acl_data(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_acl_data(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_read_remote_info(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_read_remote_info(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_disconnect(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_disconnect(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_adv_enable(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_adv_enable(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_adv_param(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_adv_param(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_LTK_req(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_LTK_req(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_LTK_req_nrep(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_LTK_req_nrep(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Scn_reset_enable(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Scn_reset_enable(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_reset_adv(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_reset_adv(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_reset_scn(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_reset_scn(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_Recv_LTK_req_reset(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_Recv_LTK_req_reset(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}


static void Cmd_Sla_acl_data_err_handle(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_acl_data_err_handle(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_read_remote_info_err_handle(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_read_remote_info_err_handle(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_disconnect_err_handle(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_disconnect_err_handle(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_LTK_req_error_handle(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_LTK_req_error_handle(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_LTK_req_nrep_error_handle(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_LTK_req_nrep_error_handle(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Sla_disconnect_twice(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(Sla_disconnect_twice(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Perf_Scan_Active (s32 argc, s8 *argv[]){

	if(argc != 3)
	{
			printf("{dut1 ,dut2\n");
			return;
	}

    LOG_INIT();

	LOG_RESULT(Perf_Scan_Active(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Perf_Scan_Passive (s32 argc, s8 *argv[]){

	if(argc != 3)
	{
			printf("{dut1 ,dut2\n");
			return;
	}

    LOG_INIT();

	LOG_RESULT(Perf_Scan_Passive(dut_socket_get(atoi(argv[1])) , dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Perf_Adv_plus_scan_favor_adv (s32 argc, s8 *argv[]){

	if(argc != 3)
	{
			printf("{dut1}{dut2}\n");
			return;
	}

    LOG_INIT();

	LOG_RESULT(Perf_Adv_plus_scan_favor_adv(dut_socket_get(atoi(argv[1])) , 
                                  dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Perf_Adv_plus_scan_favor_scn (s32 argc, s8 *argv[]){

	if(argc != 3)
	{
			printf("{dut1}{dut2}\n");
			return;
	}

    LOG_INIT();

	LOG_RESULT(Perf_Adv_plus_scan_favor_scn(dut_socket_get(atoi(argv[1])) , 
                                  dut_socket_get(atoi(argv[2]))));
}

static void Cmd_Perf_Sla_Adv_1(s32 argc, s8 *argv[]) {
        
    if(argc != 4)
    {
        printf("{Sla/Adv} {Mas} {Scn}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Adv(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], HCI_CMD_PARAM_ADV_NONCONN_IND, HCI_CMD_PARAM_PASSIVE_SCAN));
}

static void Cmd_Perf_Sla_Adv_2(s32 argc, s8 *argv[]) {
        
    if(argc != 4)
    {
        printf("{Sla/Adv} {Mas} {Scn}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Adv(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], HCI_CMD_PARAM_ADV_NONCONN_IND, HCI_CMD_PARAM_ACTIVE_SCAN));
}

static void Cmd_Perf_Sla_Adv_3(s32 argc, s8 *argv[]) {
        
    if(argc != 4)
    {
        printf("{Sla/Adv} {Mas} {Scn}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Adv(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], HCI_CMD_PARAM_ADV_SCAN_IND, HCI_CMD_PARAM_PASSIVE_SCAN));
}

static void Cmd_Perf_Sla_Adv_4(s32 argc, s8 *argv[]) {
        
    if(argc != 4)
    {
        printf("{Sla/Adv} {Mas} {Scn}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Adv(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], HCI_CMD_PARAM_ADV_SCAN_IND, HCI_CMD_PARAM_ACTIVE_SCAN));
}

static void Cmd_Perf_Sla_Scn_1(s32 argc, s8 *argv[]) {
        
    if(argc != 4)
    {
        printf("{Sla/Scn} {Mas} {Adv}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Scn(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], HCI_CMD_PARAM_PASSIVE_SCAN, HCI_CMD_PARAM_ADV_NONCONN_IND));
}

static void Cmd_Perf_Sla_Scn_2(s32 argc, s8 *argv[]) {
        
    if(argc != 4)
    {
        printf("{Sla/Scn} {Mas} {Adv}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Scn(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], HCI_CMD_PARAM_PASSIVE_SCAN, HCI_CMD_PARAM_ADV_SCAN_IND));
}

static void Cmd_Perf_Sla_Scn_3(s32 argc, s8 *argv[]) {
        
    if(argc != 4)
    {
        printf("{Sla/Scn} {Mas} {Adv}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Scn(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], HCI_CMD_PARAM_ACTIVE_SCAN, HCI_CMD_PARAM_ADV_NONCONN_IND));
}

static void Cmd_Perf_Sla_Scn_4(s32 argc, s8 *argv[]) {
        
    if(argc != 4)
    {
        printf("{Sla/Scn} {Mas} {Adv}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Scn(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], HCI_CMD_PARAM_ACTIVE_SCAN, HCI_CMD_PARAM_ADV_SCAN_IND));
}

static void Cmd_Perf_Sla_Adv_Scn(s32 argc, s8 *argv[]) {
        
    if(argc != 5)
    {
        printf("{Sla/Adv/Scn} {Mas} {Scn} {Adv}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd, Dut_setting[atoi(argv[4])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Adv_Scn(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], &Dut_setting[atoi(argv[4])], HCI_CMD_PARAM_ADV_SCAN_IND, HCI_CMD_PARAM_ACTIVE_SCAN));
}

static void Cmd_Perf_Sla_Adv_Scn_trx(s32 argc, s8 *argv[]) {
        
    if(argc != 5)
    {
        printf("{Sla/Adv/Scn} {Mas} {Scn} {Adv}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd, Dut_setting[atoi(argv[4])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Adv_Scn_trx(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], &Dut_setting[atoi(argv[4])], HCI_CMD_PARAM_ADV_SCAN_IND, HCI_CMD_PARAM_ACTIVE_SCAN));
}

static void Cmd_Perf_Sla_Adv_Scn_iv_update(s32 argc, s8 *argv[]) {
        
    if(argc != 5)
    {
        printf("{Sla/Adv/Scn} {Mas} {Scn} {Adv}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd, Dut_setting[atoi(argv[4])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Adv_Scn_iv_update(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], &Dut_setting[atoi(argv[4])], HCI_CMD_PARAM_ADV_SCAN_IND, HCI_CMD_PARAM_ACTIVE_SCAN));
}

static void Cmd_Perf_Sla_Adv_Scn_ch_update(s32 argc, s8 *argv[]) {
        
    if(argc != 5)
    {
        printf("{Sla/Adv/Scn} {Mas} {Scn} {Adv}\n");
        return;
    }
    printf("run %s with dut(%d) dut(%d) dut(%d) dut(%d)\n", __FUNCTION__, Dut_setting[atoi(argv[1])].dut_fd, Dut_setting[atoi(argv[2])].dut_fd, Dut_setting[atoi(argv[3])].dut_fd, Dut_setting[atoi(argv[4])].dut_fd);
        
    LOG_INIT();
        
    LOG_RESULT(Perf_Sla_Adv_Scn_ch_update(&Dut_setting[atoi(argv[1])], &Dut_setting[atoi(argv[2])], &Dut_setting[atoi(argv[3])], &Dut_setting[atoi(argv[4])], HCI_CMD_PARAM_ADV_SCAN_IND, HCI_CMD_PARAM_ACTIVE_SCAN));
}

static void Cmd_TEST_MAS_Master_Sending_Conn_Req(s32 argc, s8 *argv[]) {

	if(argc != 2)
	{
		printf("{dut} \n");
		return;
	}
	printf("run %s with dut(%d) \n" , __FUNCTION__,dut_socket_get(atoi(argv[1])) );

	TEST_MAS_Master_Sending_Conn_Req(dut_socket_get(atoi(argv[1])) );
}

static void Cmd_Uart_Testing (s32 argc, s8 *argv[]){

	if(argc != 2)
	{
		printf("{dut1}\n");
		return;
	}

	char buf[SOCKET_BUF_SIZE]={"000000001111111122222222333333334444444455555555666666667777777"};
	socket_msg_send(dut_socket_get(atoi(argv[1])) ,63,buf);
}

static void Cmd_Transmit_Test (s32 argc, s8 *argv[]){

	if(argc != 5)
	{
			printf("{dut ,ch ,pkt_len ,payload_type}\n");
			return;
	}
	printf("run transmit test(dut%d)\n" ,atoi(argv[1]));
	transmit_test( atoi(argv[1]),atoi(argv[2]) ,atoi(argv[3]) ,atoi(argv[4]));

}

static void Cmd_Receive_Test(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut , ch }\n");
		return;
	}
	printf("run receive test(dut%d)\n" ,atoi(argv[1]));
	receive_test( atoi(argv[1]),atoi(argv[2]) );
}


static void Cmd_Test_end(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut }\n");
		return;
	}
	printf("run test end(dut%d)\n" ,atoi(argv[1]));
	test_end( atoi(argv[1]));
}

static void Cmd_Comm_config_load(s32 argc, s8 *argv[]) {

	if(argc != 2)
	{
		printf("{cfg}\n");
		return;
	}

	printf("run config load\n");
    bench_config_load(atoi(argv[1]));
}


static void Cmd_Comm_init(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	printf("run Comm Init(dut%d)\n" ,atoi(argv[1]));
	comm_init(atoi(argv[1]));
}

static void Cmd_dut_check_payload(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 3)
	{
		printf("{dut}{enable}\n");
		return;
	}

	int dut1;
	s32 dut1_fd=0;

	dut1=atoi(argv[1]);
	dut1_fd=dut_socket_init(dut1);
    
	printf("run dut check payload(dut%d)\n" ,dut1);
	COMM_Dut_check_payload(dut1_fd , atoi(argv[2]));
}


static void Cmd_TI_Dtm_End(s32 argc, s8 *argv[]) {
	// # parameters from argv
	if(argc != 2)
	{
		printf("{dut}\n");
		return;
	}
	printf("run TI test end(dut%d)\n" ,atoi(argv[1]));
	TI_Dtm_End(atoi(argv[1]));
}


static void Cmd_Reg_Read(s32 argc, s8 *argv[]) {

	// # parameters from argv
	u32 addr;

	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	s32 dut_fd=0;

	// # parameters
	if(argc != 3){
		PRINTF_FX("{dut , addr}\n");
		return;
	}
	addr	 = ssv_atoi(argv[2]);
	dut_fd	 = dut_socket_init(ssv_atoi(argv[1]));

	bt_hci_cmd_ssv_reg_read.parameter_tbl[0].value = (u32*)&addr;

	//HCI_WRITECMD_AND_GETEVENT_PARSING(bt_hci_cmd_ssv_reg_read);

	ret=bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_ssv_reg_read);
	if(SOCKET_SUCCESS != ret)
		return ;
    do{
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	printf("Get Event(%d):\n",dut_fd);
	if(SOCKET_SUCCESS != ret){
		return ;
	}

	print_charray(len,buf);

	PRINTF_FX("[0x%08x] => 0x%02x%02x%02x%02x\n", addr,
	buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_+3],
	buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_+2],
	buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_+1],
	buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_+0]);
}


static void Cmd_Reg_Write(s32 argc, s8 *argv[]) {

	// # parameters from argv
	u32 addr;
	u32 value_w;

	// # parameters for commands
	u8 buf[SOCKET_BUF_SIZE];
	u16 len;
	u8 ret;

	s32 dut_fd=0;

	// # parameters
	if(argc != 4){
		PRINTF_FX("{dut ,addr ,value}\n");
		return;
	}
	addr	 = ssv_atoi(argv[2]);
	value_w  = ssv_atoi(argv[3]);

	dut_fd	 = dut_socket_init(ssv_atoi(argv[1]));

	// # build command
	bt_hci_cmd_ssv_reg_write.parameter_tbl[0].value = (void*)&addr;
	bt_hci_cmd_ssv_reg_write.parameter_tbl[1].value = (void*)&value_w;

	ret=bt_hci_write_cmd2socket(dut_fd, &bt_hci_cmd_ssv_reg_write);
	if(SOCKET_SUCCESS != ret)
		return ;
    do{ 
        ret=socket_msg_get(dut_fd,&len,buf);
    }while(len <=0);
	printf("Get Event(%d):\n",dut_fd);
	print_charray(len,buf);
	if(SOCKET_SUCCESS != ret)
		return ;

	PRINTF_FX("[0x%08x] <= 0x%08x\n", addr,  value_w);
	PRINTF_FX("[0x%08x] => 0x%02x%02x%02x%02x\n", addr,
	buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_+3],
	buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_+2],
	buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_+1],
	buf[_BT_HCI_W_EVENT_HEADER_+_BT_HCI_IDX_EVENT_PARAMETER_+0]);

}

static void Cmd_SSV_Transmit_Test (s32 argc, s8 *argv[]){

	if(argc != 6)
	{
			printf("{dut ,ch ,pkt_cnt,pkt_len ,payload_type}\n");
			return;
	}
	printf("run transmit test(dut%d)\n" ,atoi(argv[1]));
	ssv_transmit_test( atoi(argv[1]),atoi(argv[2]) ,atoi(argv[3]) ,atoi(argv[4]),atoi(argv[5]));
}

static void Cmd_SSV_Auto_Dtm (s32 argc, s8 *argv[]){


	if(argc != 7)
	{
			printf("{ti_dut ,ssv_dut ,pkt_cnt, pkt_len ,payload_type , loop_cnt}\n");
			return;
	}

	u32 loop_cnt = 0;

    LOG_INIT();

	for ( ; loop_cnt < atoi(argv[6]) ; loop_cnt ++){
		LOG_INFO("\n#########################################\n");
		LOG_INFO("run auto dtm (dut%d) ,(dut%d) round(%d)\n" ,atoi(argv[1]),atoi(argv[2]) ,loop_cnt+1);
		LOG_INFO("#########################################\n\n");
		ssv_auto_dtm(atoi(argv[1]),atoi(argv[2]) ,atoi(argv[3]) ,atoi(argv[4]),atoi(argv[5]));
	}
}

static void Cmd_SSV_Dtm_Pattern (s32 argc, s8 *argv[]){

	if(argc != 3)
	{
			printf("{ti_dut ,ssv_dut }\n");
			return;
	}

    LOG_INIT();

	ssv_dtm_pattern( atoi(argv[1]) , atoi(argv[2]) , 1000 , 0 , 0);
}


static void Cmd_CFI_446(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(CFI_446(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CFI_451_1(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(CFI_451_1(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

static void Cmd_CFI_451_2(s32 argc, s8 *argv[]) {
        
    if(argc != 3)
    {
        printf("{dut1}{dut2} \n");
        return;
    }
    printf("run %s with dut(%d) dut(%d)\n", __FUNCTION__, dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2])));
        
    LOG_INIT();
        
    LOG_RESULT(CFI_451_2(dut_socket_get(atoi(argv[1])), dut_socket_get(atoi(argv[2]))));
}

verdict dut_reset_with_mask_en( u8 dut_fd )
{
	int verdict=FAIL;
    u32 line = 0;

    COMM_ADV_Disable_Config(dut_fd,&g_pattern_param);
    COMM_ADV_Disable(dut_fd,g_pattern_param);

    COMM_SCN_Disable_Config(dut_fd,&g_pattern_param);
    COMM_SCN_Disable(dut_fd,g_pattern_param);

    COMM_Clear_White_List(dut_fd);

    COMM_Reset(dut_fd);

	verdict=COMM_Set_Event_Mask(dut_fd,&g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

	verdict=COMM_Le_Set_Event_Mask(dut_fd,&g_pattern_param);
	VERDICT_RESULT_WITH_LINE();

    COMM_Dut_clean_buffer(dut_fd);

    return PASS;

FUN_FAIL:
    printf("[%s]: %d FAIL\n" , __FUNCTION__, line);    
	return FAIL;
}


const CLICmds gCliCmdTableTI[] =
{
	{ "ti-get-system-status",   Cmd_TI_Get_System_Status,				    "TI Get System Status:{dut1}"						    },
    { "ti-sleep-mode-config",   Cmd_TI_Sleep_Mode_Configurations,           "TI Sleep Mode Configurations:{dut1}"                           },
    { "ti-update-br",           Cmd_TI_Update_Hci_Baudrate,                 "TI Update Hci Baudrate:{dut1}"                           },
    { "ti-output-power",        Cmd_TI_Output_Power,                        "TI Output Power:{dut1}"                           },
    { "ti-cont-tx-mode",		    	Cmd_TI_Cont_Tx_Mode,					"TI Continuous Tx Mode: {dut, modulation, test_pattern, ch, pwr_level}"},
    { "ti-write-bd-addr",		    	Cmd_TI_Write_BD_Addr,					"TI Write BD Addr: {dut, bd_addr}"},
    { "ti-pkt-tx-rx",		        	Cmd_TI_Pkt_Tx_Rx,							"TI Packet Tx Rx: {dut, freq_mode, tx_ch, rx_ch, pkt_type, pkt_pattern, pkt_len, pwr_level, prbs9}"},
    { "ti-meter-start",      		    Cmd_TI_BER_Meter_Start,				"TI BER Meter Start: {dut, ch, bd_addr, pkt_type, pkt_len, num_of_pkt, prbs9}"},
	{ "ti-meter-result",	            Cmd_TI_Read_BER_Meter_Result,		"TI Read BER Meter Result: {dut}"},
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },
};

const CLICmds gCliCmdTableSSV[] =
{
	{ "reg-read",	            Cmd_Reg_Read, 		                        "SSV read reg:  {addr}"				 },
	{ "reg-write",	            Cmd_Reg_Write,		                        "SSV write reg: {addr, value_w}."		},
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },
};

const CLICmds gCliCmdTableParameter[] =
{
    { "adv.param.1",    Cmd_Adv_time_indep_all_param_check_with_adv_ind,            "Advertiser Parameter testing :check all var combined with adv_x_ind only"       },   
    { "adv.param.2",    Cmd_Adv_time_indep_all_param_check_with_scn_rsp,            "Advertiser Parameter testing :check all var combined with scn_rsp   only"       },   
    { "adv.param.3",    Cmd_Adv_time_indep_filter_check_with_scn_req,               "Advertiser Parameter testing :check some var combined with filterpolicy (only scan_req)"   },   
    { "adv.param.4",    Cmd_Adv_time_indep_filter_check_with_conn_req,              "Advertiser Parameter testing :check some var combined with filterpolicy (only conn_req)"   },   

    { "adv.param.5",    Cmd_Adv_time_dep_advint_chmap_check_ex_dir_ind,             "Advertiser Parameter testing :check adv interval and ch map exclusive adv_direct_ind"   },   
    { "adv.param.6",    Cmd_Adv_time_dep_advint_chmap_check_with_dir_ind,           "Advertiser Parameter testing :check adv interval and ch map (only adv_direct_ind)"   },   

    { "scn.param.1",    Cmd_Scn_time_indep_all_param_check_passive_with_adv_ind,    "Scanner Parameter testing :check all var combined with adv_ind    (passive)" },
    { "scn.param.2",    Cmd_Scn_time_indep_all_param_check_passive_without_scn_rsp, "Scanner Parameter testing :check all var combined without scn_rsp (passive)" },
    { "scn.param.3",    Cmd_Scn_time_indep_all_param_check_active_with_adv_ind,     "Scanner Parameter testing :check all var combined with adv_ind    (active) " },
    { "scn.param.4",    Cmd_Scn_time_indep_all_param_check_active_with_scn_rsp,     "Scanner Parameter testing :check all var combined with scn_rsp    (active)" },

    { "scn.param.5",    Cmd_Scn_time_dep_scnint_win_check_ex_dir_ind,               "Scanner Parameter testing :check scan interval and window exclusive adv_direct_ind"},   
    { "scn.param.6",    Cmd_Scn_time_dep_scnint_win_check_with_dir_ind,             "Scanner Parameter testing :check scan interval and window (only adv_direct_ind)"   },   

    { "sla.param.1",    Cmd_Sla_time_indep_acl_data_len,                            "Slave Parameter testing  :check Acl data len"                                  },   
    { "sla.param.2",    Cmd_Sla_time_indep_ch_map,                                  "Slave Parameter testing  :check ch map from master"                            },   

    { "sla.param.3",    Cmd_Sla_time_dep_conn_intval,                               "Slave Parameter testing  :check connection interval from master"               },   
    { "sla.param.4",    Cmd_Sla_time_dep_conn_slave_latency,                        "Slave Parameter testing  :check connection slave latency from master"          },   
    { "sla.param.5",    Cmd_Sla_time_dep_conn_supervision_timeout,                  "Slave Parameter testing  :check connection supervision timeout from master"    },   

    { "wl.fun",         Cmd_Whitelist_add_remove,                                   "whitelist add /remove testing : check  add/remove/clear func"                  },   
    { "wl.adv",         Cmd_Whitelist_adv,                                          "whitelist adv testing : check w/wo whitelist and add/remove/clear func"        },   
    { "wl.scn",         Cmd_Whitelist_scn,                                          "whitelist scn testing : check w/wo whitelist and add/remove/clear func"        },   
    { "wl.adv_scn",     Cmd_Whitelist_adv_scn,                                      "whitelist adv+scn testing : check w/wo whitelist and add/remove/clear func"        },   
    { "wl.adv_scn_sla", Cmd_Whitelist_adv_scn_sla,                                  "whitelist adv+scn+slave testing : check w/wo whitelist and add/remove/clear func"        },   
    
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};

const CLICmds gCliCmdTableStable[] =
{
    { "adv.stable.1",   Cmd_Adv_stability_with_adv_ind,                             "Advertiser Stability testing :check with adv_ind"                             },   
    { "adv.stable.2",   Cmd_Adv_stability_with_adv_scan_ind,                        "Advertiser Stability testing :check with adv_scan_ind"                        },   
    { "adv.stable.3",   Cmd_Adv_stability_with_adv_non_ind,                         "Advertiser Stability testing :check with adv_non_ind"                         },   
    { "adv.stable.4",   Cmd_Adv_stability_with_adv_direct_ind,                      "Advertiser Stability testing :check with adv_direct_ind"                      },   

    { "scn.stable.1",   Cmd_Scn_stability_passive_with_adv_ind,                     "Scanner Stability testing :passive check with adv_ind"                         },   
    { "scn.stable.2",   Cmd_Scn_stability_active_with_adv_ind_scn_rsp,              "Scanner Stability testing :active check with adv_ind and scan_rsp"             },   

    { "sla.stable.1",   Cmd_Sla_stability_conn_with_tx_acl_data,                    "Slave Stability testing :connection with tx acl_data (adv direct ind)"         },   
    { "sla.stable.2",   Cmd_Sla_stability_conn_with_rx_acl_data,                    "Slave Stability testing :connection with rx acl_data (adv direct ind)"         },   
    { "sla.stable.2p",  Cmd_Sla_stability_conn_with_rx_acl_data_with_busy_polling, "Slave Stability testing :connection with rx acl_data with busy polling(adv direct ind)"        },   
    { "sla.stable.3",   Cmd_Sla_stability_conn_with_trx_acl_data,                   "Slave Stability testing :connection with trx acl_data (adv direct ind)"        },   

    { "sla.stable.4",   Cmd_Sla_stability_conn_with_tx_acl_data_undir_adv,          "Slave Stability testing :connection with tx acl_data (adv ind)"                },   
    { "sla.stable.5",   Cmd_Sla_stability_conn_with_rx_acl_data_undir_adv,          "Slave Stability testing :connection with rx acl_data (adv ind)"                },   
    { "sla.stable.6",   Cmd_Sla_stability_conn_with_trx_acl_data_undir_adv,         "Slave Stability testing :connection with trx acl_data (adv ind)"                },   

    { "sla.stable.7",   Cmd_Sla_stability_encrypt_with_tx_acl_data,                 "Slave Stability testing :encryption with tx acl data"                          },   
    { "sla.stable.8",   Cmd_Sla_stability_encrypt_with_rx_acl_data,                 "Slave Stability testing :encryption with rx acl data"                          },   
    { "sla.stable.9",   Cmd_Sla_stability_encrypt_with_trx_acl_data,                "Slave Stability testing :encryption with trx acl data"                          },   

    { "sla.stable.10",  Cmd_Sla_stability_ch_map_update,                            "Slave Stability testing :channel map update"                                   },   
    { "sla.stable.11",  Cmd_Sla_stability_conn_param_update,                        "Slave Stability testing :connection parameter update"                          },   
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};

const CLICmds gCliCmdTableStress[] =
{
    { "sla.stress.1",   Cmd_Sla_stress_connect_and_disconnect,                      "Slave Stress testing : connect and disconnet from master"                      },   
    { "sla.stress.1s",  Cmd_Sla_stress_connect_and_disconnect_slave,                "Slave Stress testing : connect and disconnet from slave"                       },   
    { "sla.stress.1rx", Cmd_Sla_stress_connect_and_disconnect_rx_not_sync,          "Slave Stress testing : connect and disconnet from master with check rx not sync" },   

    { "sla.stress.2",   Cmd_Sla_stress_connect_encrypt_disconnect,                  "Slave Stress testing : connect and encryption and disconnet"                   },   
    { "sla.stress.2s",  Cmd_Sla_stress_connect_encrypt_disconnect_slave,            "Slave Stress testing : connect and encryption and disconnet from slave"        },   

//    { "sla.stress.3",   Cmd_Sla_stress_connect_encrypt_reencrypt_disconnect,        "Slave Stress testing : connect and encryption and disconnet"                   },   
//    { "sla.stress.4",   Cmd_Sla_stress_connect_encrypt_reencrypt_disconnect_undir_adv, "Slave Stress testing : connect and encryption and disconnet (adv ind)"         },   

    { "sla.stress.5",   Cmd_Sla_stress_start_and_restart_encryption,                "Slave Stress testing : start and restart encryption with connection"           },   

    { "sla.stress.6",       Cmd_Sla_stress_channel_map_update,                      "Slave Stress testing : channel map update"                                     },   
    { "sla.stress.6.trx",   Cmd_Sla_stress_channel_map_update_max_trx_acl,          "Slave Stress testing : channel map update with max trx acl data"               },   

    { "sla.stress.7",   Cmd_Sla_stress_connect_param_update_with_slave_latency,     "Slave Stress testing : connection parameter update with random slave latency"  },   
    { "sla.stress.8",   Cmd_Sla_stress_connect_param_update_with_conn_interval,     "Slave Stress testing : connection parameter update with random conn interval"  },   
    { "sla.stress.8.trx",   Cmd_Sla_stress_connect_param_update_with_conn_interval_max_trx_acl,    
                                                                                    "Slave Stress testing : connection parameter update with random conn interval , max trx acl data"  },   
    { "sla.stress.8.ppm",   Cmd_Sla_stress_connect_param_update_max_conn_interval_slave_latency,    
                                                                                    "Slave Stress testing : connection parameter update with max conn interval / slave latency"  },   
    { "sla.stress.9",   Cmd_Sla_stress_connect_param_update_max_min_conn_interval_and_channel_map_update,    
                                                                                    "Slave Stress testing : connection parameter update with max / min conn interval and channel map update"  },


    { "sla.stress.tr.1",Cmd_Sla_stress_traffic_tx_acl_data,                         "Slave Stress testing : heavy traffic with tx acl data"  },   
    { "sla.stress.tr.2",Cmd_Sla_stress_traffic_rx_acl_data,                         "Slave Stress testing : heavy traffic with tx acl data"  },   
    { "sla.stress.tr.4",Cmd_Sla_stress_traffic_encrypt_trx_acl_data,                "Slave Stress testing : heavy traffic with encrypted trx acl data"  },   
    { "sla.stress.tr.5",Cmd_Sla_stress_traffic_encrypt_trx_acl_data_6pdu,           "Slave Stress testing : heavy traffic with encrypted trx acl data 6pdu"  },

    { "sla.stress.tp.1",Cmd_Sla_stress_max_traffic_tx_acl_data,                     "Slave Stress testing : max traffic with tx acl data"  },   
    { "sla.stress.tp.2",Cmd_Sla_stress_max_traffic_rx_acl_data,                     "Slave Stress testing : max traffic with rx acl data"  },   
    { "sla.stress.tp.3",Cmd_Sla_stress_max_traffic_trx_acl_data,                    "Slave Stress testing : max traffic with trx acl data"  },   
    { "sla.stress.tp.4",Cmd_Sla_stress_max_traffic_encrypt_tx_acl_data,             "Slave Stress testing : max traffic with tx  encry acl data"  },   
    { "sla.stress.tp.5",Cmd_Sla_stress_max_traffic_encrypt_rx_acl_data,             "Slave Stress testing : max traffic with rx  encry acl data"  },   
    { "sla.stress.tp.6",Cmd_Sla_stress_max_traffic_encrypt_trx_acl_data,            "Slave Stress testing : max traffic with trx encry acl data"  },   
//    { "sla.stress.llcp.1",Cmd_Sla_stress_random_llcp,                               "Slave Stress testing : max traffic with trx encry acl data"  },   

    { "sla.stress.12"  ,Cmd_Sla_stress_max_traffic_tx_acl_data_without_flow_ctrl,     "Slave Stress testing : max traffic with tx acl data without flow ctrl"  },
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};


const CLICmds gCliCmdTablePerformance[] =
{
	{ "perf.scn.active",	    Cmd_Perf_Scan_Active,	                    "active  Scan performance check: {dut1}{dut2}"	        },
    { "perf.scn.passive",       Cmd_Perf_Scan_Passive,                      "passive Scan performance check: {dut1}{dut2}"          },
    { "perf.adv_scn.adv",       Cmd_Perf_Adv_plus_scan_favor_adv,           "adv+scan favor adv performance check: {dut1}{dut2}"},
    { "perf.adv_scn.scn",       Cmd_Perf_Adv_plus_scan_favor_scn,           "adv+scan favor scan performance check: {dut1}{dut2}"},

    { "exit",                   Cmd_Exit,                                   "Terminate ble system."                                 },
    { "echo",                   Cmd_Echo,                                   "Echo argv."                                            },
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};

const CLICmds gCliCmdTableSIG[] =
{
	{ "5.2.1.1",	  Cmd_DDI_ADV_Non_Connectable_Advertising_Events,	    "Non.Connectable Advertising Events: {dut1}{dut2}"	    },
	{ "5.2.1.2",	  Cmd_DDI_ADV_Undirected_Advertising_Events,		    "Undirected_Advertising_Events: {dut1}{dut2}"	        },
	{ "5.2.1.3",	  Cmd_DDI_ADV_Advertising_Data_Non_Connectable, 	    "Advertising Data: Non.Connectable: {dut1}{dut2}"	    },
	{ "5.2.1.4",	  Cmd_DDI_ADV_Advertising_Data_Undirected,			    "Advertising Data: Undirected: {dut1}{dut2}"	        },
    { "5.2.1.5",	  Cmd_DDI_ADV_Scan_Request_Undirected_Connectable,	    "Scan Request: Undirected Connectable: {dut1}{dut2}"    },
    { "5.2.1.6",	  Cmd_DDI_ADV_Connection_Request,	                    "Connection Request: {dut1}{dut2}"	                    },
    { "5.2.1.7",	  Cmd_DDI_ADV_Scan_Request_Connection_Request,		    "Scan Request Connection Request: {dut1}{dut2}"         },
	{ "5.2.1.8",	  Cmd_DDI_ADV_Scan_Request_Device_Filtering,		    "Scan Request Device Filtering: {dut1}{dut2}"           },
	{ "5.2.1.9",	  Cmd_DDI_ADV_Connection_Request_Device_Filtering,	    "Connection Request Device Filtering: {dut1}{dut2}"     },
	{ "5.2.1.10",	  Cmd_DDI_ADV_Directed_Advertising_Events,			    "Directed Advertising Events: {dut1}{dut2}"             },
	{ "5.2.1.11",	  Cmd_DDI_ADV_Discoverable_Advertising_Events,		    "Discoverable Advertising Events: {dut1}{dut2}"         },
	{ "5.2.1.12",	  Cmd_DDI_ADV_Advertising_Data_Discoverable,		    "Advertising Data: Discoverable: {dut1}{dut2}"          },
    { "5.2.1.13",     Cmd_DDI_ADV_Scan_Request_Discoverable,                "Scan Request: Discoverable: {dut1}{dut2}"              },
    { "5.2.1.14",	  Cmd_DDI_ADV_Device_Filtering_Discoverable,		    "Device Filtering Discoverable: {dut1}{dut2}"           },
    { "5.2.2.1",	  Cmd_DDI_SCN_Passive_Scanning_Non_Connectable, 	    "Passive Scanning: Non Connectable: {dut1}{dut2}"	    },
    { "5.2.2.2",	  Cmd_DDI_SCN_Passive_Scanning_Device_Filtering, 	    "Passive Scanning Device Filtering: {dut1}{dut2}"	    },
    { "5.2.2.3",	  Cmd_DDI_SCN_Active_Scanning,						    "Active Scanning {dut1}{dut2}"	                        },
	{ "5.2.2.4",	  Cmd_DDI_SCN_Active_Scanning_Device_Filtering, 	    "Active Scanning Device Filtering {dut1}{dut2}"         },
	{ "5.2.2.5",	  Cmd_DDI_SCN_Scanning_For_Advertiser_Types,		    "Scanning For Advertiser Types {dut1}{dut2}"	        },
	{ "5.2.2.6",	  Cmd_DDI_SCN_Passive_Scanning_Undirected_Events,	    "Passive Scanning: Undirected Events: {dut1}{dut2}" 	},
    { "5.2.2.7",	  Cmd_DDI_SCN_Passive_Scanning_Directed_Events,	        "Passive Scanning: Directed Events: {dut1}{dut2}" 	    },
    { "5.2.2.8",	  Cmd_DDI_SCN_Passive_Scanning_Discoverable_Events,	    "Passive Scanning: Discoverable Events: {dut1}{dut2}"   },
    { "5.3.1.1",      Cmd_CON_ADV_Accepting_Connections,                    "Accepting Connections: {dut1}{dut2}"                   },
	{ "5.3.1.2",	  Cmd_CON_ADV_Accepting_Connections_Timeout,		    "Accepting Connections Timeout: {dut1}{dut2}"	        },
	{ "5.3.1.4",	  Cmd_CON_ADV_Directed_Advertising_Connection,		    "Directed Advertising Connection: {dut1}{dut2}"         },
	{ "5.3.2.1",	  Cmd_CON_INI_Connection_Initiation,		    		"Connection Initiation: {dut1}{dut2}"  		       		},
	{ "5.3.2.2",	  Cmd_CON_INI_Connecting_to_Directed_Advertising,		"Connecting to Directed Advertising: {dut1}{dut2}"      },
	{ "5.3.2.5",	  Cmd_CON_INI_Initiation_Device_Filtering_Undirected,	"Initiation Device Filtering Undirected: {dut1}{dut2}"  },
	{ "5.3.2.6",	  Cmd_CON_INI_Initiation_Device_Filtering_Directed,		"Initiation Device Filtering Directed: {dut1}{dut2}"    },
    { "5.3.3.1",      Cmd_CON_SLA_Slave_Asymmetric_Connections,             "Slave Asymmetric Connections: {dut1}{dut2}"            },
	{ "5.3.3.2",	  Cmd_CON_SLA_Slave_Sending_Data,					    "Slave Sending Data: {dut1}{dut2}"                      },
	{ "5.3.3.3",	  Cmd_CON_SLA_Slave_Receiving_Data, 				    "Slave Receiving Data: {dut1}{dut2}"                    },
	{ "5.3.3.4",	  Cmd_CON_SLA_Slave_Sending_and_Receiving_Data, 	    "Slave Sending and Receiving Data: {dut1}{dut2}"        },
    { "5.3.3.5",      Cmd_CON_SLA_Accepting_Parameter_Update,               "Accepting Parameter Update: {dut1}{dut2}"              },
    { "5.3.3.6",      Cmd_CON_SLA_Slave_Sending_Termination,                "Slave Sending Termination]: {dut1}{dut2}"              },
    { "5.3.3.7",      Cmd_CON_SLA_Slave_Accepting_Termination,              "Slave Accepting Termination]: {dut1}{dut2}"              },
	{ "5.3.3.8",	  Cmd_CON_SLA_Slave_Supervision_Timer,				    "Slave Supervision Timer: {dut1}{dut2}"                 },
	{ "5.3.3.9",	  Cmd_CON_SLA_Feature_Setup_Response,				    "Feature Setup Response: {dut1}{dut2}"                  },
	{ "5.3.3.14",	  Cmd_CON_SLA_Slave_Request_Version,				    "Slave_Request_Version: {dut1}{dut2}"                   },
	{ "5.3.3.15",	  Cmd_CON_SLA_Slave_Respond_Version,				    "Slave Respond Version: {dut1}{dut2}"                   },
    { "5.3.3.16",     Cmd_CON_SLA_Slave_Acknowledgement_Scheme,             "Slave Acknowledgement Scheme: {dut1}{dut2}"                   },
	{ "5.4.1.2",	  Cmd_CON_MAS_Master_Sending_Data,					    "Master Sending Data: {dut1}{dut2}"                     },
	{ "5.4.1.3",	  Cmd_CON_MAS_Master_Receiving_Data,				    "Master Receiving Data: {dut1}{dut2}"                   },
	{ "5.4.1.4",	  Cmd_CON_MAS_Master_Sending_and_Receiving_Data,	    "Master Sending and Receiving Data: {dut1}{dut2}"       },
	{ "5.4.1.5",	  Cmd_CON_MAS_Events_With_Slave_Latency,			    "Master Events With Slave Latency: {dut1}{dut2}"        },
	{ "5.4.1.6",	  Cmd_CON_MAS_Master_Acknowledgement_Scheme,		    "Master Acknowledgement Scheme: {dut1}{dut2}"           },
	{ "5.4.1.8",	  Cmd_CON_MAS_Master_Supervision_Timer, 			    "Master Supervision Timer: {dut1}{dut2}"                },
	{ "5.4.1.9",	  Cmd_CON_MAS_Feature_Setup_Request,				    "Feature Setup Request: {dut1}{dut2}"                   },
//	{ "5.4.1.10",	  Cmd_CON_MAS_Transmit_Fragmented_L2CAP_Header,			"Master Transmit Fragmented L2CAP Header: {dut1}{dut2}" },
//	{ "5.4.1.11",	  Cmd_CON_MAS_Receive_Fragmented_L2CAP_Header,		    "Master Receive Fragmented L2CAP Header: {dut1}{dut2}"  },
	{ "5.4.1.16",	  Cmd_CON_MAS_Master_Request_Version,				    "Master Request Version: {dut1}{dut2}"                  },
	{ "5.4.1.17",	  Cmd_CON_MAS_Master_Respond_Version,				    "Master Respond Version: {dut1}{dut2}"                  },
    { "5.5.1.1",      Cmd_TIM_ADV_Earliest_transmission_to_Advertiser,      "Earliest transmission to Advertiser: {dut1}{dut2}"     },
    { "5.5.2.1",      Cmd_TIM_SLA_Adjusting_Anchor_Point,                   "Adjusting Anchor Point: {dut1}{dut2}"     },
    { "5.5.2.2",      Cmd_TIM_SLA_Earliest_Transmission_Start_to_Slave,     "Earliest Transmission Start to Slave: {dut1}{dut2}"     },
    { "5.5.2.3",      Cmd_TIM_SLA_Latest_Transmission_Start_to_Slave,       "Latest Transmission Start to Slave: {dut1}{dut2}"     },
    { "5.5.2.4",      Cmd_TIM_SLA_Shortest_Connection_Interval,             "Shortest Connection Interval: {dut1}{dut2}"     },
    { "5.7.1.1",      Cmd_FRH_ADV_Accepting_Connections_with_Hop_Lengths ,  "Accepting Connections with Hop Lengths: {dut1}{dut2}"  },
    { "5.7.2.1",      Cmd_FRH_SLA_Accepting_Channel_Map_Update ,            "Accepting Channel Map Update: {dut1}{dut2}"  },
	{ "5.9.1.1",	  Cmd_SEC_ADV_Advertising_With_Random_Address,		    "Advertising With Random Address: {dut1}{dut2}"         },
	{ "5.9.2.1",	  Cmd_SEC_SCN_Random_Address_Scanning,				    "Random Address Scanning: {dut1}{dut2}"                 },
	{ "5.9.4.1",	  Cmd_SEC_SLA_Slave_Encryption_Mode_Setup,			    "Slave Encryption Mode Setup: {dut1}{dut2}"             },
	{ "5.9.4.2",	  Cmd_SEC_SLA_Slave_Pause_Encryption,				    "Slave Pause Encryption: {dut1}{dut2}"                  },
	{ "5.9.4.3",	  Cmd_SEC_SLA_Slave_Pause_Encryption_Sending_Data,	    "Slave Pause Encryption Sending Data: {dut1}{dut2}"     },
	{ "5.9.4.4",	  Cmd_SEC_SLA_Slave_Sending_Reject_Ind, 			    "Slave Sending Reject_Ind: {dut1}{dut2}"                },
	{ "5.9.4.5",	  Cmd_SEC_SLA_Slave_Receiving_Encrypted_Data,		    "Slave Receiving Encrypted Data: {dut1}{dut2}"          },
	{ "5.10.1.1",	  Cmd_SEC_MAS_Master_Encryption_Mode_Setup, 		    "Master Encryption Mode Setup: {dut1}{dut2}"            },
	{ "5.10.1.2",	  Cmd_SEC_MAS_Master_Pause_Encryption,				    "Master Pause Encryption: {dut1}{dut2}"                 },
	{ "5.10.1.3",	  Cmd_SEC_MAS_Master_Receiving_Reject_Ind,			    "Master Receiving Reject_Ind: {dut1}{dut2}"             },
	{ "5.10.1.4",	  Cmd_SEC_MAS_Master_Encryption_Sending_Data_Before_LL_ENC_RSP, "Master Encryption: Sending Data Before LL_ENC_RSP: {dut1}{dut2}"   },
	{ "5.10.1.6",	  Cmd_SEC_MAS_Master_Encryption_Setup_Missing_Response, 		"Master Encryption Setup: Missing Response: {dut1}{dut2}"           },
	{ "5.10.1.7",	  Cmd_SEC_MAS_Master_Encryption_Setup_Missing_Request,			"Master Encryption Setup: Missing Request: {dut1}{dut2}"            },
   	{ "5.10.1.11",	  Cmd_SEC_MAS_Master_Pause_Encryption_Sending_Data, 			"Master Pause Encryption Sending Data: {dut1}{dut2}"                },
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};

const CLICmds gCliCmdTableProflie[] =
{
    { "heartrate.1",    Cmd_Profile_Heart_Rate_1,                                   "Host-like : Heart Rate Sensor. first 30sec , Collector first 30sec"},   
    { "heartrate.2",    Cmd_Profile_Heart_Rate_2,                                   "Host-like : Heart Rate Sensor. first 30sec , Collector after 30sec"},   
    { "heartrate.3",    Cmd_Profile_Heart_Rate_3,                                   "Host-like : Heart Rate Sensor. after 30sec , Collector first 30sec"},   
    { "heartrate.4",    Cmd_Profile_Heart_Rate_4,                                   "Host-like : Heart Rate Sensor. after 30sec , Collector after 30sec"},   

    { "hid.1",          Cmd_Profile_HID_1,                                          "Host-like : HID. adv int 30ms ; scan int 22.5ms ,win 11.25ms "},   
    { "hid.2",          Cmd_Profile_HID_2,                                          "Host-like : HID. adv int 30ms ; scan int 1.28 s ,win 11.25ms"},   
    { "hid.3",          Cmd_Profile_HID_3,                                          "Host-like : HID. adv int 30ms ; scan int 30  ms ,win 30   ms"},    
    { "hid.4",          Cmd_Profile_HID_4,                                          "Host-like : HID. dir-adv + undir-adv int 20ms ; scan int 22.5ms ,win 11.25ms "},   
    { "hid.5",          Cmd_Profile_HID_5,                                          "Host-like : HID. dir-adv + undir-adv int 20ms ; scan int 1.28 s ,win 11.25ms "},   
    { "hid.6",          Cmd_Profile_HID_6,                                          "Host-like : HID. dir-adv + undir-adv int 20ms ; scan int 30  ms ,win 30   ms "},   
    { "hid.7",          Cmd_Profile_HID_7,                                          "Host-like : HID. undir-adv int 1s ; scan int 22.5ms ,win 11.25ms "},   
    { "hid.8",          Cmd_Profile_HID_8,                                          "Host-like : HID. undir-adv int 1s ; scan int 1.28 s ,win 11.25ms "},   
    { "hid.9",          Cmd_Profile_HID_9,                                          "Host-like : HID. undir-adv int 1s ; scan int 30  ms ,win 30   ms "},   
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};

const CLICmds gCliCmdTableFaulty[] =
{

    { "faulty.idle.1",         Cmd_Idle_acl_data,                                   "Idle acl data {dut1}"},
    { "faulty.idle.2",         Cmd_Idle_read_remote_info,                           "Idle read remote info {dut1}"},
    { "faulty.idle.3",         Cmd_Idle_disconnect,                                 "Idle disconnect {dut1}"},
    { "faulty.idle.4",         Cmd_Idle_LTK_req,                                    "Idle LTK req {dut1}"},
    { "faulty.idle.5",         Cmd_Idle_LTK_req_nrep,                               "Idle LTK req nrep {dut1}"},   

    { "faulty.adv.1",          Cmd_Adv_set_param,                                   "Adv set param {dut1}{dut2}"},
    { "faulty.adv.2",          Cmd_Adv_acl_data,                                    "Adv acl data {dut1}{dut2}"},   
    { "faulty.adv.3",          Cmd_Adv_read_remote_info,                            "Adv read remote info {dut1}{dut2}"},   
    { "faulty.adv.4",          Cmd_Adv_disconnect,                                  "Adv disconnect {dut1}{dut2}"},
    { "faulty.adv.7",          Cmd_Adv_LTK_req,                                     "Adv_LTK_req {dut1}{dut2}"},   
    { "faulty.adv.8",          Cmd_Adv_LTK_req_nrep,                                "Adv LTK req nrep {dut1}{dut2}"},   
    { "faulty.adv.9",          Cmd_Adv_data_with_adv_direct_ind,                    "Adv data with adv direct ind {dut1}{dut2}"},

    { "faulty.scn.1",          Cmd_Scn_set_param,                                   "Scn set param {dut1}{dut2}"},   
    { "faulty.scn.2",          Cmd_Scn_acl_data,                                    "Scn acl data {dut1}{dut2}"},   
    { "faulty.scn.3",          Cmd_Scn_read_remote_info,                            "Scn read remote info {dut1}{dut2}"},   
    { "faulty.scn.4",          Cmd_Scn_disconnect,                                  "Scn disconnect {dut1}{dut2}"},   
    { "faulty.scn.7",          Cmd_Scn_LTK_req,                                     "Scn LTK req {dut1}{dut2}"},   
    { "faulty.scn.8",          Cmd_Scn_LTK_req_nrep,                                "Scn LTK req nrep {dut1}{dut2}"},

    { "faulty.sla.1",          Cmd_Sla_disconnect_twice,                            "Sla disconnect twice {dut1}{dut2}"},       
    { "faulty.sla.3",          Cmd_Sla_acl_data_err_handle,                         "Sla acl data err handle {dut1}{dut2}"},
    { "faulty.sla.4",          Cmd_Sla_read_remote_info_err_handle,                 "Sla read remote info err handle {dut1}{dut2}"},
    { "faulty.sla.5",          Cmd_Sla_disconnect_err_handle,                       "Sla disconnect err handle {dut1}{dut2}"},   
    { "faulty.sla.8",          Cmd_Sla_LTK_req_error_handle,                        "Sla LTK req error handle {dut1}{dut2}"},   
    { "faulty.sla.9",          Cmd_Sla_LTK_req_nrep_error_handle,                   "Sla LTK req nrep error handle {dut1}{dut2}"},   

    { "reset.adv.1",           Cmd_Adv_reset_enable,                                "Adv reset enable {dut1}{dut2}"},   
    { "reset.scn.1",           Cmd_Scn_reset_enable,                                "Scn reset enable {dut1}{dut2}"},   
    { "reset.sla.1",           Cmd_Sla_reset_adv,                                   "Sla reset adv {dut1}{dut2}"},   
    { "reset.sla.2",           Cmd_Sla_reset_scn,                                   "Sla reset scn {dut1}{dut2}"},   
    { "reset.enc.1",           Cmd_Sla_Recv_LTK_req_reset,                          "Sla reset when encryption"},

    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};

const CLICmds gCliCmdTableCFI[] =
{
    { "cfi.446",          Cmd_CFI_446,                                  " disconnect with peer reset{dut1}{dut2}"},   
// for ti only        
    { "cfi.451.1",          Cmd_CFI_451_1,                                  " disconnect with peer connection param update{dut1}{dut2}"},   
    { "cfi.451.2",          Cmd_CFI_451_2,                                  " disconnect with peer ch map update{dut1}{dut2}"},   
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};

const CLICmds gCliCmdTableFunc[] =
{
    { "func.adv.data",  Cmd_Adv_modify_adv_data_and_scn_rsp_data,           "Check modify adv data/scan rsp data when advertising"},
    { "func.sla.conn",  Cmd_Sla_check_conn_with_all_adv_type,               "check connection with correct adv type"},

    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};

const CLICmds gCliCmdTableMulti[] =
{
    { "adv.scn.1",          Cmd_Adv_scn_enable,                                  "Adv scn enable {dut1}{dut2}"},   
    { "adv.scn.2",          Cmd_Adv_scn_param,                                   "Adv scn param {dut1}{dut2}"},   

    { "scn_adv.1",          Cmd_Scn_adv_enable,                                  "Scn adv enable {dut1}{dut2}"},
    { "scn_adv.2",          Cmd_Scn_adv_param,                                   "Scn adv param {dut1}{dut2}"},   
#if 0
    { "sla_adv.1",          Cmd_Sla_Adv_enable,                               "Host-like : Heart Rate Sensor. first 30sec , Collector first 30sec"},   
    { "sla_adv.2",          Cmd_Sla_Adv_set_param,                            "Host-like : Heart Rate Sensor. first 30sec , Collector first 30sec"},   

    { "sla_scn.1",          Cmd_Sla_scn_enable,                               "Host-like : Heart Rate Sensor. after 30sec , Collector first 30sec"},   
    { "sla_scn.2",          Cmd_Sla_scn_param,                                "Host-like : Heart Rate Sensor. after 30sec , Collector first 30sec"},   
#endif

    { "perf.sla_adv.1",       Cmd_Perf_Sla_Adv_1,                               "Perf Sla Adv {Sla/Adv(ADV_NONCONN_IND)} {Mas} {Scn(PARAM_PASSIVE_SCAN)}"},
    { "perf.sla_adv.2",       Cmd_Perf_Sla_Adv_2,                               "Perf Sla Adv {Sla/Adv(ADV_NONCONN_IND)} {Mas} {Scn(PARAM_ACTIVE_SCAN)}"},
    { "perf.sla_adv.3",       Cmd_Perf_Sla_Adv_3,                               "Perf Sla Adv {Sla/Adv(ADV_SCAN_IND)} {Mas} {Scn(PARAM_PASSIVE_SCAN)}"},
    { "perf.sla_adv.4",       Cmd_Perf_Sla_Adv_4,                               "Perf Sla Adv {Sla/Adv(ADV_SCAN_IND)} {Mas} {Scn(PARAM_ACTIVE_SCAN)}"},
    { "perf.sla_scn.1",       Cmd_Perf_Sla_Scn_1,                               "Perf Sla Scn {Sla/Scn(PARAM_PASSIVE_SCAN)} {Mas} {Adv(ADV_NONCONN_IND)}"},
    { "perf.sla_scn.2",       Cmd_Perf_Sla_Scn_2,                               "Perf Sla Scn {Sla/Scn(PARAM_PASSIVE_SCAN)} {Mas} {Adv(ADV_SCAN_IND)}"},
    { "perf.sla_scn.3",       Cmd_Perf_Sla_Scn_3,                               "Perf Sla Scn {Sla/Scn(PARAM_ACTIVE_SCAN)} {Mas} {Adv(ADV_NONCONN_IND)}"},
    { "perf.sla_scn.4",       Cmd_Perf_Sla_Scn_4,                               "Perf Sla Scn {Sla/Scn(PARAM_ACTIVE_SCAN)} {Mas} {Adv(ADV_SCAN_IND)}"},
    { "perf.sla_adv_scn",   Cmd_Perf_Sla_Adv_Scn,                               "Perf Sla Adv Scn {Sla/Adv/Scn} {Mas} {Scn} {Adv}"},
    { "perf.sla_adv_scn.trx",   Cmd_Perf_Sla_Adv_Scn_trx,                       "Perf Sla Adv Scn max trx acl data {Sla/Adv/Scn} {Mas} {Scn} {Adv}"},
    { "perf.sla_adv_scn.iv_update",   Cmd_Perf_Sla_Adv_Scn_iv_update,           "Perf Sla Adv Scn conn param update {Sla/Adv/Scn} {Mas} {Scn} {Adv}"},
    { "perf.sla_adv_scn.ch_update",   Cmd_Perf_Sla_Adv_Scn_ch_update,           "Perf Sla Adv Scn ch map update request {Sla/Adv/Scn} {Mas} {Scn} {Adv}"},
    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};


const CLICmds gCliCmdTableDTM[] =
{
	{ "ti-dtm-tx",			    Cmd_TI_Dtm_Tx, 	                            "TI DTM Tx: {dut, ch, pkt_cnt, pkt_len, pld_tp}." 	    },
	{ "ti-dtm-tx-cont",		    Cmd_TI_Dtm_Tx_Cont,	                        "TI DTM Tx continue: {dut, ch, pkt_cnt, pkt_len, pld_tp }."   },
    { "ti-dtm-tx-cont-end",     Cmd_TI_Dtm_Tx_Cont_End,                     "TI DTM Tx continue End: {dut, ch, pkt_cnt, pkt_len, pld_tp }."   },
	{ "ti-dtm-rx",			    Cmd_TI_Dtm_Rx, 	                            "TI DTM Rx: {dut, ch}."				                    },
	{ "ti-dtm-end", 		    Cmd_TI_Dtm_End,	                            "TI DTM End:{dut}." 				                    },
	{ "ti-dtm", 			    Cmd_TI_DTM,		                            "TI Dtm:	{dut1, dut2, rfch, cnt}"				    },
	{ "ti-auto-dtm",		    Cmd_TI_Auto_DTM,	                        "TI DTM Auto Dtm: {dut1}.{dut2}"				        },

    { "le-tx-test", 		    Cmd_Transmit_Test,                          "LE_Transmitter_Tests:{dut, ch, pkt_len, pld_tp}"       },
	{ "le-rx-test", 		    Cmd_Receive_Test,	                        "LE_Receive_Tests:{dut}"                                },
	{ "le-end-test",		    Cmd_Test_end,		                        "LE_Test_End:{dut}"                                     },
	{ "ssv-tx-test",	        Cmd_SSV_Transmit_Test,                      "SSV LE_Transmitter_Tests:{dut , ch , pkt_cnt ,pkt_len ,pld_tp}"        },

	{ "ssv-auto-dtm",	        Cmd_SSV_Auto_Dtm, 	                        "SSV Auto Dtm:       {ti_dut , ssv_dut, pkt_cnt ,pkt_len ,pld_tp ,loop_cnt}" },
	{ "ssv-dtm-pattern",	    Cmd_SSV_Dtm_Pattern, 	                    "SSV Dtm Pattern     {ti_dut , ssv_dut}" },

    { (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },

};


#define LELOCAL_FEATURE
#define LE_SUPPORTED_STATES

const CLICmds gCliCmdTable[] =
{
    { "update-br",              Cmd_Update_Dut_Baudrate,                    "Update Dut Baudrate."                                      },
    { "cfg-load",               Cmd_Comm_config_load,                       "Config load"},
	{ "comm-init",			    Cmd_Comm_init, 	                            "Common Init:{dut}"						                },

	{ "check-pld",			    Cmd_dut_check_payload, 	                    "Dut Check Payload:{dut}{enable}"						        },     

	{ "read_bd_addr",		    Cmd_COMM_Read_BD_Addr, 					    "Read BD Addr:{dut}"							        },
	{ "dev_addr_set",		    Cmd_COMM_Device_Address_Set,				"Device_Address_Set: {dut}" 			                },

    { "add_white_list",          Cmd_COMM_White_List_Add,                    "Add White list"                                        },
    { "rm_white_list",          Cmd_COMM_White_List_Remove,                 "Remove White list"                                     },

    { "read_local_feat",        Cmd_COMM_Read_Local_features,               "Read Local Features: {dut}"                             },
    { "read_remote_feat",       Cmd_COMM_Read_Remote_features,              "Read Remote Features: {dut}"                             },
    { "read_local_cmd",         Cmd_COMM_Read_Local_commands,               "Read Local Supported Commands: {dut}"                   },
    { "read_le_local_feat",     Cmd_COMM_LE_Read_Local_features,            "LE Read Local Features: {dut}"                             },
    { "read_le_support_state",  Cmd_COMM_LE_Read_Local_supported_states,    "LE Read Support States: {dut}"                             },
    { "read_buff",              Cmd_COMM_Read_LE_Buffer_Size,               "Read LE Buffer Size: {dut}"                             },

	{ "ch_map_set", 		    Cmd_COMM_Ch_Map_Set,						"Ch_Map_Set: {dut}" 				                    },
	{ "conn_update_set",	    Cmd_COMM_Conn_Upate_Set,					"Conn_Update_Set: {dut}"				                },

	{ "send_acl_data",		    Cmd_COMM_Send_ACL_Data,					    "Send_ACL_Data: {dut}"					                },
	{ "recv_acl_data",		    Cmd_COMM_Recv_ACL_Data,					    "Recv_ACL_Data: {dut}"					                },

	{ "data-frag",			    Cmd_COMM_Send_ACL_Data_Fragement,		    "Send_ACL_Data: {dut}" 				                    },
	{ "data-trx",			    Cmd_COMM_Send_ACL_Data_Echo,				"Echo_ACL_Data: {dut}" 				                    },

    { "adv-adv_param_set",	    Cmd_COMM_ADV_Advertising_Parameters_Set,	"ADV_Advertising_Parameters_Set: {dut1}"	            },
    { "adv-adv_data_set",       Cmd_COMM_ADV_Advertising_Data_Set,          "ADV_Advertising_Data_Set: {dut1}"                },
	{ "adv-scn_rsp_set",	    Cmd_COMM_Scan_Response_Data_Set,			"set scan response data: {dut}"	                        },
	{ "adv-non_conn_adv",	    Cmd_COMM_ADV_NonConnectable_Advertising,	"ADV_Non-Connectable_Advertising: {dut1}"               },
	{ "adv-undir_adv",		    Cmd_COMM_ADV_Undirected_Advertising,		"ADV_Undirected_Advertising: {dut1}"		            },
	{ "advu",		    		Cmd_COMM_ADV_Undirected_Advertising,		"ADV_Undirected_Advertising: {dut1}"		            },
	{ "advs",		    		Cmd_COMM_ADV_Undirected_Advertising_Stress,	"ADV_Undirected_Advertising_Stress: {dut1}"	            },
	{ "inis",		    		Cmd_COMM_Initiator_Stress,	                "ADV_Initiator_Stress: {dut1}"		                    },
	{ "adv-undir_adv_test",     Cmd_COMM_ADV_Undirected_Advertising_Test,	"ADV_Undirected_Advertising: {dut1}"		            },
	{ "adv-disc_adv",		    Cmd_COMM_ADV_Discoverable_Advertising, 	    "ADV_Discoverable_Advertising: {dut1}"		            },
	{ "adv-dir_adv",		    Cmd_COMM_ADV_Directed_Advertising, 		    "ADV_Directed_Advertising: {dut1}"		                },
	{ "advld",		            Cmd_COMM_ADV_Low_Duty_Directed_Advertising, "ADV_Low_Duty_Directed_Advertising: {dut1}"		                },
	{ "adv-enable",		        Cmd_COMM_ADV_Enable,						"ADV_Enable Advertising: {dut1}{to}"		                },
	{ "adv-disable",		    Cmd_COMM_ADV_Disable,						"ADV_Disable Advertising: {dut1}"		                },
	{ "advd",		    		Cmd_COMM_ADV_Disable,						"ADV_Disable Advertising: {dut1}"		                },

	{ "scn-passive_scan",	    Cmd_COMM_SCN_Passive_Scanning, 			    "SCN_Passive Scanning: {dut1}"		                    },
	{ "scn-active_scan",	    Cmd_COMM_SCN_Active_Scanning,			    "SCN_Active Scanning: {dut1}"		                    },

    { "scn-param_set",          Cmd_COMM_SCN_Parameters_Set,                "SCN_Parameters_Set: {dut1}"                            },
    { "scn-enable",             Cmd_COMM_SCN_Enable,                        "SCN_Enable scanning: {dut1}"                           },
    { "scne",             		Cmd_COMM_SCN_Enable,                        "SCN_Enable scanning: {dut1}"                           },
    { "scnfe",             		Cmd_COMM_FULL_SCN_Enable,                   "SCN_Enable full scanning: {dut1}"                      },
	{ "scn-disable",		    Cmd_COMM_SCN_Disable,						"SCN_Disable scanning: {dut1}"		                    },
	{ "scnd",		    		Cmd_COMM_SCN_Disable,						"SCN_Disable scanning: {dut1}"		                    },
    { "scn-perf"  ,             Cmd_COMM_SCN_Performance,				    "SCN_Performance scanning: {dut1}{Timeout}" },
    { "scn-adv",                Cmd_COMM_MULTI_SCN_ADV_Enable,              "SCN_ADV Enable: {dut1}"                                },

    { "sla.conn.1",             Cmd_Sla_conn_adv_ind,                       "Slave connection testing  :check with adv ind"                                 },   

	{ "test-mas",	            Cmd_TEST_MAS_Master_Sending_Conn_Req,	    "Master Sending Connection Req {dut}"                                           },
    { "master-conn",            Cmd_Master_Conn,                            "init: send conn_req"                                   },
    { "master-disconn",         Cmd_Master_Disconn,                         "master: terminate connection"                          },
    { "master-conn-update",     Cmd_Master_Conn_Update,                     "master: conn parameter update"                         },
    { "master-feature-exchange",Cmd_Master_Feature_Exchange,                "master: do feature exchange"                           },
    { "bcmd-event-log-query",   BCmd_Event_Log_Query,                       "bcmd: event log query"                                 },
 // { "bcmd-event-log-dump",    BCmd_Event_Log_Dump,                        "bcmd: event log dump"                                  },
 // { "bcmd-event-log-reset",   BCmd_Event_Log_Reset,                       "bcmd: event log reset"                                 },
 //	{ "ddi-scn-passive_scan_undir_adv",		  Cmd_TI_DDI_SCN_Passive_Scanning_Undirected_Events,	 "TI SCN_Active Scanning: {dut1}"		},
	{ "uart-tx",	            Cmd_Uart_Testing,                           "Uart Tx To Condor:{dut1}"},
	
	{ "hcicmd-reset",          	Cmd_hcicmd_reset,                      		"HCI cmd - Reset"},
	{ "lecc",	            	Cmd_lecc,                           		"send LE conn_req"},
	{ "ledc",	            	Cmd_ledc,                           		"send LE disconn_req"},
	{ "lecan",	            	Cmd_lecan,                           		"send LE conn_cancel"},
	{ "acl",	            	Cmd_acl,	                           		"send ACL data"},
	{ "dut-reset",            	Cmd_dut_reset,                        		"dut reset with mask_en"},
	{ "dr",            	        Cmd_dut_reset,                        		"dut reset with mask_en"},
	{ "aclf",	            	Cmd_acl_fragment,	                  		"send fragment ACL data"},
	

	/*lint -save -e611 */
	{ (const char *)NULL, (CliCmdFunc)NULL,   (const char *)NULL },
	/*lint -restore */
};


//should init everything , then call the appropriate test pattern
int main(s32 argc, s8 *argv[])
{
    int dut;
    int dut_fd;
	int ret[MAX_DUTS+1] = {FAIL};

    log_svn_info();
    
    bench_config_load(CFG_DEFAULT);
    bench_config_load(CFG_ADV);

    error_addr_config();

    for(dut=1; dut <= s_dev_num; dut++) {
        dut_fd = dut_socket_init(dut);
        if (ERROR == dut_fd) {
			printf(COLOR_WARN "dut(%d): dut_socket_init() fail!!\n" COLOR_NONE, dut);
            continue;
        }
        // TODO: why initialization is chip dependent?
        // TODO: why "chip dependent" pass criterion?
        switch(s_dev_type[dut]) {
            case DUT_TYPE_TI :
                //printf("TI init \n");
                ret[dut] = dut_reset_with_mask_en(dut_fd);
                break;
                
            case DUT_TYPE_SSV:
                //printf("SSV init \n");
                ret[dut] = dut_reset_with_mask_en(dut_fd);
                //SSV_Ble_init(dut_fd);
                //SSV_Slave_subrate(dut_fd);
                break;
                
            case DUT_TYPE_CSR:
				ret[dut] = dut_reset_with_mask_en(dut_fd);
                break;
        }
    }
	// print dut[] info & init result
	printf(COLOR_INFO);
	for (dut=1; dut <= s_dev_num; dut++) {
		dut_fd = dut_socket_init(dut);
		printf("dut(%d): %4s, fd=%d, init %s\n", 
				dut, dut_type_str(s_dev_type[dut]), dut_fd, 
				(ret[dut] == PASS ? "ok!" : "fail!"));
	}
	printf(COLOR_NONE);

    while(1) {
        MSLEEP(1);
        cli_task();
    }

    return 0;
}
